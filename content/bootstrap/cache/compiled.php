<?php
namespace Symfony\Component\Debug {
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Debug\Exception\FlattenException;
use Symfony\Component\Debug\Exception\OutOfMemoryException;
class ExceptionHandler
{
    private $debug;
    private $charset;
    private $handler;
    private $caughtBuffer;
    private $caughtLength;
    private $fileLinkFormat;
    public function __construct($debug = true, $charset = null, $fileLinkFormat = null)
    {
        if (false !== strpos($charset, '%')) {
            $pivot = $fileLinkFormat;
            $fileLinkFormat = $charset;
            $charset = $pivot;
        }
        $this->debug = $debug;
        $this->charset = $charset ?: ini_get('default_charset') ?: 'UTF-8';
        $this->fileLinkFormat = $fileLinkFormat ?: ini_get('xdebug.file_link_format') ?: get_cfg_var('xdebug.file_link_format');
    }
    public static function register($debug = true, $charset = null, $fileLinkFormat = null)
    {
        $handler = new static($debug, $charset, $fileLinkFormat);
        $prev = set_exception_handler(array($handler, 'handle'));
        if (is_array($prev) && $prev[0] instanceof ErrorHandler) {
            restore_exception_handler();
            $prev[0]->setExceptionHandler(array($handler, 'handle'));
        }
        return $handler;
    }
    public function setHandler($handler)
    {
        if (null !== $handler && !is_callable($handler)) {
            throw new \LogicException('The exception handler must be a valid PHP callable.');
        }
        $old = $this->handler;
        $this->handler = $handler;
        return $old;
    }
    public function setFileLinkFormat($format)
    {
        $old = $this->fileLinkFormat;
        $this->fileLinkFormat = $format;
        return $old;
    }
    public function handle(\Exception $exception)
    {
        if (null === $this->handler || $exception instanceof OutOfMemoryException) {
            $this->failSafeHandle($exception);
            return;
        }
        $caughtLength = $this->caughtLength = 0;
        ob_start(array($this, 'catchOutput'));
        $this->failSafeHandle($exception);
        while (null === $this->caughtBuffer && ob_end_flush()) {
        }
        if (isset($this->caughtBuffer[0])) {
            ob_start(array($this, 'cleanOutput'));
            echo $this->caughtBuffer;
            $caughtLength = ob_get_length();
        }
        $this->caughtBuffer = null;
        try {
            call_user_func($this->handler, $exception);
            $this->caughtLength = $caughtLength;
        } catch (\Exception $e) {
            if (!$caughtLength) {
                throw $exception;
            }
        }
    }
    private function failSafeHandle(\Exception $exception)
    {
        if (class_exists('Symfony\\Component\\HttpFoundation\\Response', false) && __CLASS__ !== get_class($this) && ($reflector = new \ReflectionMethod($this, 'createResponse')) && __CLASS__ !== $reflector->class) {
            $response = $this->createResponse($exception);
            $response->sendHeaders();
            $response->sendContent();
            return;
        }
        $this->sendPhpResponse($exception);
    }
    public function sendPhpResponse($exception)
    {
        if (!$exception instanceof FlattenException) {
            $exception = FlattenException::create($exception);
        }
        if (!headers_sent()) {
            header(sprintf('HTTP/1.0 %s', $exception->getStatusCode()));
            foreach ($exception->getHeaders() as $name => $value) {
                header($name . ': ' . $value, false);
            }
            header('Content-Type: text/html; charset=' . $this->charset);
        }
        echo $this->decorate($this->getContent($exception), $this->getStylesheet($exception));
    }
    public function createResponse($exception)
    {
        if (!$exception instanceof FlattenException) {
            $exception = FlattenException::create($exception);
        }
        return Response::create($this->decorate($this->getContent($exception), $this->getStylesheet($exception)), $exception->getStatusCode(), $exception->getHeaders())->setCharset($this->charset);
    }
    public function getContent(FlattenException $exception)
    {
        switch ($exception->getStatusCode()) {
            case 404:
                $title = 'Sorry, the page you are looking for could not be found.';
                break;
            default:
                $title = 'Whoops, looks like something went wrong.';
        }
        $content = '';
        if ($this->debug) {
            try {
                $count = count($exception->getAllPrevious());
                $total = $count + 1;
                foreach ($exception->toArray() as $position => $e) {
                    $ind = $count - $position + 1;
                    $class = $this->formatClass($e['class']);
                    $message = nl2br($this->escapeHtml($e['message']));
                    $content .= sprintf(<<<'EOF'
                        <h2 class="block_exception clear_fix">
                            <span class="exception_counter">%d/%d</span>
                            <span class="exception_title">%s%s:</span>
                            <span class="exception_message">%s</span>
                        </h2>
                        <div class="block">
                            <ol class="traces list_exception">
EOF
, $ind, $total, $class, $this->formatPath($e['trace'][0]['file'], $e['trace'][0]['line']), $message);
                    foreach ($e['trace'] as $trace) {
                        $content .= '       <li>';
                        if ($trace['function']) {
                            $content .= sprintf('at %s%s%s(%s)', $this->formatClass($trace['class']), $trace['type'], $trace['function'], $this->formatArgs($trace['args']));
                        }
                        if (isset($trace['file']) && isset($trace['line'])) {
                            $content .= $this->formatPath($trace['file'], $trace['line']);
                        }
                        $content .= "</li>\n";
                    }
                    $content .= "    </ol>\n</div>\n";
                }
            } catch (\Exception $e) {
                if ($this->debug) {
                    $title = sprintf('Exception thrown when handling an exception (%s: %s)', get_class($e), $this->escapeHtml($e->getMessage()));
                } else {
                    $title = 'Whoops, looks like something went wrong.';
                }
            }
        }
        return <<<EOF
            <div id="sf-resetcontent" class="sf-reset">
                <h1>{$title}</h1>
                {$content}
            </div>
EOF;
    }
    public function getStylesheet(FlattenException $exception)
    {
        return <<<'EOF'
            .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; cursor: default; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, "Times New Roman", Times, serif }
            .sf-reset .exception_counter { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; float: left; display: block; }
            .sf-reset .exception_title { margin-left: 3em; margin-bottom: 0.7em; display: block; }
            .sf-reset .exception_message { margin-left: 3em; display: block; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                word-wrap: break-word;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset a { background:none; color:#868686; text-decoration:none; }
            .sf-reset a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
EOF;
    }
    private function decorate($content, $css)
    {
        return <<<EOF
<!DOCTYPE html>
<html>
    <head>
        <meta charset="{$this->charset}" />
        <meta name="robots" content="noindex,nofollow" />
        <style>
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}
            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
            {$css}
        </style>
    </head>
    <body>
        {$content}
    </body>
</html>
EOF;
    }
    private function formatClass($class)
    {
        $parts = explode('\\', $class);
        return sprintf('<abbr title="%s">%s</abbr>', $class, array_pop($parts));
    }
    private function formatPath($path, $line)
    {
        $path = $this->escapeHtml($path);
        $file = preg_match('#[^/\\\\]*$#', $path, $file) ? $file[0] : $path;
        if ($linkFormat = $this->fileLinkFormat) {
            $link = strtr($this->escapeHtml($linkFormat), array('%f' => $path, '%l' => (int) $line));
            return sprintf(' in <a href="%s" title="Go to source">%s line %d</a>', $link, $file, $line);
        }
        return sprintf(' in <a title="%s line %3$d" ondblclick="var f=this.innerHTML;this.innerHTML=this.title;this.title=f;">%s line %d</a>', $path, $file, $line);
    }
    private function formatArgs(array $args)
    {
        $result = array();
        foreach ($args as $key => $item) {
            if ('object' === $item[0]) {
                $formattedValue = sprintf('<em>object</em>(%s)', $this->formatClass($item[1]));
            } elseif ('array' === $item[0]) {
                $formattedValue = sprintf('<em>array</em>(%s)', is_array($item[1]) ? $this->formatArgs($item[1]) : $item[1]);
            } elseif ('string' === $item[0]) {
                $formattedValue = sprintf("'%s'", $this->escapeHtml($item[1]));
            } elseif ('null' === $item[0]) {
                $formattedValue = '<em>null</em>';
            } elseif ('boolean' === $item[0]) {
                $formattedValue = '<em>' . strtolower(var_export($item[1], true)) . '</em>';
            } elseif ('resource' === $item[0]) {
                $formattedValue = '<em>resource</em>';
            } else {
                $formattedValue = str_replace("\n", '', var_export($this->escapeHtml((string) $item[1]), true));
            }
            $result[] = is_int($key) ? $formattedValue : sprintf("'%s' => %s", $key, $formattedValue);
        }
        return implode(', ', $result);
    }
    protected static function utf8Htmlize($str)
    {
        @trigger_error('The ' . __METHOD__ . ' method is deprecated since version 2.7 and will be removed in 3.0.', E_USER_DEPRECATED);
        return htmlspecialchars($str, ENT_QUOTES | (PHP_VERSION_ID >= 50400 ? ENT_SUBSTITUTE : 0), 'UTF-8');
    }
    private function escapeHtml($str)
    {
        return htmlspecialchars($str, ENT_QUOTES | (PHP_VERSION_ID >= 50400 ? ENT_SUBSTITUTE : 0), $this->charset);
    }
    public function catchOutput($buffer)
    {
        $this->caughtBuffer = $buffer;
        return '';
    }
    public function cleanOutput($buffer)
    {
        if ($this->caughtLength) {
            $cleanBuffer = substr_replace($buffer, '', 0, $this->caughtLength);
            if (isset($cleanBuffer[0])) {
                $buffer = $cleanBuffer;
            }
        }
        return $buffer;
    }
}
}

namespace Symfony\Component\HttpFoundation {
use Symfony\Component\HttpFoundation\Exception\ConflictingHeadersException;
use Symfony\Component\HttpFoundation\Session\SessionInterface;
class Request
{
    const HEADER_FORWARDED = 'forwarded';
    const HEADER_CLIENT_IP = 'client_ip';
    const HEADER_CLIENT_HOST = 'client_host';
    const HEADER_CLIENT_PROTO = 'client_proto';
    const HEADER_CLIENT_PORT = 'client_port';
    const METHOD_HEAD = 'HEAD';
    const METHOD_GET = 'GET';
    const METHOD_POST = 'POST';
    const METHOD_PUT = 'PUT';
    const METHOD_PATCH = 'PATCH';
    const METHOD_DELETE = 'DELETE';
    const METHOD_PURGE = 'PURGE';
    const METHOD_OPTIONS = 'OPTIONS';
    const METHOD_TRACE = 'TRACE';
    const METHOD_CONNECT = 'CONNECT';
    protected static $trustedProxies = array();
    protected static $trustedHostPatterns = array();
    protected static $trustedHosts = array();
    protected static $trustedHeaders = array(self::HEADER_FORWARDED => 'FORWARDED', self::HEADER_CLIENT_IP => 'X_FORWARDED_FOR', self::HEADER_CLIENT_HOST => 'X_FORWARDED_HOST', self::HEADER_CLIENT_PROTO => 'X_FORWARDED_PROTO', self::HEADER_CLIENT_PORT => 'X_FORWARDED_PORT');
    protected static $httpMethodParameterOverride = false;
    public $attributes;
    public $request;
    public $query;
    public $server;
    public $files;
    public $cookies;
    public $headers;
    protected $content;
    protected $languages;
    protected $charsets;
    protected $encodings;
    protected $acceptableContentTypes;
    protected $pathInfo;
    protected $requestUri;
    protected $baseUrl;
    protected $basePath;
    protected $method;
    protected $format;
    protected $session;
    protected $locale;
    protected $defaultLocale = 'en';
    protected static $formats;
    protected static $requestFactory;
    public function __construct(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)
    {
        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
    }
    public function initialize(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)
    {
        $this->request = new ParameterBag($request);
        $this->query = new ParameterBag($query);
        $this->attributes = new ParameterBag($attributes);
        $this->cookies = new ParameterBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());
        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->requestUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
    }
    public static function createFromGlobals()
    {
        $server = $_SERVER;
        if ('cli-server' === PHP_SAPI) {
            if (array_key_exists('HTTP_CONTENT_LENGTH', $_SERVER)) {
                $server['CONTENT_LENGTH'] = $_SERVER['HTTP_CONTENT_LENGTH'];
            }
            if (array_key_exists('HTTP_CONTENT_TYPE', $_SERVER)) {
                $server['CONTENT_TYPE'] = $_SERVER['HTTP_CONTENT_TYPE'];
            }
        }
        $request = self::createRequestFromFactory($_GET, $_POST, array(), $_COOKIE, $_FILES, $server);
        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded') && in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), array('PUT', 'DELETE', 'PATCH'))) {
            parse_str($request->getContent(), $data);
            $request->request = new ParameterBag($data);
        }
        return $request;
    }
    public static function create($uri, $method = 'GET', $parameters = array(), $cookies = array(), $files = array(), $server = array(), $content = null)
    {
        $server = array_replace(array('SERVER_NAME' => 'localhost', 'SERVER_PORT' => 80, 'HTTP_HOST' => 'localhost', 'HTTP_USER_AGENT' => 'Symfony/2.X', 'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5', 'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7', 'REMOTE_ADDR' => '127.0.0.1', 'SCRIPT_NAME' => '', 'SCRIPT_FILENAME' => '', 'SERVER_PROTOCOL' => 'HTTP/1.1', 'REQUEST_TIME' => time()), $server);
        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);
        $components = parse_url($uri);
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }
        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }
        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] = $server['HTTP_HOST'] . ':' . $components['port'];
        }
        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }
        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }
        if (!isset($components['path'])) {
            $components['path'] = '/';
        }
        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
            case 'PATCH':
                $request = $parameters;
                $query = array();
                break;
            default:
                $request = array();
                $query = $parameters;
                break;
        }
        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);
            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }
        $server['REQUEST_URI'] = $components['path'] . ('' !== $queryString ? '?' . $queryString : '');
        $server['QUERY_STRING'] = $queryString;
        return self::createRequestFromFactory($query, $request, array(), $cookies, $files, $server, $content);
    }
    public static function setFactory($callable)
    {
        self::$requestFactory = $callable;
    }
    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)
    {
        $dup = clone $this;
        if ($query !== null) {
            $dup->query = new ParameterBag($query);
        }
        if ($request !== null) {
            $dup->request = new ParameterBag($request);
        }
        if ($attributes !== null) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if ($cookies !== null) {
            $dup->cookies = new ParameterBag($cookies);
        }
        if ($files !== null) {
            $dup->files = new FileBag($files);
        }
        if ($server !== null) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;
        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }
        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($this->getRequestFormat(null));
        }
        return $dup;
    }
    public function __clone()
    {
        $this->query = clone $this->query;
        $this->request = clone $this->request;
        $this->attributes = clone $this->attributes;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
    }
    public function __toString()
    {
        try {
            $content = $this->getContent();
        } catch (\LogicException $e) {
            return trigger_error($e, E_USER_ERROR);
        }
        return sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')) . "\r\n" . $this->headers . "\r\n" . $content;
    }
    public function overrideGlobals()
    {
        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), null, '&')));
        $_GET = $this->query->all();
        $_POST = $this->request->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();
        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (in_array($key, array('CONTENT_TYPE', 'CONTENT_LENGTH'))) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_' . $key] = implode(', ', $value);
            }
        }
        $request = array('g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE);
        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';
        $_REQUEST = array();
        foreach (str_split($requestOrder) as $order) {
            $_REQUEST = array_merge($_REQUEST, $request[$order]);
        }
    }
    public static function setTrustedProxies(array $proxies)
    {
        self::$trustedProxies = $proxies;
    }
    public static function getTrustedProxies()
    {
        return self::$trustedProxies;
    }
    public static function setTrustedHosts(array $hostPatterns)
    {
        self::$trustedHostPatterns = array_map(function ($hostPattern) {
            return sprintf('#%s#i', $hostPattern);
        }, $hostPatterns);
        self::$trustedHosts = array();
    }
    public static function getTrustedHosts()
    {
        return self::$trustedHostPatterns;
    }
    public static function setTrustedHeaderName($key, $value)
    {
        if (!array_key_exists($key, self::$trustedHeaders)) {
            throw new \InvalidArgumentException(sprintf('Unable to set the trusted header name for key "%s".', $key));
        }
        self::$trustedHeaders[$key] = $value;
    }
    public static function getTrustedHeaderName($key)
    {
        if (!array_key_exists($key, self::$trustedHeaders)) {
            throw new \InvalidArgumentException(sprintf('Unable to get the trusted header name for key "%s".', $key));
        }
        return self::$trustedHeaders[$key];
    }
    public static function normalizeQueryString($qs)
    {
        if ('' == $qs) {
            return '';
        }
        $parts = array();
        $order = array();
        foreach (explode('&', $qs) as $param) {
            if ('' === $param || '=' === $param[0]) {
                continue;
            }
            $keyValuePair = explode('=', $param, 2);
            $parts[] = isset($keyValuePair[1]) ? rawurlencode(urldecode($keyValuePair[0])) . '=' . rawurlencode(urldecode($keyValuePair[1])) : rawurlencode(urldecode($keyValuePair[0]));
            $order[] = urldecode($keyValuePair[0]);
        }
        array_multisort($order, SORT_ASC, $parts);
        return implode('&', $parts);
    }
    public static function enableHttpMethodParameterOverride()
    {
        self::$httpMethodParameterOverride = true;
    }
    public static function getHttpMethodParameterOverride()
    {
        return self::$httpMethodParameterOverride;
    }
    public function get($key, $default = null, $deep = false)
    {
        if ($this !== ($result = $this->query->get($key, $this, $deep))) {
            return $result;
        }
        if ($this !== ($result = $this->attributes->get($key, $this, $deep))) {
            return $result;
        }
        if ($this !== ($result = $this->request->get($key, $this, $deep))) {
            return $result;
        }
        return $default;
    }
    public function getSession()
    {
        return $this->session;
    }
    public function hasPreviousSession()
    {
        return $this->hasSession() && $this->cookies->has($this->session->getName());
    }
    public function hasSession()
    {
        return null !== $this->session;
    }
    public function setSession(SessionInterface $session)
    {
        $this->session = $session;
    }
    public function getClientIps()
    {
        $clientIps = array();
        $ip = $this->server->get('REMOTE_ADDR');
        if (!$this->isFromTrustedProxy()) {
            return array($ip);
        }
        $hasTrustedForwardedHeader = self::$trustedHeaders[self::HEADER_FORWARDED] && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED]);
        $hasTrustedClientIpHeader = self::$trustedHeaders[self::HEADER_CLIENT_IP] && $this->headers->has(self::$trustedHeaders[self::HEADER_CLIENT_IP]);
        if ($hasTrustedForwardedHeader) {
            $forwardedHeader = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);
            preg_match_all('{(for)=("?\\[?)([a-z0-9\\.:_\\-/]*)}', $forwardedHeader, $matches);
            $forwardedClientIps = $matches[3];
            $forwardedClientIps = $this->normalizeAndFilterClientIps($forwardedClientIps, $ip);
            $clientIps = $forwardedClientIps;
        }
        if ($hasTrustedClientIpHeader) {
            $xForwardedForClientIps = array_map('trim', explode(',', $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_IP])));
            $xForwardedForClientIps = $this->normalizeAndFilterClientIps($xForwardedForClientIps, $ip);
            $clientIps = $xForwardedForClientIps;
        }
        if ($hasTrustedForwardedHeader && $hasTrustedClientIpHeader && $forwardedClientIps !== $xForwardedForClientIps) {
            throw new ConflictingHeadersException('The request has both a trusted Forwarded header and a trusted Client IP header, conflicting with each other with regards to the originating IP addresses of the request. This is the result of a misconfiguration. You should either configure your proxy only to send one of these headers, or configure Symfony to distrust one of them.');
        }
        if (!$hasTrustedForwardedHeader && !$hasTrustedClientIpHeader) {
            return $this->normalizeAndFilterClientIps(array(), $ip);
        }
        return $clientIps;
    }
    public function getClientIp()
    {
        $ipAddresses = $this->getClientIps();
        return $ipAddresses[0];
    }
    public function getScriptName()
    {
        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
    }
    public function getPathInfo()
    {
        if (null === $this->pathInfo) {
            $this->pathInfo = $this->preparePathInfo();
        }
        return $this->pathInfo;
    }
    public function getBasePath()
    {
        if (null === $this->basePath) {
            $this->basePath = $this->prepareBasePath();
        }
        return $this->basePath;
    }
    public function getBaseUrl()
    {
        if (null === $this->baseUrl) {
            $this->baseUrl = $this->prepareBaseUrl();
        }
        return $this->baseUrl;
    }
    public function getScheme()
    {
        return $this->isSecure() ? 'https' : 'http';
    }
    public function getPort()
    {
        if ($this->isFromTrustedProxy()) {
            if (self::$trustedHeaders[self::HEADER_CLIENT_PORT] && ($port = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PORT]))) {
                return $port;
            }
            if (self::$trustedHeaders[self::HEADER_CLIENT_PROTO] && 'https' === $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO], 'http')) {
                return 443;
            }
        }
        if ($host = $this->headers->get('HOST')) {
            if ($host[0] === '[') {
                $pos = strpos($host, ':', strrpos($host, ']'));
            } else {
                $pos = strrpos($host, ':');
            }
            if (false !== $pos) {
                return (int) substr($host, $pos + 1);
            }
            return 'https' === $this->getScheme() ? 443 : 80;
        }
        return $this->server->get('SERVER_PORT');
    }
    public function getUser()
    {
        return $this->headers->get('PHP_AUTH_USER');
    }
    public function getPassword()
    {
        return $this->headers->get('PHP_AUTH_PW');
    }
    public function getUserInfo()
    {
        $userinfo = $this->getUser();
        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= ":{$pass}";
        }
        return $userinfo;
    }
    public function getHttpHost()
    {
        $scheme = $this->getScheme();
        $port = $this->getPort();
        if ('http' == $scheme && $port == 80 || 'https' == $scheme && $port == 443) {
            return $this->getHost();
        }
        return $this->getHost() . ':' . $port;
    }
    public function getRequestUri()
    {
        if (null === $this->requestUri) {
            $this->requestUri = $this->prepareRequestUri();
        }
        return $this->requestUri;
    }
    public function getSchemeAndHttpHost()
    {
        return $this->getScheme() . '://' . $this->getHttpHost();
    }
    public function getUri()
    {
        if (null !== ($qs = $this->getQueryString())) {
            $qs = '?' . $qs;
        }
        return $this->getSchemeAndHttpHost() . $this->getBaseUrl() . $this->getPathInfo() . $qs;
    }
    public function getUriForPath($path)
    {
        return $this->getSchemeAndHttpHost() . $this->getBaseUrl() . $path;
    }
    public function getRelativeUriForPath($path)
    {
        if (!isset($path[0]) || '/' !== $path[0]) {
            return $path;
        }
        if ($path === ($basePath = $this->getPathInfo())) {
            return '';
        }
        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);
        $targetDirs = explode('/', isset($path[0]) && '/' === $path[0] ? substr($path, 1) : $path);
        array_pop($sourceDirs);
        $targetFile = array_pop($targetDirs);
        foreach ($sourceDirs as $i => $dir) {
            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {
                unset($sourceDirs[$i], $targetDirs[$i]);
            } else {
                break;
            }
        }
        $targetDirs[] = $targetFile;
        $path = str_repeat('../', count($sourceDirs)) . implode('/', $targetDirs);
        return !isset($path[0]) || '/' === $path[0] || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos) ? "./{$path}" : $path;
    }
    public function getQueryString()
    {
        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));
        return '' === $qs ? null : $qs;
    }
    public function isSecure()
    {
        if ($this->isFromTrustedProxy() && self::$trustedHeaders[self::HEADER_CLIENT_PROTO] && ($proto = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_PROTO]))) {
            return in_array(strtolower(current(explode(',', $proto))), array('https', 'on', 'ssl', '1'));
        }
        $https = $this->server->get('HTTPS');
        return !empty($https) && 'off' !== strtolower($https);
    }
    public function getHost()
    {
        if ($this->isFromTrustedProxy() && self::$trustedHeaders[self::HEADER_CLIENT_HOST] && ($host = $this->headers->get(self::$trustedHeaders[self::HEADER_CLIENT_HOST]))) {
            $elements = explode(',', $host);
            $host = $elements[count($elements) - 1];
        } elseif (!($host = $this->headers->get('HOST'))) {
            if (!($host = $this->server->get('SERVER_NAME'))) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }
        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));
        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {
            throw new \UnexpectedValueException(sprintf('Invalid Host "%s"', $host));
        }
        if (count(self::$trustedHostPatterns) > 0) {
            if (in_array($host, self::$trustedHosts)) {
                return $host;
            }
            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;
                    return $host;
                }
            }
            throw new \UnexpectedValueException(sprintf('Untrusted Host "%s"', $host));
        }
        return $host;
    }
    public function setMethod($method)
    {
        $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
    }
    public function getMethod()
    {
        if (null === $this->method) {
            $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
            if ('POST' === $this->method) {
                if ($method = $this->headers->get('X-HTTP-METHOD-OVERRIDE')) {
                    $this->method = strtoupper($method);
                } elseif (self::$httpMethodParameterOverride) {
                    $this->method = strtoupper($this->request->get('_method', $this->query->get('_method', 'POST')));
                }
            }
        }
        return $this->method;
    }
    public function getRealMethod()
    {
        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
    }
    public function getMimeType($format)
    {
        if (null === static::$formats) {
            static::initializeFormats();
        }
        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
    }
    public function getFormat($mimeType)
    {
        $canonicalMimeType = null;
        if (false !== ($pos = strpos($mimeType, ';'))) {
            $canonicalMimeType = substr($mimeType, 0, $pos);
        }
        if (null === static::$formats) {
            static::initializeFormats();
        }
        foreach (static::$formats as $format => $mimeTypes) {
            if (in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
            if (null !== $canonicalMimeType && in_array($canonicalMimeType, (array) $mimeTypes)) {
                return $format;
            }
        }
    }
    public function setFormat($format, $mimeTypes)
    {
        if (null === static::$formats) {
            static::initializeFormats();
        }
        static::$formats[$format] = is_array($mimeTypes) ? $mimeTypes : array($mimeTypes);
    }
    public function getRequestFormat($default = 'html')
    {
        if (null === $this->format) {
            $this->format = $this->get('_format', $default);
        }
        return $this->format;
    }
    public function setRequestFormat($format)
    {
        $this->format = $format;
    }
    public function getContentType()
    {
        return $this->getFormat($this->headers->get('CONTENT_TYPE'));
    }
    public function setDefaultLocale($locale)
    {
        $this->defaultLocale = $locale;
        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
    }
    public function getDefaultLocale()
    {
        return $this->defaultLocale;
    }
    public function setLocale($locale)
    {
        $this->setPhpDefaultLocale($this->locale = $locale);
    }
    public function getLocale()
    {
        return null === $this->locale ? $this->defaultLocale : $this->locale;
    }
    public function isMethod($method)
    {
        return $this->getMethod() === strtoupper($method);
    }
    public function isMethodSafe()
    {
        return in_array($this->getMethod(), array('GET', 'HEAD', 'OPTIONS', 'TRACE'));
    }
    public function getContent($asResource = false)
    {
        $currentContentIsResource = is_resource($this->content);
        if (PHP_VERSION_ID < 50600 && false === $this->content) {
            throw new \LogicException('getContent() can only be called once when using the resource return type and PHP below 5.6.');
        }
        if (true === $asResource) {
            if ($currentContentIsResource) {
                rewind($this->content);
                return $this->content;
            }
            if (is_string($this->content)) {
                $resource = fopen('php://temp', 'r+');
                fwrite($resource, $this->content);
                rewind($resource);
                return $resource;
            }
            $this->content = false;
            return fopen('php://input', 'rb');
        }
        if ($currentContentIsResource) {
            rewind($this->content);
            return stream_get_contents($this->content);
        }
        if (null === $this->content || false === $this->content) {
            $this->content = file_get_contents('php://input');
        }
        return $this->content;
    }
    public function getETags()
    {
        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);
    }
    public function isNoCache()
    {
        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
    }
    public function getPreferredLanguage(array $locales = null)
    {
        $preferredLanguages = $this->getLanguages();
        if (empty($locales)) {
            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;
        }
        if (!$preferredLanguages) {
            return $locales[0];
        }
        $extendedPreferredLanguages = array();
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== ($position = strpos($language, '_'))) {
                $superLanguage = substr($language, 0, $position);
                if (!in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }
        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));
        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];
    }
    public function getLanguages()
    {
        if (null !== $this->languages) {
            return $this->languages;
        }
        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = array();
        foreach ($languages as $lang => $acceptHeaderItem) {
            if (false !== strpos($lang, '-')) {
                $codes = explode('-', $lang);
                if ('i' === $codes[0]) {
                    if (count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = count($codes); $i < $max; ++$i) {
                        if ($i === 0) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_' . strtoupper($codes[$i]);
                        }
                    }
                }
            }
            $this->languages[] = $lang;
        }
        return $this->languages;
    }
    public function getCharsets()
    {
        if (null !== $this->charsets) {
            return $this->charsets;
        }
        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());
    }
    public function getEncodings()
    {
        if (null !== $this->encodings) {
            return $this->encodings;
        }
        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());
    }
    public function getAcceptableContentTypes()
    {
        if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }
        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());
    }
    public function isXmlHttpRequest()
    {
        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
    }
    protected function prepareRequestUri()
    {
        $requestUri = '';
        if ($this->headers->has('X_ORIGINAL_URL')) {
            $requestUri = $this->headers->get('X_ORIGINAL_URL');
            $this->headers->remove('X_ORIGINAL_URL');
            $this->server->remove('HTTP_X_ORIGINAL_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->headers->has('X_REWRITE_URL')) {
            $requestUri = $this->headers->get('X_REWRITE_URL');
            $this->headers->remove('X_REWRITE_URL');
        } elseif ($this->server->get('IIS_WasUrlRewritten') == '1' && $this->server->get('UNENCODED_URL') != '') {
            $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');
            $schemeAndHttpHost = $this->getSchemeAndHttpHost();
            if (strpos($requestUri, $schemeAndHttpHost) === 0) {
                $requestUri = substr($requestUri, strlen($schemeAndHttpHost));
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
            $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?' . $this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }
        $this->server->set('REQUEST_URI', $requestUri);
        return $requestUri;
    }
    protected function prepareBaseUrl()
    {
        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME');
        } else {
            $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/' . $seg . $baseUrl;
                ++$index;
            } while ($last > $index && false !== ($pos = strpos($path, $baseUrl)) && 0 != $pos);
        }
        $requestUri = $this->getRequestUri();
        if ($baseUrl && false !== ($prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl))) {
            return $prefix;
        }
        if ($baseUrl && false !== ($prefix = $this->getUrlencodedPrefix($requestUri, rtrim(dirname($baseUrl), '/' . DIRECTORY_SEPARATOR) . '/'))) {
            return rtrim($prefix, '/' . DIRECTORY_SEPARATOR);
        }
        $truncatedRequestUri = $requestUri;
        if (false !== ($pos = strpos($requestUri, '?'))) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }
        $basename = basename($baseUrl);
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
            return '';
        }
        if (strlen($requestUri) >= strlen($baseUrl) && false !== ($pos = strpos($requestUri, $baseUrl)) && $pos !== 0) {
            $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl));
        }
        return rtrim($baseUrl, '/' . DIRECTORY_SEPARATOR);
    }
    protected function prepareBasePath()
    {
        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }
        if (basename($baseUrl) === $filename) {
            $basePath = dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }
        if ('\\' === DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }
        return rtrim($basePath, '/');
    }
    protected function preparePathInfo()
    {
        $baseUrl = $this->getBaseUrl();
        if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }
        if ($pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        $pathInfo = substr($requestUri, strlen($baseUrl));
        if (null !== $baseUrl && (false === $pathInfo || '' === $pathInfo)) {
            return '/';
        } elseif (null === $baseUrl) {
            return $requestUri;
        }
        return (string) $pathInfo;
    }
    protected static function initializeFormats()
    {
        static::$formats = array('html' => array('text/html', 'application/xhtml+xml'), 'txt' => array('text/plain'), 'js' => array('application/javascript', 'application/x-javascript', 'text/javascript'), 'css' => array('text/css'), 'json' => array('application/json', 'application/x-json'), 'xml' => array('text/xml', 'application/xml', 'application/x-xml'), 'rdf' => array('application/rdf+xml'), 'atom' => array('application/atom+xml'), 'rss' => array('application/rss+xml'), 'form' => array('application/x-www-form-urlencoded'));
    }
    private function setPhpDefaultLocale($locale)
    {
        try {
            if (class_exists('Locale', false)) {
                \Locale::setDefault($locale);
            }
        } catch (\Exception $e) {
        }
    }
    private function getUrlencodedPrefix($string, $prefix)
    {
        if (0 !== strpos(rawurldecode($string), $prefix)) {
            return false;
        }
        $len = strlen($prefix);
        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {
            return $match[0];
        }
        return false;
    }
    private static function createRequestFromFactory(array $query = array(), array $request = array(), array $attributes = array(), array $cookies = array(), array $files = array(), array $server = array(), $content = null)
    {
        if (self::$requestFactory) {
            $request = call_user_func(self::$requestFactory, $query, $request, $attributes, $cookies, $files, $server, $content);
            if (!$request instanceof self) {
                throw new \LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');
            }
            return $request;
        }
        return new static($query, $request, $attributes, $cookies, $files, $server, $content);
    }
    private function isFromTrustedProxy()
    {
        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);
    }
    private function normalizeAndFilterClientIps(array $clientIps, $ip)
    {
        $clientIps[] = $ip;
        $firstTrustedIp = null;
        foreach ($clientIps as $key => $clientIp) {
            if (preg_match('{((?:\\d+\\.){3}\\d+)\\:\\d+}', $clientIp, $match)) {
                $clientIps[$key] = $clientIp = $match[1];
            }
            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {
                unset($clientIps[$key]);
                continue;
            }
            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {
                unset($clientIps[$key]);
                if (null === $firstTrustedIp) {
                    $firstTrustedIp = $clientIp;
                }
            }
        }
        return $clientIps ? array_reverse($clientIps) : array($firstTrustedIp);
    }
}
}

namespace Symfony\Component\HttpFoundation {
class Response
{
    const HTTP_CONTINUE = 100;
    const HTTP_SWITCHING_PROTOCOLS = 101;
    const HTTP_PROCESSING = 102;
    const HTTP_OK = 200;
    const HTTP_CREATED = 201;
    const HTTP_ACCEPTED = 202;
    const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;
    const HTTP_NO_CONTENT = 204;
    const HTTP_RESET_CONTENT = 205;
    const HTTP_PARTIAL_CONTENT = 206;
    const HTTP_MULTI_STATUS = 207;
    const HTTP_ALREADY_REPORTED = 208;
    const HTTP_IM_USED = 226;
    const HTTP_MULTIPLE_CHOICES = 300;
    const HTTP_MOVED_PERMANENTLY = 301;
    const HTTP_FOUND = 302;
    const HTTP_SEE_OTHER = 303;
    const HTTP_NOT_MODIFIED = 304;
    const HTTP_USE_PROXY = 305;
    const HTTP_RESERVED = 306;
    const HTTP_TEMPORARY_REDIRECT = 307;
    const HTTP_PERMANENTLY_REDIRECT = 308;
    const HTTP_BAD_REQUEST = 400;
    const HTTP_UNAUTHORIZED = 401;
    const HTTP_PAYMENT_REQUIRED = 402;
    const HTTP_FORBIDDEN = 403;
    const HTTP_NOT_FOUND = 404;
    const HTTP_METHOD_NOT_ALLOWED = 405;
    const HTTP_NOT_ACCEPTABLE = 406;
    const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;
    const HTTP_REQUEST_TIMEOUT = 408;
    const HTTP_CONFLICT = 409;
    const HTTP_GONE = 410;
    const HTTP_LENGTH_REQUIRED = 411;
    const HTTP_PRECONDITION_FAILED = 412;
    const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;
    const HTTP_REQUEST_URI_TOO_LONG = 414;
    const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;
    const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
    const HTTP_EXPECTATION_FAILED = 417;
    const HTTP_I_AM_A_TEAPOT = 418;
    const HTTP_MISDIRECTED_REQUEST = 421;
    const HTTP_UNPROCESSABLE_ENTITY = 422;
    const HTTP_LOCKED = 423;
    const HTTP_FAILED_DEPENDENCY = 424;
    const HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL = 425;
    const HTTP_UPGRADE_REQUIRED = 426;
    const HTTP_PRECONDITION_REQUIRED = 428;
    const HTTP_TOO_MANY_REQUESTS = 429;
    const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
    const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;
    const HTTP_INTERNAL_SERVER_ERROR = 500;
    const HTTP_NOT_IMPLEMENTED = 501;
    const HTTP_BAD_GATEWAY = 502;
    const HTTP_SERVICE_UNAVAILABLE = 503;
    const HTTP_GATEWAY_TIMEOUT = 504;
    const HTTP_VERSION_NOT_SUPPORTED = 505;
    const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;
    const HTTP_INSUFFICIENT_STORAGE = 507;
    const HTTP_LOOP_DETECTED = 508;
    const HTTP_NOT_EXTENDED = 510;
    const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;
    public $headers;
    protected $content;
    protected $version;
    protected $statusCode;
    protected $statusText;
    protected $charset;
    public static $statusTexts = array(100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-Status', 208 => 'Already Reported', 226 => 'IM Used', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Reserved', 307 => 'Temporary Redirect', 308 => 'Permanent Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Long', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 418 => 'I\'m a teapot', 421 => 'Misdirected Request', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Reserved for WebDAV advanced collections expired proposal', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 451 => 'Unavailable For Legal Reasons', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Timeout', 505 => 'HTTP Version Not Supported', 506 => 'Variant Also Negotiates (Experimental)', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 510 => 'Not Extended', 511 => 'Network Authentication Required');
    public function __construct($content = '', $status = 200, $headers = array())
    {
        $this->headers = new ResponseHeaderBag($headers);
        $this->setContent($content);
        $this->setStatusCode($status);
        $this->setProtocolVersion('1.0');
        if (!$this->headers->has('Date')) {
            $this->setDate(\DateTime::createFromFormat('U', time(), new \DateTimeZone('UTC')));
        }
    }
    public static function create($content = '', $status = 200, $headers = array())
    {
        return new static($content, $status, $headers);
    }
    public function __toString()
    {
        return sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText) . "\r\n" . $this->headers . "\r\n" . $this->getContent();
    }
    public function __clone()
    {
        $this->headers = clone $this->headers;
    }
    public function prepare(Request $request)
    {
        $headers = $this->headers;
        if ($this->isInformational() || $this->isEmpty()) {
            $this->setContent(null);
            $headers->remove('Content-Type');
            $headers->remove('Content-Length');
        } else {
            if (!$headers->has('Content-Type')) {
                $format = $request->getRequestFormat();
                if (null !== $format && ($mimeType = $request->getMimeType($format))) {
                    $headers->set('Content-Type', $mimeType);
                }
            }
            $charset = $this->charset ?: 'UTF-8';
            if (!$headers->has('Content-Type')) {
                $headers->set('Content-Type', 'text/html; charset=' . $charset);
            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {
                $headers->set('Content-Type', $headers->get('Content-Type') . '; charset=' . $charset);
            }
            if ($headers->has('Transfer-Encoding')) {
                $headers->remove('Content-Length');
            }
            if ($request->isMethod('HEAD')) {
                $length = $headers->get('Content-Length');
                $this->setContent(null);
                if ($length) {
                    $headers->set('Content-Length', $length);
                }
            }
        }
        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {
            $this->setProtocolVersion('1.1');
        }
        if ('1.0' == $this->getProtocolVersion() && 'no-cache' == $this->headers->get('Cache-Control')) {
            $this->headers->set('pragma', 'no-cache');
            $this->headers->set('expires', -1);
        }
        $this->ensureIEOverSSLCompatibility($request);
        return $this;
    }
    public function sendHeaders()
    {
        if (headers_sent()) {
            return $this;
        }
        foreach ($this->headers->allPreserveCase() as $name => $values) {
            foreach ($values as $value) {
                header($name . ': ' . $value, false);
            }
        }
        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);
        foreach ($this->headers->getCookies() as $cookie) {
            setcookie($cookie->getName(), $cookie->getValue(), $cookie->getExpiresTime(), $cookie->getPath(), $cookie->getDomain(), $cookie->isSecure(), $cookie->isHttpOnly());
        }
        return $this;
    }
    public function sendContent()
    {
        echo $this->content;
        return $this;
    }
    public function send()
    {
        $this->sendHeaders();
        $this->sendContent();
        if (function_exists('fastcgi_finish_request')) {
            fastcgi_finish_request();
        } elseif ('cli' !== PHP_SAPI) {
            static::closeOutputBuffers(0, true);
        }
        return $this;
    }
    public function setContent($content)
    {
        if (null !== $content && !is_string($content) && !is_numeric($content) && !is_callable(array($content, '__toString'))) {
            throw new \UnexpectedValueException(sprintf('The Response content must be a string or object implementing __toString(), "%s" given.', gettype($content)));
        }
        $this->content = (string) $content;
        return $this;
    }
    public function getContent()
    {
        return $this->content;
    }
    public function setProtocolVersion($version)
    {
        $this->version = $version;
        return $this;
    }
    public function getProtocolVersion()
    {
        return $this->version;
    }
    public function setStatusCode($code, $text = null)
    {
        $this->statusCode = $code = (int) $code;
        if ($this->isInvalid()) {
            throw new \InvalidArgumentException(sprintf('The HTTP status code "%s" is not valid.', $code));
        }
        if (null === $text) {
            $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] : 'unknown status';
            return $this;
        }
        if (false === $text) {
            $this->statusText = '';
            return $this;
        }
        $this->statusText = $text;
        return $this;
    }
    public function getStatusCode()
    {
        return $this->statusCode;
    }
    public function setCharset($charset)
    {
        $this->charset = $charset;
        return $this;
    }
    public function getCharset()
    {
        return $this->charset;
    }
    public function isCacheable()
    {
        if (!in_array($this->statusCode, array(200, 203, 300, 301, 302, 404, 410))) {
            return false;
        }
        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {
            return false;
        }
        return $this->isValidateable() || $this->isFresh();
    }
    public function isFresh()
    {
        return $this->getTtl() > 0;
    }
    public function isValidateable()
    {
        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');
    }
    public function setPrivate()
    {
        $this->headers->removeCacheControlDirective('public');
        $this->headers->addCacheControlDirective('private');
        return $this;
    }
    public function setPublic()
    {
        $this->headers->addCacheControlDirective('public');
        $this->headers->removeCacheControlDirective('private');
        return $this;
    }
    public function mustRevalidate()
    {
        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');
    }
    public function getDate()
    {
        return $this->headers->getDate('Date', new \DateTime());
    }
    public function setDate(\DateTime $date)
    {
        $date->setTimezone(new \DateTimeZone('UTC'));
        $this->headers->set('Date', $date->format('D, d M Y H:i:s') . ' GMT');
        return $this;
    }
    public function getAge()
    {
        if (null !== ($age = $this->headers->get('Age'))) {
            return (int) $age;
        }
        return max(time() - $this->getDate()->format('U'), 0);
    }
    public function expire()
    {
        if ($this->isFresh()) {
            $this->headers->set('Age', $this->getMaxAge());
        }
        return $this;
    }
    public function getExpires()
    {
        try {
            return $this->headers->getDate('Expires');
        } catch (\RuntimeException $e) {
            return \DateTime::createFromFormat(DATE_RFC2822, 'Sat, 01 Jan 00 00:00:00 +0000');
        }
    }
    public function setExpires(\DateTime $date = null)
    {
        if (null === $date) {
            $this->headers->remove('Expires');
        } else {
            $date = clone $date;
            $date->setTimezone(new \DateTimeZone('UTC'));
            $this->headers->set('Expires', $date->format('D, d M Y H:i:s') . ' GMT');
        }
        return $this;
    }
    public function getMaxAge()
    {
        if ($this->headers->hasCacheControlDirective('s-maxage')) {
            return (int) $this->headers->getCacheControlDirective('s-maxage');
        }
        if ($this->headers->hasCacheControlDirective('max-age')) {
            return (int) $this->headers->getCacheControlDirective('max-age');
        }
        if (null !== $this->getExpires()) {
            return $this->getExpires()->format('U') - $this->getDate()->format('U');
        }
    }
    public function setMaxAge($value)
    {
        $this->headers->addCacheControlDirective('max-age', $value);
        return $this;
    }
    public function setSharedMaxAge($value)
    {
        $this->setPublic();
        $this->headers->addCacheControlDirective('s-maxage', $value);
        return $this;
    }
    public function getTtl()
    {
        if (null !== ($maxAge = $this->getMaxAge())) {
            return $maxAge - $this->getAge();
        }
    }
    public function setTtl($seconds)
    {
        $this->setSharedMaxAge($this->getAge() + $seconds);
        return $this;
    }
    public function setClientTtl($seconds)
    {
        $this->setMaxAge($this->getAge() + $seconds);
        return $this;
    }
    public function getLastModified()
    {
        return $this->headers->getDate('Last-Modified');
    }
    public function setLastModified(\DateTime $date = null)
    {
        if (null === $date) {
            $this->headers->remove('Last-Modified');
        } else {
            $date = clone $date;
            $date->setTimezone(new \DateTimeZone('UTC'));
            $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s') . ' GMT');
        }
        return $this;
    }
    public function getEtag()
    {
        return $this->headers->get('ETag');
    }
    public function setEtag($etag = null, $weak = false)
    {
        if (null === $etag) {
            $this->headers->remove('Etag');
        } else {
            if (0 !== strpos($etag, '"')) {
                $etag = '"' . $etag . '"';
            }
            $this->headers->set('ETag', (true === $weak ? 'W/' : '') . $etag);
        }
        return $this;
    }
    public function setCache(array $options)
    {
        if ($diff = array_diff(array_keys($options), array('etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public'))) {
            throw new \InvalidArgumentException(sprintf('Response does not support the following options: "%s".', implode('", "', array_values($diff))));
        }
        if (isset($options['etag'])) {
            $this->setEtag($options['etag']);
        }
        if (isset($options['last_modified'])) {
            $this->setLastModified($options['last_modified']);
        }
        if (isset($options['max_age'])) {
            $this->setMaxAge($options['max_age']);
        }
        if (isset($options['s_maxage'])) {
            $this->setSharedMaxAge($options['s_maxage']);
        }
        if (isset($options['public'])) {
            if ($options['public']) {
                $this->setPublic();
            } else {
                $this->setPrivate();
            }
        }
        if (isset($options['private'])) {
            if ($options['private']) {
                $this->setPrivate();
            } else {
                $this->setPublic();
            }
        }
        return $this;
    }
    public function setNotModified()
    {
        $this->setStatusCode(304);
        $this->setContent(null);
        foreach (array('Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified') as $header) {
            $this->headers->remove($header);
        }
        return $this;
    }
    public function hasVary()
    {
        return null !== $this->headers->get('Vary');
    }
    public function getVary()
    {
        if (!($vary = $this->headers->get('Vary', null, false))) {
            return array();
        }
        $ret = array();
        foreach ($vary as $item) {
            $ret = array_merge($ret, preg_split('/[\\s,]+/', $item));
        }
        return $ret;
    }
    public function setVary($headers, $replace = true)
    {
        $this->headers->set('Vary', $headers, $replace);
        return $this;
    }
    public function isNotModified(Request $request)
    {
        if (!$request->isMethodSafe()) {
            return false;
        }
        $notModified = false;
        $lastModified = $this->headers->get('Last-Modified');
        $modifiedSince = $request->headers->get('If-Modified-Since');
        if ($etags = $request->getETags()) {
            $notModified = in_array($this->getEtag(), $etags) || in_array('*', $etags);
        }
        if ($modifiedSince && $lastModified) {
            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);
        }
        if ($notModified) {
            $this->setNotModified();
        }
        return $notModified;
    }
    public function isInvalid()
    {
        return $this->statusCode < 100 || $this->statusCode >= 600;
    }
    public function isInformational()
    {
        return $this->statusCode >= 100 && $this->statusCode < 200;
    }
    public function isSuccessful()
    {
        return $this->statusCode >= 200 && $this->statusCode < 300;
    }
    public function isRedirection()
    {
        return $this->statusCode >= 300 && $this->statusCode < 400;
    }
    public function isClientError()
    {
        return $this->statusCode >= 400 && $this->statusCode < 500;
    }
    public function isServerError()
    {
        return $this->statusCode >= 500 && $this->statusCode < 600;
    }
    public function isOk()
    {
        return 200 === $this->statusCode;
    }
    public function isForbidden()
    {
        return 403 === $this->statusCode;
    }
    public function isNotFound()
    {
        return 404 === $this->statusCode;
    }
    public function isRedirect($location = null)
    {
        return in_array($this->statusCode, array(201, 301, 302, 303, 307, 308)) && (null === $location ?: $location == $this->headers->get('Location'));
    }
    public function isEmpty()
    {
        return in_array($this->statusCode, array(204, 304));
    }
    public static function closeOutputBuffers($targetLevel, $flush)
    {
        $status = ob_get_status(true);
        $level = count($status);
        $flags = defined('PHP_OUTPUT_HANDLER_REMOVABLE') ? PHP_OUTPUT_HANDLER_REMOVABLE | ($flush ? PHP_OUTPUT_HANDLER_FLUSHABLE : PHP_OUTPUT_HANDLER_CLEANABLE) : -1;
        while ($level-- > $targetLevel && ($s = $status[$level]) && (!isset($s['del']) ? !isset($s['flags']) || $flags === ($s['flags'] & $flags) : $s['del'])) {
            if ($flush) {
                ob_end_flush();
            } else {
                ob_end_clean();
            }
        }
    }
    protected function ensureIEOverSSLCompatibility(Request $request)
    {
        if (false !== stripos($this->headers->get('Content-Disposition'), 'attachment') && preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT'), $match) == 1 && true === $request->isSecure()) {
            if ((int) preg_replace('/(MSIE )(.*?);/', '$2', $match[0]) < 9) {
                $this->headers->remove('Cache-Control');
            }
        }
    }
}
}

namespace Symfony\Component\HttpFoundation {
class ParameterBag implements \IteratorAggregate, \Countable
{
    protected $parameters;
    public function __construct(array $parameters = array())
    {
        $this->parameters = $parameters;
    }
    public function all()
    {
        return $this->parameters;
    }
    public function keys()
    {
        return array_keys($this->parameters);
    }
    public function replace(array $parameters = array())
    {
        $this->parameters = $parameters;
    }
    public function add(array $parameters = array())
    {
        $this->parameters = array_replace($this->parameters, $parameters);
    }
    public function get($path, $default = null, $deep = false)
    {
        if (!$deep || false === ($pos = strpos($path, '['))) {
            return array_key_exists($path, $this->parameters) ? $this->parameters[$path] : $default;
        }
        $root = substr($path, 0, $pos);
        if (!array_key_exists($root, $this->parameters)) {
            return $default;
        }
        $value = $this->parameters[$root];
        $currentKey = null;
        for ($i = $pos, $c = strlen($path); $i < $c; ++$i) {
            $char = $path[$i];
            if ('[' === $char) {
                if (null !== $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "[" at position %d.', $i));
                }
                $currentKey = '';
            } elseif (']' === $char) {
                if (null === $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "]" at position %d.', $i));
                }
                if (!is_array($value) || !array_key_exists($currentKey, $value)) {
                    return $default;
                }
                $value = $value[$currentKey];
                $currentKey = null;
            } else {
                if (null === $currentKey) {
                    throw new \InvalidArgumentException(sprintf('Malformed path. Unexpected "%s" at position %d.', $char, $i));
                }
                $currentKey .= $char;
            }
        }
        if (null !== $currentKey) {
            throw new \InvalidArgumentException(sprintf('Malformed path. Path must end with "]".'));
        }
        return $value;
    }
    public function set($key, $value)
    {
        $this->parameters[$key] = $value;
    }
    public function has($key)
    {
        return array_key_exists($key, $this->parameters);
    }
    public function remove($key)
    {
        unset($this->parameters[$key]);
    }
    public function getAlpha($key, $default = '', $deep = false)
    {
        return preg_replace('/[^[:alpha:]]/', '', $this->get($key, $default, $deep));
    }
    public function getAlnum($key, $default = '', $deep = false)
    {
        return preg_replace('/[^[:alnum:]]/', '', $this->get($key, $default, $deep));
    }
    public function getDigits($key, $default = '', $deep = false)
    {
        return str_replace(array('-', '+'), '', $this->filter($key, $default, $deep, FILTER_SANITIZE_NUMBER_INT));
    }
    public function getInt($key, $default = 0, $deep = false)
    {
        return (int) $this->get($key, $default, $deep);
    }
    public function getBoolean($key, $default = false, $deep = false)
    {
        return $this->filter($key, $default, $deep, FILTER_VALIDATE_BOOLEAN);
    }
    public function filter($key, $default = null, $deep = false, $filter = FILTER_DEFAULT, $options = array())
    {
        $value = $this->get($key, $default, $deep);
        if (!is_array($options) && $options) {
            $options = array('flags' => $options);
        }
        if (is_array($value) && !isset($options['flags'])) {
            $options['flags'] = FILTER_REQUIRE_ARRAY;
        }
        return filter_var($value, $filter, $options);
    }
    public function getIterator()
    {
        return new \ArrayIterator($this->parameters);
    }
    public function count()
    {
        return count($this->parameters);
    }
}
}

namespace Symfony\Component\HttpFoundation {
use Symfony\Component\HttpFoundation\File\UploadedFile;
class FileBag extends ParameterBag
{
    private static $fileKeys = array('error', 'name', 'size', 'tmp_name', 'type');
    public function __construct(array $parameters = array())
    {
        $this->replace($parameters);
    }
    public function replace(array $files = array())
    {
        $this->parameters = array();
        $this->add($files);
    }
    public function set($key, $value)
    {
        if (!is_array($value) && !$value instanceof UploadedFile) {
            throw new \InvalidArgumentException('An uploaded file must be an array or an instance of UploadedFile.');
        }
        parent::set($key, $this->convertFileInformation($value));
    }
    public function add(array $files = array())
    {
        foreach ($files as $key => $file) {
            $this->set($key, $file);
        }
    }
    protected function convertFileInformation($file)
    {
        if ($file instanceof UploadedFile) {
            return $file;
        }
        $file = $this->fixPhpFilesArray($file);
        if (is_array($file)) {
            $keys = array_keys($file);
            sort($keys);
            if ($keys == self::$fileKeys) {
                if (UPLOAD_ERR_NO_FILE == $file['error']) {
                    $file = null;
                } else {
                    $file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error']);
                }
            } else {
                $file = array_map(array($this, 'convertFileInformation'), $file);
            }
        }
        return $file;
    }
    protected function fixPhpFilesArray($data)
    {
        if (!is_array($data)) {
            return $data;
        }
        $keys = array_keys($data);
        sort($keys);
        if (self::$fileKeys != $keys || !isset($data['name']) || !is_array($data['name'])) {
            return $data;
        }
        $files = $data;
        foreach (self::$fileKeys as $k) {
            unset($files[$k]);
        }
        foreach ($data['name'] as $key => $name) {
            $files[$key] = $this->fixPhpFilesArray(array('error' => $data['error'][$key], 'name' => $name, 'type' => $data['type'][$key], 'tmp_name' => $data['tmp_name'][$key], 'size' => $data['size'][$key]));
        }
        return $files;
    }
}
}

namespace Symfony\Component\HttpFoundation {
class ServerBag extends ParameterBag
{
    public function getHeaders()
    {
        $headers = array();
        $contentHeaders = array('CONTENT_LENGTH' => true, 'CONTENT_MD5' => true, 'CONTENT_TYPE' => true);
        foreach ($this->parameters as $key => $value) {
            if (0 === strpos($key, 'HTTP_')) {
                $headers[substr($key, 5)] = $value;
            } elseif (isset($contentHeaders[$key])) {
                $headers[$key] = $value;
            }
        }
        if (isset($this->parameters['PHP_AUTH_USER'])) {
            $headers['PHP_AUTH_USER'] = $this->parameters['PHP_AUTH_USER'];
            $headers['PHP_AUTH_PW'] = isset($this->parameters['PHP_AUTH_PW']) ? $this->parameters['PHP_AUTH_PW'] : '';
        } else {
            $authorizationHeader = null;
            if (isset($this->parameters['HTTP_AUTHORIZATION'])) {
                $authorizationHeader = $this->parameters['HTTP_AUTHORIZATION'];
            } elseif (isset($this->parameters['REDIRECT_HTTP_AUTHORIZATION'])) {
                $authorizationHeader = $this->parameters['REDIRECT_HTTP_AUTHORIZATION'];
            }
            if (null !== $authorizationHeader) {
                if (0 === stripos($authorizationHeader, 'basic ')) {
                    $exploded = explode(':', base64_decode(substr($authorizationHeader, 6)), 2);
                    if (count($exploded) == 2) {
                        list($headers['PHP_AUTH_USER'], $headers['PHP_AUTH_PW']) = $exploded;
                    }
                } elseif (empty($this->parameters['PHP_AUTH_DIGEST']) && 0 === stripos($authorizationHeader, 'digest ')) {
                    $headers['PHP_AUTH_DIGEST'] = $authorizationHeader;
                    $this->parameters['PHP_AUTH_DIGEST'] = $authorizationHeader;
                } elseif (0 === stripos($authorizationHeader, 'bearer ')) {
                    $headers['AUTHORIZATION'] = $authorizationHeader;
                }
            }
        }
        if (isset($headers['AUTHORIZATION'])) {
            return $headers;
        }
        if (isset($headers['PHP_AUTH_USER'])) {
            $headers['AUTHORIZATION'] = 'Basic ' . base64_encode($headers['PHP_AUTH_USER'] . ':' . $headers['PHP_AUTH_PW']);
        } elseif (isset($headers['PHP_AUTH_DIGEST'])) {
            $headers['AUTHORIZATION'] = $headers['PHP_AUTH_DIGEST'];
        }
        return $headers;
    }
}
}

namespace Symfony\Component\HttpFoundation {
class HeaderBag implements \IteratorAggregate, \Countable
{
    protected $headers = array();
    protected $cacheControl = array();
    public function __construct(array $headers = array())
    {
        foreach ($headers as $key => $values) {
            $this->set($key, $values);
        }
    }
    public function __toString()
    {
        if (!$this->headers) {
            return '';
        }
        $max = max(array_map('strlen', array_keys($this->headers))) + 1;
        $content = '';
        ksort($this->headers);
        foreach ($this->headers as $name => $values) {
            $name = implode('-', array_map('ucfirst', explode('-', $name)));
            foreach ($values as $value) {
                $content .= sprintf("%-{$max}s %s\r\n", $name . ':', $value);
            }
        }
        return $content;
    }
    public function all()
    {
        return $this->headers;
    }
    public function keys()
    {
        return array_keys($this->headers);
    }
    public function replace(array $headers = array())
    {
        $this->headers = array();
        $this->add($headers);
    }
    public function add(array $headers)
    {
        foreach ($headers as $key => $values) {
            $this->set($key, $values);
        }
    }
    public function get($key, $default = null, $first = true)
    {
        $key = str_replace('_', '-', strtolower($key));
        if (!array_key_exists($key, $this->headers)) {
            if (null === $default) {
                return $first ? null : array();
            }
            return $first ? $default : array($default);
        }
        if ($first) {
            return count($this->headers[$key]) ? $this->headers[$key][0] : $default;
        }
        return $this->headers[$key];
    }
    public function set($key, $values, $replace = true)
    {
        $key = str_replace('_', '-', strtolower($key));
        $values = array_values((array) $values);
        if (true === $replace || !isset($this->headers[$key])) {
            $this->headers[$key] = $values;
        } else {
            $this->headers[$key] = array_merge($this->headers[$key], $values);
        }
        if ('cache-control' === $key) {
            $this->cacheControl = $this->parseCacheControl($values[0]);
        }
    }
    public function has($key)
    {
        return array_key_exists(str_replace('_', '-', strtolower($key)), $this->headers);
    }
    public function contains($key, $value)
    {
        return in_array($value, $this->get($key, null, false));
    }
    public function remove($key)
    {
        $key = str_replace('_', '-', strtolower($key));
        unset($this->headers[$key]);
        if ('cache-control' === $key) {
            $this->cacheControl = array();
        }
    }
    public function getDate($key, \DateTime $default = null)
    {
        if (null === ($value = $this->get($key))) {
            return $default;
        }
        if (false === ($date = \DateTime::createFromFormat(DATE_RFC2822, $value))) {
            throw new \RuntimeException(sprintf('The %s HTTP header is not parseable (%s).', $key, $value));
        }
        return $date;
    }
    public function addCacheControlDirective($key, $value = true)
    {
        $this->cacheControl[$key] = $value;
        $this->set('Cache-Control', $this->getCacheControlHeader());
    }
    public function hasCacheControlDirective($key)
    {
        return array_key_exists($key, $this->cacheControl);
    }
    public function getCacheControlDirective($key)
    {
        return array_key_exists($key, $this->cacheControl) ? $this->cacheControl[$key] : null;
    }
    public function removeCacheControlDirective($key)
    {
        unset($this->cacheControl[$key]);
        $this->set('Cache-Control', $this->getCacheControlHeader());
    }
    public function getIterator()
    {
        return new \ArrayIterator($this->headers);
    }
    public function count()
    {
        return count($this->headers);
    }
    protected function getCacheControlHeader()
    {
        $parts = array();
        ksort($this->cacheControl);
        foreach ($this->cacheControl as $key => $value) {
            if (true === $value) {
                $parts[] = $key;
            } else {
                if (preg_match('#[^a-zA-Z0-9._-]#', $value)) {
                    $value = '"' . $value . '"';
                }
                $parts[] = "{$key}={$value}";
            }
        }
        return implode(', ', $parts);
    }
    protected function parseCacheControl($header)
    {
        $cacheControl = array();
        preg_match_all('#([a-zA-Z][a-zA-Z_-]*)\\s*(?:=(?:"([^"]*)"|([^ \\t",;]*)))?#', $header, $matches, PREG_SET_ORDER);
        foreach ($matches as $match) {
            $cacheControl[strtolower($match[1])] = isset($match[3]) ? $match[3] : (isset($match[2]) ? $match[2] : true);
        }
        return $cacheControl;
    }
}
}

namespace Symfony\Component\HttpFoundation\Session {
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
interface SessionInterface
{
    public function start();
    public function getId();
    public function setId($id);
    public function getName();
    public function setName($name);
    public function invalidate($lifetime = null);
    public function migrate($destroy = false, $lifetime = null);
    public function save();
    public function has($name);
    public function get($name, $default = null);
    public function set($name, $value);
    public function all();
    public function replace(array $attributes);
    public function remove($name);
    public function clear();
    public function isStarted();
    public function registerBag(SessionBagInterface $bag);
    public function getBag($name);
    public function getMetadataBag();
}
}

namespace Symfony\Component\HttpFoundation\Session {
interface SessionBagInterface
{
    public function getName();
    public function initialize(array &$array);
    public function getStorageKey();
    public function clear();
}
}

namespace Symfony\Component\HttpFoundation\Session\Attribute {
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
interface AttributeBagInterface extends SessionBagInterface
{
    public function has($name);
    public function get($name, $default = null);
    public function set($name, $value);
    public function all();
    public function replace(array $attributes);
    public function remove($name);
}
}

namespace Symfony\Component\HttpFoundation\Session\Attribute {
class AttributeBag implements AttributeBagInterface, \IteratorAggregate, \Countable
{
    private $name = 'attributes';
    private $storageKey;
    protected $attributes = array();
    public function __construct($storageKey = '_sf2_attributes')
    {
        $this->storageKey = $storageKey;
    }
    public function getName()
    {
        return $this->name;
    }
    public function setName($name)
    {
        $this->name = $name;
    }
    public function initialize(array &$attributes)
    {
        $this->attributes =& $attributes;
    }
    public function getStorageKey()
    {
        return $this->storageKey;
    }
    public function has($name)
    {
        return array_key_exists($name, $this->attributes);
    }
    public function get($name, $default = null)
    {
        return array_key_exists($name, $this->attributes) ? $this->attributes[$name] : $default;
    }
    public function set($name, $value)
    {
        $this->attributes[$name] = $value;
    }
    public function all()
    {
        return $this->attributes;
    }
    public function replace(array $attributes)
    {
        $this->attributes = array();
        foreach ($attributes as $key => $value) {
            $this->set($key, $value);
        }
    }
    public function remove($name)
    {
        $retval = null;
        if (array_key_exists($name, $this->attributes)) {
            $retval = $this->attributes[$name];
            unset($this->attributes[$name]);
        }
        return $retval;
    }
    public function clear()
    {
        $return = $this->attributes;
        $this->attributes = array();
        return $return;
    }
    public function getIterator()
    {
        return new \ArrayIterator($this->attributes);
    }
    public function count()
    {
        return count($this->attributes);
    }
}
}

namespace Symfony\Component\HttpFoundation\Session\Storage {
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
class MetadataBag implements SessionBagInterface
{
    const CREATED = 'c';
    const UPDATED = 'u';
    const LIFETIME = 'l';
    private $name = '__metadata';
    private $storageKey;
    protected $meta = array(self::CREATED => 0, self::UPDATED => 0, self::LIFETIME => 0);
    private $lastUsed;
    private $updateThreshold;
    public function __construct($storageKey = '_sf2_meta', $updateThreshold = 0)
    {
        $this->storageKey = $storageKey;
        $this->updateThreshold = $updateThreshold;
    }
    public function initialize(array &$array)
    {
        $this->meta =& $array;
        if (isset($array[self::CREATED])) {
            $this->lastUsed = $this->meta[self::UPDATED];
            $timeStamp = time();
            if ($timeStamp - $array[self::UPDATED] >= $this->updateThreshold) {
                $this->meta[self::UPDATED] = $timeStamp;
            }
        } else {
            $this->stampCreated();
        }
    }
    public function getLifetime()
    {
        return $this->meta[self::LIFETIME];
    }
    public function stampNew($lifetime = null)
    {
        $this->stampCreated($lifetime);
    }
    public function getStorageKey()
    {
        return $this->storageKey;
    }
    public function getCreated()
    {
        return $this->meta[self::CREATED];
    }
    public function getLastUsed()
    {
        return $this->lastUsed;
    }
    public function clear()
    {
    }
    public function getName()
    {
        return $this->name;
    }
    public function setName($name)
    {
        $this->name = $name;
    }
    private function stampCreated($lifetime = null)
    {
        $timeStamp = time();
        $this->meta[self::CREATED] = $this->meta[self::UPDATED] = $this->lastUsed = $timeStamp;
        $this->meta[self::LIFETIME] = null === $lifetime ? ini_get('session.cookie_lifetime') : $lifetime;
    }
}
}

namespace Symfony\Component\HttpFoundation\Session\Storage\Handler {
class NullSessionHandler implements \SessionHandlerInterface
{
    public function open($savePath, $sessionName)
    {
        return true;
    }
    public function close()
    {
        return true;
    }
    public function read($sessionId)
    {
        return '';
    }
    public function write($sessionId, $data)
    {
        return true;
    }
    public function destroy($sessionId)
    {
        return true;
    }
    public function gc($maxlifetime)
    {
        return true;
    }
}
}

namespace Symfony\Component\HttpFoundation {
class AcceptHeaderItem
{
    private $value;
    private $quality = 1.0;
    private $index = 0;
    private $attributes = array();
    public function __construct($value, array $attributes = array())
    {
        $this->value = $value;
        foreach ($attributes as $name => $value) {
            $this->setAttribute($name, $value);
        }
    }
    public static function fromString($itemValue)
    {
        $bits = preg_split('/\\s*(?:;*("[^"]+");*|;*(\'[^\']+\');*|;+)\\s*/', $itemValue, 0, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);
        $value = array_shift($bits);
        $attributes = array();
        $lastNullAttribute = null;
        foreach ($bits as $bit) {
            if (($start = substr($bit, 0, 1)) === ($end = substr($bit, -1)) && ($start === '"' || $start === '\'')) {
                $attributes[$lastNullAttribute] = substr($bit, 1, -1);
            } elseif ('=' === $end) {
                $lastNullAttribute = $bit = substr($bit, 0, -1);
                $attributes[$bit] = null;
            } else {
                $parts = explode('=', $bit);
                $attributes[$parts[0]] = isset($parts[1]) && strlen($parts[1]) > 0 ? $parts[1] : '';
            }
        }
        return new self(($start = substr($value, 0, 1)) === ($end = substr($value, -1)) && ($start === '"' || $start === '\'') ? substr($value, 1, -1) : $value, $attributes);
    }
    public function __toString()
    {
        $string = $this->value . ($this->quality < 1 ? ';q=' . $this->quality : '');
        if (count($this->attributes) > 0) {
            $string .= ';' . implode(';', array_map(function ($name, $value) {
                return sprintf(preg_match('/[,;=]/', $value) ? '%s="%s"' : '%s=%s', $name, $value);
            }, array_keys($this->attributes), $this->attributes));
        }
        return $string;
    }
    public function setValue($value)
    {
        $this->value = $value;
        return $this;
    }
    public function getValue()
    {
        return $this->value;
    }
    public function setQuality($quality)
    {
        $this->quality = $quality;
        return $this;
    }
    public function getQuality()
    {
        return $this->quality;
    }
    public function setIndex($index)
    {
        $this->index = $index;
        return $this;
    }
    public function getIndex()
    {
        return $this->index;
    }
    public function hasAttribute($name)
    {
        return isset($this->attributes[$name]);
    }
    public function getAttribute($name, $default = null)
    {
        return isset($this->attributes[$name]) ? $this->attributes[$name] : $default;
    }
    public function getAttributes()
    {
        return $this->attributes;
    }
    public function setAttribute($name, $value)
    {
        if ('q' === $name) {
            $this->quality = (double) $value;
        } else {
            $this->attributes[$name] = (string) $value;
        }
        return $this;
    }
}
}

namespace Symfony\Component\HttpFoundation {
class AcceptHeader
{
    private $items = array();
    private $sorted = true;
    public function __construct(array $items)
    {
        foreach ($items as $item) {
            $this->add($item);
        }
    }
    public static function fromString($headerValue)
    {
        $index = 0;
        return new self(array_map(function ($itemValue) use(&$index) {
            $item = AcceptHeaderItem::fromString($itemValue);
            $item->setIndex($index++);
            return $item;
        }, preg_split('/\\s*(?:,*("[^"]+"),*|,*(\'[^\']+\'),*|,+)\\s*/', $headerValue, 0, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE)));
    }
    public function __toString()
    {
        return implode(',', $this->items);
    }
    public function has($value)
    {
        return isset($this->items[$value]);
    }
    public function get($value)
    {
        return isset($this->items[$value]) ? $this->items[$value] : null;
    }
    public function add(AcceptHeaderItem $item)
    {
        $this->items[$item->getValue()] = $item;
        $this->sorted = false;
        return $this;
    }
    public function all()
    {
        $this->sort();
        return $this->items;
    }
    public function filter($pattern)
    {
        return new self(array_filter($this->items, function (AcceptHeaderItem $item) use($pattern) {
            return preg_match($pattern, $item->getValue());
        }));
    }
    public function first()
    {
        $this->sort();
        return !empty($this->items) ? reset($this->items) : null;
    }
    private function sort()
    {
        if (!$this->sorted) {
            uasort($this->items, function ($a, $b) {
                $qA = $a->getQuality();
                $qB = $b->getQuality();
                if ($qA === $qB) {
                    return $a->getIndex() > $b->getIndex() ? 1 : -1;
                }
                return $qA > $qB ? -1 : 1;
            });
            $this->sorted = true;
        }
    }
}
}

namespace Symfony\Component\HttpFoundation {
class ResponseHeaderBag extends HeaderBag
{
    const COOKIES_FLAT = 'flat';
    const COOKIES_ARRAY = 'array';
    const DISPOSITION_ATTACHMENT = 'attachment';
    const DISPOSITION_INLINE = 'inline';
    protected $computedCacheControl = array();
    protected $cookies = array();
    protected $headerNames = array();
    public function __construct(array $headers = array())
    {
        parent::__construct($headers);
        if (!isset($this->headers['cache-control'])) {
            $this->set('Cache-Control', '');
        }
    }
    public function __toString()
    {
        $cookies = '';
        foreach ($this->getCookies() as $cookie) {
            $cookies .= 'Set-Cookie: ' . $cookie . "\r\n";
        }
        ksort($this->headerNames);
        return parent::__toString() . $cookies;
    }
    public function allPreserveCase()
    {
        return array_combine($this->headerNames, $this->headers);
    }
    public function replace(array $headers = array())
    {
        $this->headerNames = array();
        parent::replace($headers);
        if (!isset($this->headers['cache-control'])) {
            $this->set('Cache-Control', '');
        }
    }
    public function set($key, $values, $replace = true)
    {
        parent::set($key, $values, $replace);
        $uniqueKey = str_replace('_', '-', strtolower($key));
        $this->headerNames[$uniqueKey] = $key;
        if (in_array($uniqueKey, array('cache-control', 'etag', 'last-modified', 'expires'))) {
            $computed = $this->computeCacheControlValue();
            $this->headers['cache-control'] = array($computed);
            $this->headerNames['cache-control'] = 'Cache-Control';
            $this->computedCacheControl = $this->parseCacheControl($computed);
        }
    }
    public function remove($key)
    {
        parent::remove($key);
        $uniqueKey = str_replace('_', '-', strtolower($key));
        unset($this->headerNames[$uniqueKey]);
        if ('cache-control' === $uniqueKey) {
            $this->computedCacheControl = array();
        }
    }
    public function hasCacheControlDirective($key)
    {
        return array_key_exists($key, $this->computedCacheControl);
    }
    public function getCacheControlDirective($key)
    {
        return array_key_exists($key, $this->computedCacheControl) ? $this->computedCacheControl[$key] : null;
    }
    public function setCookie(Cookie $cookie)
    {
        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;
    }
    public function removeCookie($name, $path = '/', $domain = null)
    {
        if (null === $path) {
            $path = '/';
        }
        unset($this->cookies[$domain][$path][$name]);
        if (empty($this->cookies[$domain][$path])) {
            unset($this->cookies[$domain][$path]);
            if (empty($this->cookies[$domain])) {
                unset($this->cookies[$domain]);
            }
        }
    }
    public function getCookies($format = self::COOKIES_FLAT)
    {
        if (!in_array($format, array(self::COOKIES_FLAT, self::COOKIES_ARRAY))) {
            throw new \InvalidArgumentException(sprintf('Format "%s" invalid (%s).', $format, implode(', ', array(self::COOKIES_FLAT, self::COOKIES_ARRAY))));
        }
        if (self::COOKIES_ARRAY === $format) {
            return $this->cookies;
        }
        $flattenedCookies = array();
        foreach ($this->cookies as $path) {
            foreach ($path as $cookies) {
                foreach ($cookies as $cookie) {
                    $flattenedCookies[] = $cookie;
                }
            }
        }
        return $flattenedCookies;
    }
    public function clearCookie($name, $path = '/', $domain = null, $secure = false, $httpOnly = true)
    {
        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly));
    }
    public function makeDisposition($disposition, $filename, $filenameFallback = '')
    {
        if (!in_array($disposition, array(self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE))) {
            throw new \InvalidArgumentException(sprintf('The disposition must be either "%s" or "%s".', self::DISPOSITION_ATTACHMENT, self::DISPOSITION_INLINE));
        }
        if ('' == $filenameFallback) {
            $filenameFallback = $filename;
        }
        if (!preg_match('/^[\\x20-\\x7e]*$/', $filenameFallback)) {
            throw new \InvalidArgumentException('The filename fallback must only contain ASCII characters.');
        }
        if (false !== strpos($filenameFallback, '%')) {
            throw new \InvalidArgumentException('The filename fallback cannot contain the "%" character.');
        }
        if (false !== strpos($filename, '/') || false !== strpos($filename, '\\') || false !== strpos($filenameFallback, '/') || false !== strpos($filenameFallback, '\\')) {
            throw new \InvalidArgumentException('The filename and the fallback cannot contain the "/" and "\\" characters.');
        }
        $output = sprintf('%s; filename="%s"', $disposition, str_replace('"', '\\"', $filenameFallback));
        if ($filename !== $filenameFallback) {
            $output .= sprintf("; filename*=utf-8''%s", rawurlencode($filename));
        }
        return $output;
    }
    protected function computeCacheControlValue()
    {
        if (!$this->cacheControl && !$this->has('ETag') && !$this->has('Last-Modified') && !$this->has('Expires')) {
            return 'no-cache';
        }
        if (!$this->cacheControl) {
            return 'private, must-revalidate';
        }
        $header = $this->getCacheControlHeader();
        if (isset($this->cacheControl['public']) || isset($this->cacheControl['private'])) {
            return $header;
        }
        if (!isset($this->cacheControl['s-maxage'])) {
            return $header . ', private';
        }
        return $header;
    }
}
}

namespace Symfony\Component\HttpFoundation {
class Cookie
{
    protected $name;
    protected $value;
    protected $domain;
    protected $expire;
    protected $path;
    protected $secure;
    protected $httpOnly;
    public function __construct($name, $value = null, $expire = 0, $path = '/', $domain = null, $secure = false, $httpOnly = true)
    {
        if (preg_match("/[=,; \t\r\n\v\f]/", $name)) {
            throw new \InvalidArgumentException(sprintf('The cookie name "%s" contains invalid characters.', $name));
        }
        if (empty($name)) {
            throw new \InvalidArgumentException('The cookie name cannot be empty.');
        }
        if ($expire instanceof \DateTime || $expire instanceof \DateTimeInterface) {
            $expire = $expire->format('U');
        } elseif (!is_numeric($expire)) {
            $expire = strtotime($expire);
            if (false === $expire || -1 === $expire) {
                throw new \InvalidArgumentException('The cookie expiration time is not valid.');
            }
        }
        $this->name = $name;
        $this->value = $value;
        $this->domain = $domain;
        $this->expire = $expire;
        $this->path = empty($path) ? '/' : $path;
        $this->secure = (bool) $secure;
        $this->httpOnly = (bool) $httpOnly;
    }
    public function __toString()
    {
        $str = urlencode($this->getName()) . '=';
        if ('' === (string) $this->getValue()) {
            $str .= 'deleted; expires=' . gmdate('D, d-M-Y H:i:s T', time() - 31536001);
        } else {
            $str .= urlencode($this->getValue());
            if ($this->getExpiresTime() !== 0) {
                $str .= '; expires=' . gmdate('D, d-M-Y H:i:s T', $this->getExpiresTime());
            }
        }
        if ($this->path) {
            $str .= '; path=' . $this->path;
        }
        if ($this->getDomain()) {
            $str .= '; domain=' . $this->getDomain();
        }
        if (true === $this->isSecure()) {
            $str .= '; secure';
        }
        if (true === $this->isHttpOnly()) {
            $str .= '; httponly';
        }
        return $str;
    }
    public function getName()
    {
        return $this->name;
    }
    public function getValue()
    {
        return $this->value;
    }
    public function getDomain()
    {
        return $this->domain;
    }
    public function getExpiresTime()
    {
        return $this->expire;
    }
    public function getPath()
    {
        return $this->path;
    }
    public function isSecure()
    {
        return $this->secure;
    }
    public function isHttpOnly()
    {
        return $this->httpOnly;
    }
    public function isCleared()
    {
        return $this->expire < time();
    }
}
}

namespace Symfony\Component\HttpKernel {
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true);
}
}

namespace Symfony\Component\HttpKernel {
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
interface TerminableInterface
{
    public function terminate(Request $request, Response $response);
}
}

namespace Symfony\Component\Routing {
class CompiledRoute implements \Serializable
{
    private $variables;
    private $tokens;
    private $staticPrefix;
    private $regex;
    private $pathVariables;
    private $hostVariables;
    private $hostRegex;
    private $hostTokens;
    public function __construct($staticPrefix, $regex, array $tokens, array $pathVariables, $hostRegex = null, array $hostTokens = array(), array $hostVariables = array(), array $variables = array())
    {
        $this->staticPrefix = (string) $staticPrefix;
        $this->regex = $regex;
        $this->tokens = $tokens;
        $this->pathVariables = $pathVariables;
        $this->hostRegex = $hostRegex;
        $this->hostTokens = $hostTokens;
        $this->hostVariables = $hostVariables;
        $this->variables = $variables;
    }
    public function serialize()
    {
        return serialize(array('vars' => $this->variables, 'path_prefix' => $this->staticPrefix, 'path_regex' => $this->regex, 'path_tokens' => $this->tokens, 'path_vars' => $this->pathVariables, 'host_regex' => $this->hostRegex, 'host_tokens' => $this->hostTokens, 'host_vars' => $this->hostVariables));
    }
    public function unserialize($serialized)
    {
        $data = unserialize($serialized);
        $this->variables = $data['vars'];
        $this->staticPrefix = $data['path_prefix'];
        $this->regex = $data['path_regex'];
        $this->tokens = $data['path_tokens'];
        $this->pathVariables = $data['path_vars'];
        $this->hostRegex = $data['host_regex'];
        $this->hostTokens = $data['host_tokens'];
        $this->hostVariables = $data['host_vars'];
    }
    public function getStaticPrefix()
    {
        return $this->staticPrefix;
    }
    public function getRegex()
    {
        return $this->regex;
    }
    public function getHostRegex()
    {
        return $this->hostRegex;
    }
    public function getTokens()
    {
        return $this->tokens;
    }
    public function getHostTokens()
    {
        return $this->hostTokens;
    }
    public function getVariables()
    {
        return $this->variables;
    }
    public function getPathVariables()
    {
        return $this->pathVariables;
    }
    public function getHostVariables()
    {
        return $this->hostVariables;
    }
}
}

namespace Symfony\Component\Routing {
interface RouteCompilerInterface
{
    public static function compile(Route $route);
}
}

namespace Symfony\Component\Routing {
class RouteCompiler implements RouteCompilerInterface
{
    const REGEX_DELIMITER = '#';
    const SEPARATORS = '/,;.:-_~+*=@|';
    public static function compile(Route $route)
    {
        $hostVariables = array();
        $variables = array();
        $hostRegex = null;
        $hostTokens = array();
        if ('' !== ($host = $route->getHost())) {
            $result = self::compilePattern($route, $host, true);
            $hostVariables = $result['variables'];
            $variables = $hostVariables;
            $hostTokens = $result['tokens'];
            $hostRegex = $result['regex'];
        }
        $path = $route->getPath();
        $result = self::compilePattern($route, $path, false);
        $staticPrefix = $result['staticPrefix'];
        $pathVariables = $result['variables'];
        $variables = array_merge($variables, $pathVariables);
        $tokens = $result['tokens'];
        $regex = $result['regex'];
        return new CompiledRoute($staticPrefix, $regex, $tokens, $pathVariables, $hostRegex, $hostTokens, $hostVariables, array_unique($variables));
    }
    private static function compilePattern(Route $route, $pattern, $isHost)
    {
        $tokens = array();
        $variables = array();
        $matches = array();
        $pos = 0;
        $defaultSeparator = $isHost ? '.' : '/';
        preg_match_all('#\\{\\w+\\}#', $pattern, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
        foreach ($matches as $match) {
            $varName = substr($match[0][0], 1, -1);
            $precedingText = substr($pattern, $pos, $match[0][1] - $pos);
            $pos = $match[0][1] + strlen($match[0][0]);
            $precedingChar = strlen($precedingText) > 0 ? substr($precedingText, -1) : '';
            $isSeparator = '' !== $precedingChar && false !== strpos(static::SEPARATORS, $precedingChar);
            if (is_numeric($varName)) {
                throw new \DomainException(sprintf('Variable name "%s" cannot be numeric in route pattern "%s". Please use a different name.', $varName, $pattern));
            }
            if (in_array($varName, $variables)) {
                throw new \LogicException(sprintf('Route pattern "%s" cannot reference variable name "%s" more than once.', $pattern, $varName));
            }
            if ($isSeparator && strlen($precedingText) > 1) {
                $tokens[] = array('text', substr($precedingText, 0, -1));
            } elseif (!$isSeparator && strlen($precedingText) > 0) {
                $tokens[] = array('text', $precedingText);
            }
            $regexp = $route->getRequirement($varName);
            if (null === $regexp) {
                $followingPattern = (string) substr($pattern, $pos);
                $nextSeparator = self::findNextSeparator($followingPattern);
                $regexp = sprintf('[^%s%s]+', preg_quote($defaultSeparator, self::REGEX_DELIMITER), $defaultSeparator !== $nextSeparator && '' !== $nextSeparator ? preg_quote($nextSeparator, self::REGEX_DELIMITER) : '');
                if ('' !== $nextSeparator && !preg_match('#^\\{\\w+\\}#', $followingPattern) || '' === $followingPattern) {
                    $regexp .= '+';
                }
            }
            $tokens[] = array('variable', $isSeparator ? $precedingChar : '', $regexp, $varName);
            $variables[] = $varName;
        }
        if ($pos < strlen($pattern)) {
            $tokens[] = array('text', substr($pattern, $pos));
        }
        $firstOptional = PHP_INT_MAX;
        if (!$isHost) {
            for ($i = count($tokens) - 1; $i >= 0; --$i) {
                $token = $tokens[$i];
                if ('variable' === $token[0] && $route->hasDefault($token[3])) {
                    $firstOptional = $i;
                } else {
                    break;
                }
            }
        }
        $regexp = '';
        for ($i = 0, $nbToken = count($tokens); $i < $nbToken; ++$i) {
            $regexp .= self::computeRegexp($tokens, $i, $firstOptional);
        }
        return array('staticPrefix' => 'text' === $tokens[0][0] ? $tokens[0][1] : '', 'regex' => self::REGEX_DELIMITER . '^' . $regexp . '$' . self::REGEX_DELIMITER . 's' . ($isHost ? 'i' : ''), 'tokens' => array_reverse($tokens), 'variables' => $variables);
    }
    private static function findNextSeparator($pattern)
    {
        if ('' == $pattern) {
            return '';
        }
        $pattern = preg_replace('#\\{\\w+\\}#', '', $pattern);
        return isset($pattern[0]) && false !== strpos(static::SEPARATORS, $pattern[0]) ? $pattern[0] : '';
    }
    private static function computeRegexp(array $tokens, $index, $firstOptional)
    {
        $token = $tokens[$index];
        if ('text' === $token[0]) {
            return preg_quote($token[1], self::REGEX_DELIMITER);
        } else {
            if (0 === $index && 0 === $firstOptional) {
                return sprintf('%s(?P<%s>%s)?', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]);
            } else {
                $regexp = sprintf('%s(?P<%s>%s)', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]);
                if ($index >= $firstOptional) {
                    $regexp = "(?:{$regexp}";
                    $nbTokens = count($tokens);
                    if ($nbTokens - 1 == $index) {
                        $regexp .= str_repeat(')?', $nbTokens - $firstOptional - (0 === $firstOptional ? 1 : 0));
                    }
                }
                return $regexp;
            }
        }
    }
}
}

namespace Symfony\Component\Routing {
class Route implements \Serializable
{
    private $path = '/';
    private $host = '';
    private $schemes = array();
    private $methods = array();
    private $defaults = array();
    private $requirements = array();
    private $options = array();
    private $compiled;
    private $condition = '';
    public function __construct($path, array $defaults = array(), array $requirements = array(), array $options = array(), $host = '', $schemes = array(), $methods = array(), $condition = '')
    {
        $this->setPath($path);
        $this->setDefaults($defaults);
        $this->setRequirements($requirements);
        $this->setOptions($options);
        $this->setHost($host);
        if ($schemes) {
            $this->setSchemes($schemes);
        }
        if ($methods) {
            $this->setMethods($methods);
        }
        $this->setCondition($condition);
    }
    public function serialize()
    {
        return serialize(array('path' => $this->path, 'host' => $this->host, 'defaults' => $this->defaults, 'requirements' => $this->requirements, 'options' => $this->options, 'schemes' => $this->schemes, 'methods' => $this->methods, 'condition' => $this->condition, 'compiled' => $this->compiled));
    }
    public function unserialize($serialized)
    {
        $data = unserialize($serialized);
        $this->path = $data['path'];
        $this->host = $data['host'];
        $this->defaults = $data['defaults'];
        $this->requirements = $data['requirements'];
        $this->options = $data['options'];
        $this->schemes = $data['schemes'];
        $this->methods = $data['methods'];
        if (isset($data['condition'])) {
            $this->condition = $data['condition'];
        }
        if (isset($data['compiled'])) {
            $this->compiled = $data['compiled'];
        }
    }
    public function getPattern()
    {
        @trigger_error('The ' . __METHOD__ . ' method is deprecated since version 2.2 and will be removed in 3.0. Use the getPath() method instead.', E_USER_DEPRECATED);
        return $this->path;
    }
    public function setPattern($pattern)
    {
        @trigger_error('The ' . __METHOD__ . ' method is deprecated since version 2.2 and will be removed in 3.0. Use the setPath() method instead.', E_USER_DEPRECATED);
        return $this->setPath($pattern);
    }
    public function getPath()
    {
        return $this->path;
    }
    public function setPath($pattern)
    {
        $this->path = '/' . ltrim(trim($pattern), '/');
        $this->compiled = null;
        return $this;
    }
    public function getHost()
    {
        return $this->host;
    }
    public function setHost($pattern)
    {
        $this->host = (string) $pattern;
        $this->compiled = null;
        return $this;
    }
    public function getSchemes()
    {
        return $this->schemes;
    }
    public function setSchemes($schemes)
    {
        $this->schemes = array_map('strtolower', (array) $schemes);
        if ($this->schemes) {
            $this->requirements['_scheme'] = implode('|', $this->schemes);
        } else {
            unset($this->requirements['_scheme']);
        }
        $this->compiled = null;
        return $this;
    }
    public function hasScheme($scheme)
    {
        return in_array(strtolower($scheme), $this->schemes, true);
    }
    public function getMethods()
    {
        return $this->methods;
    }
    public function setMethods($methods)
    {
        $this->methods = array_map('strtoupper', (array) $methods);
        if ($this->methods) {
            $this->requirements['_method'] = implode('|', $this->methods);
        } else {
            unset($this->requirements['_method']);
        }
        $this->compiled = null;
        return $this;
    }
    public function getOptions()
    {
        return $this->options;
    }
    public function setOptions(array $options)
    {
        $this->options = array('compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler');
        return $this->addOptions($options);
    }
    public function addOptions(array $options)
    {
        foreach ($options as $name => $option) {
            $this->options[$name] = $option;
        }
        $this->compiled = null;
        return $this;
    }
    public function setOption($name, $value)
    {
        $this->options[$name] = $value;
        $this->compiled = null;
        return $this;
    }
    public function getOption($name)
    {
        return isset($this->options[$name]) ? $this->options[$name] : null;
    }
    public function hasOption($name)
    {
        return array_key_exists($name, $this->options);
    }
    public function getDefaults()
    {
        return $this->defaults;
    }
    public function setDefaults(array $defaults)
    {
        $this->defaults = array();
        return $this->addDefaults($defaults);
    }
    public function addDefaults(array $defaults)
    {
        foreach ($defaults as $name => $default) {
            $this->defaults[$name] = $default;
        }
        $this->compiled = null;
        return $this;
    }
    public function getDefault($name)
    {
        return isset($this->defaults[$name]) ? $this->defaults[$name] : null;
    }
    public function hasDefault($name)
    {
        return array_key_exists($name, $this->defaults);
    }
    public function setDefault($name, $default)
    {
        $this->defaults[$name] = $default;
        $this->compiled = null;
        return $this;
    }
    public function getRequirements()
    {
        return $this->requirements;
    }
    public function setRequirements(array $requirements)
    {
        $this->requirements = array();
        return $this->addRequirements($requirements);
    }
    public function addRequirements(array $requirements)
    {
        foreach ($requirements as $key => $regex) {
            $this->requirements[$key] = $this->sanitizeRequirement($key, $regex);
        }
        $this->compiled = null;
        return $this;
    }
    public function getRequirement($key)
    {
        if ('_scheme' === $key) {
            @trigger_error('The "_scheme" requirement is deprecated since version 2.2 and will be removed in 3.0. Use getSchemes() instead.', E_USER_DEPRECATED);
        } elseif ('_method' === $key) {
            @trigger_error('The "_method" requirement is deprecated since version 2.2 and will be removed in 3.0. Use getMethods() instead.', E_USER_DEPRECATED);
        }
        return isset($this->requirements[$key]) ? $this->requirements[$key] : null;
    }
    public function hasRequirement($key)
    {
        return array_key_exists($key, $this->requirements);
    }
    public function setRequirement($key, $regex)
    {
        $this->requirements[$key] = $this->sanitizeRequirement($key, $regex);
        $this->compiled = null;
        return $this;
    }
    public function getCondition()
    {
        return $this->condition;
    }
    public function setCondition($condition)
    {
        $this->condition = (string) $condition;
        $this->compiled = null;
        return $this;
    }
    public function compile()
    {
        if (null !== $this->compiled) {
            return $this->compiled;
        }
        $class = $this->getOption('compiler_class');
        return $this->compiled = $class::compile($this);
    }
    private function sanitizeRequirement($key, $regex)
    {
        if (!is_string($regex)) {
            throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" must be a string.', $key));
        }
        if ('' !== $regex && '^' === $regex[0]) {
            $regex = (string) substr($regex, 1);
        }
        if ('$' === substr($regex, -1)) {
            $regex = substr($regex, 0, -1);
        }
        if ('' === $regex) {
            throw new \InvalidArgumentException(sprintf('Routing requirement for "%s" cannot be empty.', $key));
        }
        if ('_scheme' === $key) {
            @trigger_error('The "_scheme" requirement is deprecated since version 2.2 and will be removed in 3.0. Use the setSchemes() method instead.', E_USER_DEPRECATED);
            $this->setSchemes(explode('|', $regex));
        } elseif ('_method' === $key) {
            @trigger_error('The "_method" requirement is deprecated since version 2.2 and will be removed in 3.0. Use the setMethods() method instead.', E_USER_DEPRECATED);
            $this->setMethods(explode('|', $regex));
        }
        return $regex;
    }
}
}

namespace Symfony\Component\Finder {
class SplFileInfo extends \SplFileInfo
{
    private $relativePath;
    private $relativePathname;
    public function __construct($file, $relativePath, $relativePathname)
    {
        parent::__construct($file);
        $this->relativePath = $relativePath;
        $this->relativePathname = $relativePathname;
    }
    public function getRelativePath()
    {
        return $this->relativePath;
    }
    public function getRelativePathname()
    {
        return $this->relativePathname;
    }
    public function getContents()
    {
        $level = error_reporting(0);
        $content = file_get_contents($this->getPathname());
        error_reporting($level);
        if (false === $content) {
            $error = error_get_last();
            throw new \RuntimeException($error['message']);
        }
        return $content;
    }
}
}

namespace Symfony\Component\Finder\Expression {
use Symfony\Component\Finder\Glob as FinderGlob;
class Glob implements ValueInterface
{
    private $pattern;
    public function __construct($pattern)
    {
        $this->pattern = $pattern;
    }
    public function render()
    {
        return $this->pattern;
    }
    public function renderPattern()
    {
        return $this->pattern;
    }
    public function getType()
    {
        return Expression::TYPE_GLOB;
    }
    public function isCaseSensitive()
    {
        return true;
    }
    public function prepend($expr)
    {
        $this->pattern = $expr . $this->pattern;
        return $this;
    }
    public function append($expr)
    {
        $this->pattern .= $expr;
        return $this;
    }
    public function isExpandable()
    {
        return false !== strpos($this->pattern, '{') && false !== strpos($this->pattern, '}');
    }
    public function toRegex($strictLeadingDot = true, $strictWildcardSlash = true)
    {
        $regex = FinderGlob::toRegex($this->pattern, $strictLeadingDot, $strictWildcardSlash, '');
        return new Regex($regex);
    }
}
}

namespace Symfony\Component\Finder\Expression {
class Regex implements ValueInterface
{
    const START_FLAG = '^';
    const END_FLAG = '$';
    const BOUNDARY = '~';
    const JOKER = '.*';
    const ESCAPING = '\\';
    private $pattern;
    private $options;
    private $startFlag;
    private $endFlag;
    private $startJoker;
    private $endJoker;
    public static function create($expr)
    {
        if (preg_match('/^(.{3,}?)([imsxuADU]*)$/', $expr, $m)) {
            $start = substr($m[1], 0, 1);
            $end = substr($m[1], -1);
            if ($start === $end && !preg_match('/[*?[:alnum:] \\\\]/', $start) || $start === '{' && $end === '}' || $start === '(' && $end === ')') {
                return new self(substr($m[1], 1, -1), $m[2], $end);
            }
        }
        throw new \InvalidArgumentException('Given expression is not a regex.');
    }
    public function __construct($pattern, $options = '', $delimiter = null)
    {
        if (null !== $delimiter) {
            $pattern = str_replace('\\' . $delimiter, $delimiter, $pattern);
        }
        $this->parsePattern($pattern);
        $this->options = $options;
    }
    public function __toString()
    {
        return $this->render();
    }
    public function render()
    {
        return self::BOUNDARY . $this->renderPattern() . self::BOUNDARY . $this->options;
    }
    public function renderPattern()
    {
        return ($this->startFlag ? self::START_FLAG : '') . ($this->startJoker ? self::JOKER : '') . str_replace(self::BOUNDARY, '\\' . self::BOUNDARY, $this->pattern) . ($this->endJoker ? self::JOKER : '') . ($this->endFlag ? self::END_FLAG : '');
    }
    public function isCaseSensitive()
    {
        return !$this->hasOption('i');
    }
    public function getType()
    {
        return Expression::TYPE_REGEX;
    }
    public function prepend($expr)
    {
        $this->pattern = $expr . $this->pattern;
        return $this;
    }
    public function append($expr)
    {
        $this->pattern .= $expr;
        return $this;
    }
    public function hasOption($option)
    {
        return false !== strpos($this->options, $option);
    }
    public function addOption($option)
    {
        if (!$this->hasOption($option)) {
            $this->options .= $option;
        }
        return $this;
    }
    public function removeOption($option)
    {
        $this->options = str_replace($option, '', $this->options);
        return $this;
    }
    public function setStartFlag($startFlag)
    {
        $this->startFlag = $startFlag;
        return $this;
    }
    public function hasStartFlag()
    {
        return $this->startFlag;
    }
    public function setEndFlag($endFlag)
    {
        $this->endFlag = (bool) $endFlag;
        return $this;
    }
    public function hasEndFlag()
    {
        return $this->endFlag;
    }
    public function setStartJoker($startJoker)
    {
        $this->startJoker = $startJoker;
        return $this;
    }
    public function hasStartJoker()
    {
        return $this->startJoker;
    }
    public function setEndJoker($endJoker)
    {
        $this->endJoker = (bool) $endJoker;
        return $this;
    }
    public function hasEndJoker()
    {
        return $this->endJoker;
    }
    public function replaceJokers($replacement)
    {
        $replace = function ($subject) use($replacement) {
            $subject = $subject[0];
            $replace = 0 === substr_count($subject, '\\') % 2;
            return $replace ? str_replace('.', $replacement, $subject) : $subject;
        };
        $this->pattern = preg_replace_callback('~[\\\\]*\\.~', $replace, $this->pattern);
        return $this;
    }
    private function parsePattern($pattern)
    {
        if ($this->startFlag = self::START_FLAG === substr($pattern, 0, 1)) {
            $pattern = substr($pattern, 1);
        }
        if ($this->startJoker = self::JOKER === substr($pattern, 0, 2)) {
            $pattern = substr($pattern, 2);
        }
        if ($this->endFlag = self::END_FLAG === substr($pattern, -1) && self::ESCAPING !== substr($pattern, -2, -1)) {
            $pattern = substr($pattern, 0, -1);
        }
        if ($this->endJoker = self::JOKER === substr($pattern, -2) && self::ESCAPING !== substr($pattern, -3, -2)) {
            $pattern = substr($pattern, 0, -2);
        }
        $this->pattern = $pattern;
    }
}
}

namespace Symfony\Component\Finder\Expression {
interface ValueInterface
{
    public function render();
    public function renderPattern();
    public function isCaseSensitive();
    public function getType();
    public function prepend($expr);
    public function append($expr);
}
}

namespace Symfony\Component\Finder\Expression {
class Expression implements ValueInterface
{
    const TYPE_REGEX = 1;
    const TYPE_GLOB = 2;
    private $value;
    public static function create($expr)
    {
        return new self($expr);
    }
    public function __construct($expr)
    {
        try {
            $this->value = Regex::create($expr);
        } catch (\InvalidArgumentException $e) {
            $this->value = new Glob($expr);
        }
    }
    public function __toString()
    {
        return $this->render();
    }
    public function render()
    {
        return $this->value->render();
    }
    public function renderPattern()
    {
        return $this->value->renderPattern();
    }
    public function isCaseSensitive()
    {
        return $this->value->isCaseSensitive();
    }
    public function getType()
    {
        return $this->value->getType();
    }
    public function prepend($expr)
    {
        $this->value->prepend($expr);
        return $this;
    }
    public function append($expr)
    {
        $this->value->append($expr);
        return $this;
    }
    public function isRegex()
    {
        return self::TYPE_REGEX === $this->value->getType();
    }
    public function isGlob()
    {
        return self::TYPE_GLOB === $this->value->getType();
    }
    public function getGlob()
    {
        if (self::TYPE_GLOB !== $this->value->getType()) {
            throw new \LogicException('Regex can\'t be transformed to glob.');
        }
        return $this->value;
    }
    public function getRegex()
    {
        return self::TYPE_REGEX === $this->value->getType() ? $this->value : $this->value->toRegex();
    }
}
}

namespace Symfony\Component\Finder\Iterator {
abstract class FilterIterator extends \FilterIterator
{
    public function rewind()
    {
        if (PHP_VERSION_ID > 50607 || PHP_VERSION_ID > 50523 && PHP_VERSION_ID < 50600) {
            parent::rewind();
            return;
        }
        $iterator = $this;
        while ($iterator instanceof \OuterIterator) {
            $innerIterator = $iterator->getInnerIterator();
            if ($innerIterator instanceof RecursiveDirectoryIterator) {
                if ($innerIterator->isRewindable()) {
                    $innerIterator->next();
                    $innerIterator->rewind();
                }
            } elseif ($innerIterator instanceof \FilesystemIterator) {
                $innerIterator->next();
                $innerIterator->rewind();
            }
            $iterator = $innerIterator;
        }
        parent::rewind();
    }
}
}

namespace Symfony\Component\Finder\Iterator {
use Symfony\Component\Finder\Expression\Expression;
abstract class MultiplePcreFilterIterator extends FilterIterator
{
    protected $matchRegexps = array();
    protected $noMatchRegexps = array();
    public function __construct(\Iterator $iterator, array $matchPatterns, array $noMatchPatterns)
    {
        foreach ($matchPatterns as $pattern) {
            $this->matchRegexps[] = $this->toRegex($pattern);
        }
        foreach ($noMatchPatterns as $pattern) {
            $this->noMatchRegexps[] = $this->toRegex($pattern);
        }
        parent::__construct($iterator);
    }
    protected function isRegex($str)
    {
        return Expression::create($str)->isRegex();
    }
    protected abstract function toRegex($str);
}
}

namespace Symfony\Component\Finder\Iterator {
class PathFilterIterator extends MultiplePcreFilterIterator
{
    public function accept()
    {
        $filename = $this->current()->getRelativePathname();
        if ('\\' === DIRECTORY_SEPARATOR) {
            $filename = str_replace('\\', '/', $filename);
        }
        foreach ($this->noMatchRegexps as $regex) {
            if (preg_match($regex, $filename)) {
                return false;
            }
        }
        $match = true;
        if ($this->matchRegexps) {
            $match = false;
            foreach ($this->matchRegexps as $regex) {
                if (preg_match($regex, $filename)) {
                    return true;
                }
            }
        }
        return $match;
    }
    protected function toRegex($str)
    {
        return $this->isRegex($str) ? $str : '/' . preg_quote($str, '/') . '/';
    }
}
}

namespace Symfony\Component\Finder\Iterator {
class ExcludeDirectoryFilterIterator extends FilterIterator implements \RecursiveIterator
{
    private $iterator;
    private $isRecursive;
    private $excludedDirs = array();
    private $excludedPattern;
    public function __construct(\Iterator $iterator, array $directories)
    {
        $this->iterator = $iterator;
        $this->isRecursive = $iterator instanceof \RecursiveIterator;
        $patterns = array();
        foreach ($directories as $directory) {
            if (!$this->isRecursive || false !== strpos($directory, '/')) {
                $patterns[] = preg_quote($directory, '#');
            } else {
                $this->excludedDirs[$directory] = true;
            }
        }
        if ($patterns) {
            $this->excludedPattern = '#(?:^|/)(?:' . implode('|', $patterns) . ')(?:/|$)#';
        }
        parent::__construct($iterator);
    }
    public function accept()
    {
        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {
            return false;
        }
        if ($this->excludedPattern) {
            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();
            $path = str_replace('\\', '/', $path);
            return !preg_match($this->excludedPattern, $path);
        }
        return true;
    }
    public function hasChildren()
    {
        return $this->isRecursive && $this->iterator->hasChildren();
    }
    public function getChildren()
    {
        $children = new self($this->iterator->getChildren(), array());
        $children->excludedDirs = $this->excludedDirs;
        $children->excludedPattern = $this->excludedPattern;
        return $children;
    }
}
}

namespace Symfony\Component\Finder\Iterator {
use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\SplFileInfo;
class RecursiveDirectoryIterator extends \RecursiveDirectoryIterator
{
    private $ignoreUnreadableDirs;
    private $rewindable;
    private $rootPath;
    private $subPath;
    private $directorySeparator = '/';
    public function __construct($path, $flags, $ignoreUnreadableDirs = false)
    {
        if ($flags & (self::CURRENT_AS_PATHNAME | self::CURRENT_AS_SELF)) {
            throw new \RuntimeException('This iterator only support returning current as fileinfo.');
        }
        parent::__construct($path, $flags);
        $this->ignoreUnreadableDirs = $ignoreUnreadableDirs;
        $this->rootPath = (string) $path;
        if ('/' !== DIRECTORY_SEPARATOR && !($flags & self::UNIX_PATHS)) {
            $this->directorySeparator = DIRECTORY_SEPARATOR;
        }
    }
    public function current()
    {
        if (null === ($subPathname = $this->subPath)) {
            $subPathname = $this->subPath = (string) $this->getSubPath();
        }
        if ('' !== $subPathname) {
            $subPathname .= $this->directorySeparator;
        }
        $subPathname .= $this->getFilename();
        return new SplFileInfo($this->rootPath . $this->directorySeparator . $subPathname, $this->subPath, $subPathname);
    }
    public function getChildren()
    {
        try {
            $children = parent::getChildren();
            if ($children instanceof self) {
                $children->ignoreUnreadableDirs = $this->ignoreUnreadableDirs;
                $children->rewindable =& $this->rewindable;
                $children->rootPath = $this->rootPath;
            }
            return $children;
        } catch (\UnexpectedValueException $e) {
            if ($this->ignoreUnreadableDirs) {
                return new \RecursiveArrayIterator(array());
            } else {
                throw new AccessDeniedException($e->getMessage(), $e->getCode(), $e);
            }
        }
    }
    public function rewind()
    {
        if (false === $this->isRewindable()) {
            return;
        }
        if (PHP_VERSION_ID < 50523 || PHP_VERSION_ID >= 50600 && PHP_VERSION_ID < 50607) {
            parent::next();
        }
        parent::rewind();
    }
    public function isRewindable()
    {
        if (null !== $this->rewindable) {
            return $this->rewindable;
        }
        if (false !== ($stream = @opendir($this->getPath()))) {
            $infos = stream_get_meta_data($stream);
            closedir($stream);
            if ($infos['seekable']) {
                return $this->rewindable = true;
            }
        }
        return $this->rewindable = false;
    }
}
}

namespace Symfony\Component\Finder\Iterator {
class FileTypeFilterIterator extends FilterIterator
{
    const ONLY_FILES = 1;
    const ONLY_DIRECTORIES = 2;
    private $mode;
    public function __construct(\Iterator $iterator, $mode)
    {
        $this->mode = $mode;
        parent::__construct($iterator);
    }
    public function accept()
    {
        $fileinfo = $this->current();
        if (self::ONLY_DIRECTORIES === (self::ONLY_DIRECTORIES & $this->mode) && $fileinfo->isFile()) {
            return false;
        } elseif (self::ONLY_FILES === (self::ONLY_FILES & $this->mode) && $fileinfo->isDir()) {
            return false;
        }
        return true;
    }
}
}

namespace Symfony\Component\Finder\Iterator {
use Symfony\Component\Finder\Expression\Expression;
class FilenameFilterIterator extends MultiplePcreFilterIterator
{
    public function accept()
    {
        $filename = $this->current()->getFilename();
        foreach ($this->noMatchRegexps as $regex) {
            if (preg_match($regex, $filename)) {
                return false;
            }
        }
        $match = true;
        if ($this->matchRegexps) {
            $match = false;
            foreach ($this->matchRegexps as $regex) {
                if (preg_match($regex, $filename)) {
                    return true;
                }
            }
        }
        return $match;
    }
    protected function toRegex($str)
    {
        return Expression::create($str)->getRegex()->render();
    }
}
}

namespace Symfony\Component\Finder\Shell {
class Shell
{
    const TYPE_UNIX = 1;
    const TYPE_DARWIN = 2;
    const TYPE_CYGWIN = 3;
    const TYPE_WINDOWS = 4;
    const TYPE_BSD = 5;
    private $type;
    public function getType()
    {
        if (null === $this->type) {
            $this->type = $this->guessType();
        }
        return $this->type;
    }
    public function testCommand($command)
    {
        if (!function_exists('exec')) {
            return false;
        }
        $testCommand = 'which ';
        if (self::TYPE_WINDOWS === $this->type) {
            $testCommand = 'where ';
        }
        $command = escapeshellcmd($command);
        exec($testCommand . $command, $output, $code);
        return 0 === $code && count($output) > 0;
    }
    private function guessType()
    {
        $os = strtolower(PHP_OS);
        if (false !== strpos($os, 'cygwin')) {
            return self::TYPE_CYGWIN;
        }
        if (false !== strpos($os, 'darwin')) {
            return self::TYPE_DARWIN;
        }
        if (false !== strpos($os, 'bsd')) {
            return self::TYPE_BSD;
        }
        if (0 === strpos($os, 'win')) {
            return self::TYPE_WINDOWS;
        }
        return self::TYPE_UNIX;
    }
}
}

namespace Symfony\Component\Finder\Adapter {
interface AdapterInterface
{
    public function setFollowLinks($followLinks);
    public function setMode($mode);
    public function setExclude(array $exclude);
    public function setDepths(array $depths);
    public function setNames(array $names);
    public function setNotNames(array $notNames);
    public function setContains(array $contains);
    public function setNotContains(array $notContains);
    public function setSizes(array $sizes);
    public function setDates(array $dates);
    public function setFilters(array $filters);
    public function setSort($sort);
    public function setPath(array $paths);
    public function setNotPath(array $notPaths);
    public function ignoreUnreadableDirs($ignore = true);
    public function searchInDirectory($dir);
    public function isSupported();
    public function getName();
}
}

namespace Symfony\Component\Finder\Adapter {
abstract class AbstractAdapter implements AdapterInterface
{
    protected $followLinks = false;
    protected $mode = 0;
    protected $minDepth = 0;
    protected $maxDepth = PHP_INT_MAX;
    protected $exclude = array();
    protected $names = array();
    protected $notNames = array();
    protected $contains = array();
    protected $notContains = array();
    protected $sizes = array();
    protected $dates = array();
    protected $filters = array();
    protected $sort = false;
    protected $paths = array();
    protected $notPaths = array();
    protected $ignoreUnreadableDirs = false;
    private static $areSupported = array();
    public function isSupported()
    {
        $name = $this->getName();
        if (!array_key_exists($name, self::$areSupported)) {
            self::$areSupported[$name] = $this->canBeUsed();
        }
        return self::$areSupported[$name];
    }
    public function setFollowLinks($followLinks)
    {
        $this->followLinks = $followLinks;
        return $this;
    }
    public function setMode($mode)
    {
        $this->mode = $mode;
        return $this;
    }
    public function setDepths(array $depths)
    {
        $this->minDepth = 0;
        $this->maxDepth = PHP_INT_MAX;
        foreach ($depths as $comparator) {
            switch ($comparator->getOperator()) {
                case '>':
                    $this->minDepth = $comparator->getTarget() + 1;
                    break;
                case '>=':
                    $this->minDepth = $comparator->getTarget();
                    break;
                case '<':
                    $this->maxDepth = $comparator->getTarget() - 1;
                    break;
                case '<=':
                    $this->maxDepth = $comparator->getTarget();
                    break;
                default:
                    $this->minDepth = $this->maxDepth = $comparator->getTarget();
            }
        }
        return $this;
    }
    public function setExclude(array $exclude)
    {
        $this->exclude = $exclude;
        return $this;
    }
    public function setNames(array $names)
    {
        $this->names = $names;
        return $this;
    }
    public function setNotNames(array $notNames)
    {
        $this->notNames = $notNames;
        return $this;
    }
    public function setContains(array $contains)
    {
        $this->contains = $contains;
        return $this;
    }
    public function setNotContains(array $notContains)
    {
        $this->notContains = $notContains;
        return $this;
    }
    public function setSizes(array $sizes)
    {
        $this->sizes = $sizes;
        return $this;
    }
    public function setDates(array $dates)
    {
        $this->dates = $dates;
        return $this;
    }
    public function setFilters(array $filters)
    {
        $this->filters = $filters;
        return $this;
    }
    public function setSort($sort)
    {
        $this->sort = $sort;
        return $this;
    }
    public function setPath(array $paths)
    {
        $this->paths = $paths;
        return $this;
    }
    public function setNotPath(array $notPaths)
    {
        $this->notPaths = $notPaths;
        return $this;
    }
    public function ignoreUnreadableDirs($ignore = true)
    {
        $this->ignoreUnreadableDirs = (bool) $ignore;
        return $this;
    }
    protected abstract function canBeUsed();
}
}

namespace Symfony\Component\Finder\Adapter {
use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\Iterator;
use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Expression\Expression;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Comparator\DateComparator;
abstract class AbstractFindAdapter extends AbstractAdapter
{
    protected $shell;
    public function __construct()
    {
        $this->shell = new Shell();
    }
    public function searchInDirectory($dir)
    {
        $dir = realpath($dir);
        if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode && ($this->contains || $this->notContains)) {
            return new Iterator\FilePathsIterator(array(), $dir);
        }
        $command = Command::create();
        $find = $this->buildFindCommand($command, $dir);
        if ($this->followLinks) {
            $find->add('-follow');
        }
        $find->add('-mindepth')->add($this->minDepth + 1);
        if (PHP_INT_MAX !== $this->maxDepth) {
            $find->add('-maxdepth')->add($this->maxDepth + 1);
        }
        if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode) {
            $find->add('-type d');
        } elseif (Iterator\FileTypeFilterIterator::ONLY_FILES === $this->mode) {
            $find->add('-type f');
        }
        $this->buildNamesFiltering($find, $this->names);
        $this->buildNamesFiltering($find, $this->notNames, true);
        $this->buildPathsFiltering($find, $dir, $this->paths);
        $this->buildPathsFiltering($find, $dir, $this->notPaths, true);
        $this->buildSizesFiltering($find, $this->sizes);
        $this->buildDatesFiltering($find, $this->dates);
        $useGrep = $this->shell->testCommand('grep') && $this->shell->testCommand('xargs');
        $useSort = is_int($this->sort) && $this->shell->testCommand('sort') && $this->shell->testCommand('cut');
        if ($useGrep && ($this->contains || $this->notContains)) {
            $grep = $command->ins('grep');
            $this->buildContentFiltering($grep, $this->contains);
            $this->buildContentFiltering($grep, $this->notContains, true);
        }
        if ($useSort) {
            $this->buildSorting($command, $this->sort);
        }
        $command->setErrorHandler($this->ignoreUnreadableDirs ? function ($stderr) {
        } : function ($stderr) {
            throw new AccessDeniedException($stderr);
        });
        $paths = $this->shell->testCommand('uniq') ? $command->add('| uniq')->execute() : array_unique($command->execute());
        $iterator = new Iterator\FilePathsIterator($paths, $dir);
        if ($this->exclude) {
            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
        }
        if (!$useGrep && ($this->contains || $this->notContains)) {
            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
        }
        if ($this->filters) {
            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
        }
        if (!$useSort && $this->sort) {
            $iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
            $iterator = $iteratorAggregate->getIterator();
        }
        return $iterator;
    }
    protected function canBeUsed()
    {
        return $this->shell->testCommand('find');
    }
    protected function buildFindCommand(Command $command, $dir)
    {
        return $command->ins('find')->add('find ')->arg($dir)->add('-noleaf');
    }
    private function buildNamesFiltering(Command $command, array $names, $not = false)
    {
        if (0 === count($names)) {
            return;
        }
        $command->add($not ? '-not' : null)->cmd('(');
        foreach ($names as $i => $name) {
            $expr = Expression::create($name);
            if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
                $expr = Expression::create($expr->getGlob()->toRegex(false));
            }
            if ($expr->isRegex()) {
                $regex = $expr->getRegex();
                $regex->prepend($regex->hasStartFlag() ? '/' : '/[^/]*')->setStartFlag(false)->setStartJoker(true)->replaceJokers('[^/]');
                if (!$regex->hasEndFlag() || $regex->hasEndJoker()) {
                    $regex->setEndJoker(false)->append('[^/]*');
                }
            }
            $command->add($i > 0 ? '-or' : null)->add($expr->isRegex() ? $expr->isCaseSensitive() ? '-regex' : '-iregex' : ($expr->isCaseSensitive() ? '-name' : '-iname'))->arg($expr->renderPattern());
        }
        $command->cmd(')');
    }
    private function buildPathsFiltering(Command $command, $dir, array $paths, $not = false)
    {
        if (0 === count($paths)) {
            return;
        }
        $command->add($not ? '-not' : null)->cmd('(');
        foreach ($paths as $i => $path) {
            $expr = Expression::create($path);
            if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
                $expr = Expression::create($expr->getGlob()->toRegex(false));
            }
            if ($expr->isRegex()) {
                $regex = $expr->getRegex();
                $regex->prepend($regex->hasStartFlag() ? preg_quote($dir) . DIRECTORY_SEPARATOR : '.*')->setEndJoker(!$regex->hasEndFlag());
            } else {
                $expr->prepend('*')->append('*');
            }
            $command->add($i > 0 ? '-or' : null)->add($expr->isRegex() ? $expr->isCaseSensitive() ? '-regex' : '-iregex' : ($expr->isCaseSensitive() ? '-path' : '-ipath'))->arg($expr->renderPattern());
        }
        $command->cmd(')');
    }
    private function buildSizesFiltering(Command $command, array $sizes)
    {
        foreach ($sizes as $i => $size) {
            $command->add($i > 0 ? '-and' : null);
            switch ($size->getOperator()) {
                case '<=':
                    $command->add('-size -' . ($size->getTarget() + 1) . 'c');
                    break;
                case '>=':
                    $command->add('-size +' . ($size->getTarget() - 1) . 'c');
                    break;
                case '>':
                    $command->add('-size +' . $size->getTarget() . 'c');
                    break;
                case '!=':
                    $command->add('-size -' . $size->getTarget() . 'c');
                    $command->add('-size +' . $size->getTarget() . 'c');
                    break;
                case '<':
                default:
                    $command->add('-size -' . $size->getTarget() . 'c');
            }
        }
    }
    private function buildDatesFiltering(Command $command, array $dates)
    {
        foreach ($dates as $i => $date) {
            $command->add($i > 0 ? '-and' : null);
            $mins = (int) round((time() - $date->getTarget()) / 60);
            if (0 > $mins) {
                $command->add(' -mmin -0');
                return;
            }
            switch ($date->getOperator()) {
                case '<=':
                    $command->add('-mmin +' . ($mins - 1));
                    break;
                case '>=':
                    $command->add('-mmin -' . ($mins + 1));
                    break;
                case '>':
                    $command->add('-mmin -' . $mins);
                    break;
                case '!=':
                    $command->add('-mmin +' . $mins . ' -or -mmin -' . $mins);
                    break;
                case '<':
                default:
                    $command->add('-mmin +' . $mins);
            }
        }
    }
    private function buildSorting(Command $command, $sort)
    {
        $this->buildFormatSorting($command, $sort);
    }
    protected abstract function buildFormatSorting(Command $command, $sort);
    protected abstract function buildContentFiltering(Command $command, array $contains, $not = false);
}
}

namespace Symfony\Component\Finder\Adapter {
use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;
class GnuFindAdapter extends AbstractFindAdapter
{
    public function getName()
    {
        return 'gnu_find';
    }
    protected function buildFormatSorting(Command $command, $sort)
    {
        switch ($sort) {
            case SortableIterator::SORT_BY_NAME:
                $command->ins('sort')->add('| sort');
                return;
            case SortableIterator::SORT_BY_TYPE:
                $format = '%y';
                break;
            case SortableIterator::SORT_BY_ACCESSED_TIME:
                $format = '%A@';
                break;
            case SortableIterator::SORT_BY_CHANGED_TIME:
                $format = '%C@';
                break;
            case SortableIterator::SORT_BY_MODIFIED_TIME:
                $format = '%T@';
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
        }
        $command->get('find')->add('-printf')->arg($format . ' %h/%f\\n')->add('| sort | cut')->arg('-d ')->arg('-f2-');
    }
    protected function canBeUsed()
    {
        return $this->shell->getType() === Shell::TYPE_UNIX && parent::canBeUsed();
    }
    protected function buildFindCommand(Command $command, $dir)
    {
        return parent::buildFindCommand($command, $dir)->add('-regextype posix-extended');
    }
    protected function buildContentFiltering(Command $command, array $contains, $not = false)
    {
        foreach ($contains as $contain) {
            $expr = Expression::create($contain);
            $command->add('| xargs -I{} -r grep -I')->add($expr->isCaseSensitive() ? null : '-i')->add($not ? '-L' : '-l')->add('-Ee')->arg($expr->renderPattern())->add('{}');
        }
    }
}
}

namespace Symfony\Component\Finder\Adapter {
use Symfony\Component\Finder\Iterator;
class PhpAdapter extends AbstractAdapter
{
    public function searchInDirectory($dir)
    {
        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;
        if ($this->followLinks) {
            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;
        }
        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);
        if ($this->exclude) {
            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
        }
        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);
        if ($this->minDepth > 0 || $this->maxDepth < PHP_INT_MAX) {
            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $this->minDepth, $this->maxDepth);
        }
        if ($this->mode) {
            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);
        }
        if ($this->names || $this->notNames) {
            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);
        }
        if ($this->contains || $this->notContains) {
            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
        }
        if ($this->sizes) {
            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);
        }
        if ($this->dates) {
            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);
        }
        if ($this->filters) {
            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
        }
        if ($this->paths || $this->notPaths) {
            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $this->notPaths);
        }
        if ($this->sort) {
            $iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
            $iterator = $iteratorAggregate->getIterator();
        }
        return $iterator;
    }
    public function getName()
    {
        return 'php';
    }
    protected function canBeUsed()
    {
        return true;
    }
}
}

namespace Symfony\Component\Finder\Adapter {
use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;
class BsdFindAdapter extends AbstractFindAdapter
{
    public function getName()
    {
        return 'bsd_find';
    }
    protected function canBeUsed()
    {
        return in_array($this->shell->getType(), array(Shell::TYPE_BSD, Shell::TYPE_DARWIN)) && parent::canBeUsed();
    }
    protected function buildFormatSorting(Command $command, $sort)
    {
        switch ($sort) {
            case SortableIterator::SORT_BY_NAME:
                $command->ins('sort')->add('| sort');
                return;
            case SortableIterator::SORT_BY_TYPE:
                $format = '%HT';
                break;
            case SortableIterator::SORT_BY_ACCESSED_TIME:
                $format = '%a';
                break;
            case SortableIterator::SORT_BY_CHANGED_TIME:
                $format = '%c';
                break;
            case SortableIterator::SORT_BY_MODIFIED_TIME:
                $format = '%m';
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
        }
        $command->add('-print0 | xargs -0 stat -f')->arg($format . '%t%N')->add('| sort | cut -f 2');
    }
    protected function buildFindCommand(Command $command, $dir)
    {
        parent::buildFindCommand($command, $dir)->addAtIndex('-E', 1);
        return $command;
    }
    protected function buildContentFiltering(Command $command, array $contains, $not = false)
    {
        foreach ($contains as $contain) {
            $expr = Expression::create($contain);
            $command->add('| grep -v \'^$\'')->add('| xargs -I{} grep -I')->add($expr->isCaseSensitive() ? null : '-i')->add($not ? '-L' : '-l')->add('-Ee')->arg($expr->renderPattern())->add('{}');
        }
    }
}
}

namespace Symfony\Component\Finder {
use Symfony\Component\Finder\Adapter\AdapterInterface;
use Symfony\Component\Finder\Adapter\GnuFindAdapter;
use Symfony\Component\Finder\Adapter\BsdFindAdapter;
use Symfony\Component\Finder\Adapter\PhpAdapter;
use Symfony\Component\Finder\Comparator\DateComparator;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Exception\ExceptionInterface;
use Symfony\Component\Finder\Iterator\CustomFilterIterator;
use Symfony\Component\Finder\Iterator\DateRangeFilterIterator;
use Symfony\Component\Finder\Iterator\DepthRangeFilterIterator;
use Symfony\Component\Finder\Iterator\ExcludeDirectoryFilterIterator;
use Symfony\Component\Finder\Iterator\FilecontentFilterIterator;
use Symfony\Component\Finder\Iterator\FilenameFilterIterator;
use Symfony\Component\Finder\Iterator\SizeRangeFilterIterator;
use Symfony\Component\Finder\Iterator\SortableIterator;
class Finder implements \IteratorAggregate, \Countable
{
    const IGNORE_VCS_FILES = 1;
    const IGNORE_DOT_FILES = 2;
    private $mode = 0;
    private $names = array();
    private $notNames = array();
    private $exclude = array();
    private $filters = array();
    private $depths = array();
    private $sizes = array();
    private $followLinks = false;
    private $sort = false;
    private $ignore = 0;
    private $dirs = array();
    private $dates = array();
    private $iterators = array();
    private $contains = array();
    private $notContains = array();
    private $adapters = array();
    private $paths = array();
    private $notPaths = array();
    private $ignoreUnreadableDirs = false;
    private static $vcsPatterns = array('.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg');
    public function __construct()
    {
        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;
        $this->addAdapter(new GnuFindAdapter())->addAdapter(new BsdFindAdapter())->addAdapter(new PhpAdapter(), -50)->setAdapter('php');
    }
    public static function create()
    {
        return new static();
    }
    public function addAdapter(AdapterInterface $adapter, $priority = 0)
    {
        $this->adapters[$adapter->getName()] = array('adapter' => $adapter, 'priority' => $priority, 'selected' => false);
        return $this->sortAdapters();
    }
    public function useBestAdapter()
    {
        $this->resetAdapterSelection();
        return $this->sortAdapters();
    }
    public function setAdapter($name)
    {
        if (!isset($this->adapters[$name])) {
            throw new \InvalidArgumentException(sprintf('Adapter "%s" does not exist.', $name));
        }
        $this->resetAdapterSelection();
        $this->adapters[$name]['selected'] = true;
        return $this->sortAdapters();
    }
    public function removeAdapters()
    {
        $this->adapters = array();
        return $this;
    }
    public function getAdapters()
    {
        return array_values(array_map(function (array $adapter) {
            return $adapter['adapter'];
        }, $this->adapters));
    }
    public function directories()
    {
        $this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;
        return $this;
    }
    public function files()
    {
        $this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;
        return $this;
    }
    public function depth($level)
    {
        $this->depths[] = new Comparator\NumberComparator($level);
        return $this;
    }
    public function date($date)
    {
        $this->dates[] = new Comparator\DateComparator($date);
        return $this;
    }
    public function name($pattern)
    {
        $this->names[] = $pattern;
        return $this;
    }
    public function notName($pattern)
    {
        $this->notNames[] = $pattern;
        return $this;
    }
    public function contains($pattern)
    {
        $this->contains[] = $pattern;
        return $this;
    }
    public function notContains($pattern)
    {
        $this->notContains[] = $pattern;
        return $this;
    }
    public function path($pattern)
    {
        $this->paths[] = $pattern;
        return $this;
    }
    public function notPath($pattern)
    {
        $this->notPaths[] = $pattern;
        return $this;
    }
    public function size($size)
    {
        $this->sizes[] = new Comparator\NumberComparator($size);
        return $this;
    }
    public function exclude($dirs)
    {
        $this->exclude = array_merge($this->exclude, (array) $dirs);
        return $this;
    }
    public function ignoreDotFiles($ignoreDotFiles)
    {
        if ($ignoreDotFiles) {
            $this->ignore |= static::IGNORE_DOT_FILES;
        } else {
            $this->ignore &= ~static::IGNORE_DOT_FILES;
        }
        return $this;
    }
    public function ignoreVCS($ignoreVCS)
    {
        if ($ignoreVCS) {
            $this->ignore |= static::IGNORE_VCS_FILES;
        } else {
            $this->ignore &= ~static::IGNORE_VCS_FILES;
        }
        return $this;
    }
    public static function addVCSPattern($pattern)
    {
        foreach ((array) $pattern as $p) {
            self::$vcsPatterns[] = $p;
        }
        self::$vcsPatterns = array_unique(self::$vcsPatterns);
    }
    public function sort(\Closure $closure)
    {
        $this->sort = $closure;
        return $this;
    }
    public function sortByName()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_NAME;
        return $this;
    }
    public function sortByType()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;
        return $this;
    }
    public function sortByAccessedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;
        return $this;
    }
    public function sortByChangedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;
        return $this;
    }
    public function sortByModifiedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;
        return $this;
    }
    public function filter(\Closure $closure)
    {
        $this->filters[] = $closure;
        return $this;
    }
    public function followLinks()
    {
        $this->followLinks = true;
        return $this;
    }
    public function ignoreUnreadableDirs($ignore = true)
    {
        $this->ignoreUnreadableDirs = (bool) $ignore;
        return $this;
    }
    public function in($dirs)
    {
        $resolvedDirs = array();
        foreach ((array) $dirs as $dir) {
            if (is_dir($dir)) {
                $resolvedDirs[] = $dir;
            } elseif ($glob = glob($dir, (defined('GLOB_BRACE') ? GLOB_BRACE : 0) | GLOB_ONLYDIR)) {
                $resolvedDirs = array_merge($resolvedDirs, $glob);
            } else {
                throw new \InvalidArgumentException(sprintf('The "%s" directory does not exist.', $dir));
            }
        }
        $this->dirs = array_merge($this->dirs, $resolvedDirs);
        return $this;
    }
    public function getIterator()
    {
        if (0 === count($this->dirs) && 0 === count($this->iterators)) {
            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');
        }
        if (1 === count($this->dirs) && 0 === count($this->iterators)) {
            return $this->searchInDirectory($this->dirs[0]);
        }
        $iterator = new \AppendIterator();
        foreach ($this->dirs as $dir) {
            $iterator->append($this->searchInDirectory($dir));
        }
        foreach ($this->iterators as $it) {
            $iterator->append($it);
        }
        return $iterator;
    }
    public function append($iterator)
    {
        if ($iterator instanceof \IteratorAggregate) {
            $this->iterators[] = $iterator->getIterator();
        } elseif ($iterator instanceof \Iterator) {
            $this->iterators[] = $iterator;
        } elseif ($iterator instanceof \Traversable || is_array($iterator)) {
            $it = new \ArrayIterator();
            foreach ($iterator as $file) {
                $it->append($file instanceof \SplFileInfo ? $file : new \SplFileInfo($file));
            }
            $this->iterators[] = $it;
        } else {
            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');
        }
        return $this;
    }
    public function count()
    {
        return iterator_count($this->getIterator());
    }
    private function sortAdapters()
    {
        uasort($this->adapters, function (array $a, array $b) {
            if ($a['selected'] || $b['selected']) {
                return $a['selected'] ? -1 : 1;
            }
            return $a['priority'] > $b['priority'] ? -1 : 1;
        });
        return $this;
    }
    private function searchInDirectory($dir)
    {
        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {
            $this->exclude = array_merge($this->exclude, self::$vcsPatterns);
        }
        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {
            $this->notPaths[] = '#(^|/)\\..+(/|$)#';
        }
        foreach ($this->adapters as $adapter) {
            if ($adapter['adapter']->isSupported()) {
                try {
                    return $this->buildAdapter($adapter['adapter'])->searchInDirectory($dir);
                } catch (ExceptionInterface $e) {
                }
            }
        }
        throw new \RuntimeException('No supported adapter found.');
    }
    private function buildAdapter(AdapterInterface $adapter)
    {
        return $adapter->setFollowLinks($this->followLinks)->setDepths($this->depths)->setMode($this->mode)->setExclude($this->exclude)->setNames($this->names)->setNotNames($this->notNames)->setContains($this->contains)->setNotContains($this->notContains)->setSizes($this->sizes)->setDates($this->dates)->setFilters($this->filters)->setSort($this->sort)->setPath($this->paths)->setNotPath($this->notPaths)->ignoreUnreadableDirs($this->ignoreUnreadableDirs);
    }
    private function resetAdapterSelection()
    {
        $this->adapters = array_map(function (array $properties) {
            $properties['selected'] = false;
            return $properties;
        }, $this->adapters);
    }
}
}

namespace Symfony\Component\Finder {
class Glob
{
    public static function toRegex($glob, $strictLeadingDot = true, $strictWildcardSlash = true, $delimiter = '#')
    {
        $firstByte = true;
        $escaping = false;
        $inCurlies = 0;
        $regex = '';
        $sizeGlob = strlen($glob);
        for ($i = 0; $i < $sizeGlob; ++$i) {
            $car = $glob[$i];
            if ($firstByte) {
                if ($strictLeadingDot && '.' !== $car) {
                    $regex .= '(?=[^\\.])';
                }
                $firstByte = false;
            }
            if ('/' === $car) {
                $firstByte = true;
            }
            if ($delimiter === $car || '.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {
                $regex .= "\\{$car}";
            } elseif ('*' === $car) {
                $regex .= $escaping ? '\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');
            } elseif ('?' === $car) {
                $regex .= $escaping ? '\\?' : ($strictWildcardSlash ? '[^/]' : '.');
            } elseif ('{' === $car) {
                $regex .= $escaping ? '\\{' : '(';
                if (!$escaping) {
                    ++$inCurlies;
                }
            } elseif ('}' === $car && $inCurlies) {
                $regex .= $escaping ? '}' : ')';
                if (!$escaping) {
                    --$inCurlies;
                }
            } elseif (',' === $car && $inCurlies) {
                $regex .= $escaping ? ',' : '|';
            } elseif ('\\' === $car) {
                if ($escaping) {
                    $regex .= '\\\\';
                    $escaping = false;
                } else {
                    $escaping = true;
                }
                continue;
            } else {
                $regex .= $car;
            }
            $escaping = false;
        }
        return $delimiter . '^' . $regex . '$' . $delimiter;
    }
}
}

namespace Symfony\Component\Finder\Iterator {
class DepthRangeFilterIterator extends FilterIterator
{
    private $minDepth = 0;
    public function __construct(\RecursiveIteratorIterator $iterator, $minDepth = 0, $maxDepth = PHP_INT_MAX)
    {
        $this->minDepth = $minDepth;
        $iterator->setMaxDepth(PHP_INT_MAX === $maxDepth ? -1 : $maxDepth);
        parent::__construct($iterator);
    }
    public function accept()
    {
        return $this->getInnerIterator()->getDepth() >= $this->minDepth;
    }
}
}

namespace Symfony\Component\Finder\Comparator {
class Comparator
{
    private $target;
    private $operator = '==';
    public function getTarget()
    {
        return $this->target;
    }
    public function setTarget($target)
    {
        $this->target = $target;
    }
    public function getOperator()
    {
        return $this->operator;
    }
    public function setOperator($operator)
    {
        if (!$operator) {
            $operator = '==';
        }
        if (!in_array($operator, array('>', '<', '>=', '<=', '==', '!='))) {
            throw new \InvalidArgumentException(sprintf('Invalid operator "%s".', $operator));
        }
        $this->operator = $operator;
    }
    public function test($test)
    {
        switch ($this->operator) {
            case '>':
                return $test > $this->target;
            case '>=':
                return $test >= $this->target;
            case '<':
                return $test < $this->target;
            case '<=':
                return $test <= $this->target;
            case '!=':
                return $test != $this->target;
        }
        return $test == $this->target;
    }
}
}

namespace Symfony\Component\Finder\Comparator {
class NumberComparator extends Comparator
{
    public function __construct($test)
    {
        if (!preg_match('#^\\s*(==|!=|[<>]=?)?\\s*([0-9\\.]+)\\s*([kmg]i?)?\\s*$#i', $test, $matches)) {
            throw new \InvalidArgumentException(sprintf('Don\'t understand "%s" as a number test.', $test));
        }
        $target = $matches[2];
        if (!is_numeric($target)) {
            throw new \InvalidArgumentException(sprintf('Invalid number "%s".', $target));
        }
        if (isset($matches[3])) {
            switch (strtolower($matches[3])) {
                case 'k':
                    $target *= 1000;
                    break;
                case 'ki':
                    $target *= 1024;
                    break;
                case 'm':
                    $target *= 1000000;
                    break;
                case 'mi':
                    $target *= 1024 * 1024;
                    break;
                case 'g':
                    $target *= 1000000000;
                    break;
                case 'gi':
                    $target *= 1024 * 1024 * 1024;
                    break;
            }
        }
        $this->setTarget($target);
        $this->setOperator(isset($matches[1]) ? $matches[1] : '==');
    }
}
}

namespace Symfony\Component\Translation {
interface TranslatorInterface
{
    public function trans($id, array $parameters = array(), $domain = null, $locale = null);
    public function transChoice($id, $number, array $parameters = array(), $domain = null, $locale = null);
    public function setLocale($locale);
    public function getLocale();
}
}

namespace Symfony\Component\Console\Command {
use Symfony\Component\Console\Application;
use Symfony\Component\Console\Exception\ExceptionInterface;
use Symfony\Component\Console\Exception\InvalidArgumentException;
use Symfony\Component\Console\Exception\LogicException;
use Symfony\Component\Console\Helper\HelperSet;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputDefinition;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
class Command
{
    protected static $defaultName;
    private $application;
    private $name;
    private $processTitle;
    private $aliases = array();
    private $definition;
    private $hidden = false;
    private $help;
    private $description;
    private $ignoreValidationErrors = false;
    private $applicationDefinitionMerged = false;
    private $applicationDefinitionMergedWithArgs = false;
    private $code;
    private $synopsis = array();
    private $usages = array();
    private $helperSet;
    public static function getDefaultName()
    {
        $class = \get_called_class();
        $r = new \ReflectionProperty($class, 'defaultName');
        return $class === $r->class ? static::$defaultName : null;
    }
    public function __construct($name = null)
    {
        $this->definition = new InputDefinition();
        if (null !== $name || null !== ($name = static::getDefaultName())) {
            $this->setName($name);
        }
        $this->configure();
    }
    public function ignoreValidationErrors()
    {
        $this->ignoreValidationErrors = true;
    }
    public function setApplication(Application $application = null)
    {
        $this->application = $application;
        if ($application) {
            $this->setHelperSet($application->getHelperSet());
        } else {
            $this->helperSet = null;
        }
    }
    public function setHelperSet(HelperSet $helperSet)
    {
        $this->helperSet = $helperSet;
    }
    public function getHelperSet()
    {
        return $this->helperSet;
    }
    public function getApplication()
    {
        return $this->application;
    }
    public function isEnabled()
    {
        return true;
    }
    protected function configure()
    {
    }
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        throw new LogicException('You must override the execute() method in the concrete command class.');
    }
    protected function interact(InputInterface $input, OutputInterface $output)
    {
    }
    protected function initialize(InputInterface $input, OutputInterface $output)
    {
    }
    public function run(InputInterface $input, OutputInterface $output)
    {
        $this->getSynopsis(true);
        $this->getSynopsis(false);
        $this->mergeApplicationDefinition();
        try {
            $input->bind($this->definition);
        } catch (ExceptionInterface $e) {
            if (!$this->ignoreValidationErrors) {
                throw $e;
            }
        }
        $this->initialize($input, $output);
        if (null !== $this->processTitle) {
            if (\function_exists('cli_set_process_title')) {
                if (!@cli_set_process_title($this->processTitle)) {
                    if ('Darwin' === PHP_OS) {
                        $output->writeln('<comment>Running "cli_set_process_title" as an unprivileged user is not supported on MacOS.</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);
                    } else {
                        cli_set_process_title($this->processTitle);
                    }
                }
            } elseif (\function_exists('setproctitle')) {
                setproctitle($this->processTitle);
            } elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
                $output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
            }
        }
        if ($input->isInteractive()) {
            $this->interact($input, $output);
        }
        if ($input->hasArgument('command') && null === $input->getArgument('command')) {
            $input->setArgument('command', $this->getName());
        }
        $input->validate();
        if ($this->code) {
            $statusCode = \call_user_func($this->code, $input, $output);
        } else {
            $statusCode = $this->execute($input, $output);
        }
        return is_numeric($statusCode) ? (int) $statusCode : 0;
    }
    public function setCode(callable $code)
    {
        if ($code instanceof \Closure) {
            $r = new \ReflectionFunction($code);
            if (null === $r->getClosureThis()) {
                if (\PHP_VERSION_ID < 70000) {
                    $code = @\Closure::bind($code, $this);
                } else {
                    $code = \Closure::bind($code, $this);
                }
            }
        }
        $this->code = $code;
        return $this;
    }
    public function mergeApplicationDefinition($mergeArgs = true)
    {
        if (null === $this->application || true === $this->applicationDefinitionMerged && ($this->applicationDefinitionMergedWithArgs || !$mergeArgs)) {
            return;
        }
        $this->definition->addOptions($this->application->getDefinition()->getOptions());
        if ($mergeArgs) {
            $currentArguments = $this->definition->getArguments();
            $this->definition->setArguments($this->application->getDefinition()->getArguments());
            $this->definition->addArguments($currentArguments);
        }
        $this->applicationDefinitionMerged = true;
        if ($mergeArgs) {
            $this->applicationDefinitionMergedWithArgs = true;
        }
    }
    public function setDefinition($definition)
    {
        if ($definition instanceof InputDefinition) {
            $this->definition = $definition;
        } else {
            $this->definition->setDefinition($definition);
        }
        $this->applicationDefinitionMerged = false;
        return $this;
    }
    public function getDefinition()
    {
        return $this->definition;
    }
    public function getNativeDefinition()
    {
        return $this->getDefinition();
    }
    public function addArgument($name, $mode = null, $description = '', $default = null)
    {
        $this->definition->addArgument(new InputArgument($name, $mode, $description, $default));
        return $this;
    }
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null)
    {
        $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default));
        return $this;
    }
    public function setName($name)
    {
        $this->validateName($name);
        $this->name = $name;
        return $this;
    }
    public function setProcessTitle($title)
    {
        $this->processTitle = $title;
        return $this;
    }
    public function getName()
    {
        return $this->name;
    }
    public function setHidden($hidden)
    {
        $this->hidden = (bool) $hidden;
        return $this;
    }
    public function isHidden()
    {
        return $this->hidden;
    }
    public function setDescription($description)
    {
        $this->description = $description;
        return $this;
    }
    public function getDescription()
    {
        return $this->description;
    }
    public function setHelp($help)
    {
        $this->help = $help;
        return $this;
    }
    public function getHelp()
    {
        return $this->help;
    }
    public function getProcessedHelp()
    {
        $name = $this->name;
        $placeholders = array('%command.name%', '%command.full_name%');
        $replacements = array($name, $_SERVER['PHP_SELF'] . ' ' . $name);
        return str_replace($placeholders, $replacements, $this->getHelp() ?: $this->getDescription());
    }
    public function setAliases($aliases)
    {
        if (!\is_array($aliases) && !$aliases instanceof \Traversable) {
            throw new InvalidArgumentException('$aliases must be an array or an instance of \\Traversable');
        }
        foreach ($aliases as $alias) {
            $this->validateName($alias);
        }
        $this->aliases = $aliases;
        return $this;
    }
    public function getAliases()
    {
        return $this->aliases;
    }
    public function getSynopsis($short = false)
    {
        $key = $short ? 'short' : 'long';
        if (!isset($this->synopsis[$key])) {
            $this->synopsis[$key] = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis($short)));
        }
        return $this->synopsis[$key];
    }
    public function addUsage($usage)
    {
        if (0 !== strpos($usage, $this->name)) {
            $usage = sprintf('%s %s', $this->name, $usage);
        }
        $this->usages[] = $usage;
        return $this;
    }
    public function getUsages()
    {
        return $this->usages;
    }
    public function getHelper($name)
    {
        if (null === $this->helperSet) {
            throw new LogicException(sprintf('Cannot retrieve helper "%s" because there is no HelperSet defined. Did you forget to add your command to the application or to set the application on the command using the setApplication() method? You can also set the HelperSet directly using the setHelperSet() method.', $name));
        }
        return $this->helperSet->get($name);
    }
    private function validateName($name)
    {
        if (!preg_match('/^[^\\:]++(\\:[^\\:]++)*$/', $name)) {
            throw new InvalidArgumentException(sprintf('Command name "%s" is invalid.', $name));
        }
    }
}
}

namespace League\Flysystem {
interface AdapterInterface extends ReadInterface
{
    const VISIBILITY_PUBLIC = 'public';
    const VISIBILITY_PRIVATE = 'private';
    public function write($path, $contents, Config $config);
    public function writeStream($path, $resource, Config $config);
    public function update($path, $contents, Config $config);
    public function updateStream($path, $resource, Config $config);
    public function rename($path, $newpath);
    public function copy($path, $newpath);
    public function delete($path);
    public function deleteDir($dirname);
    public function createDir($dirname, Config $config);
    public function setVisibility($path, $visibility);
}
}

namespace League\Flysystem {
interface ReadInterface
{
    public function has($path);
    public function read($path);
    public function readStream($path);
    public function listContents($directory = '', $recursive = false);
    public function getMetadata($path);
    public function getSize($path);
    public function getMimetype($path);
    public function getTimestamp($path);
    public function getVisibility($path);
}
}

namespace League\Flysystem {
interface FilesystemInterface
{
    public function has($path);
    public function read($path);
    public function readStream($path);
    public function listContents($directory = '', $recursive = false);
    public function getMetadata($path);
    public function getSize($path);
    public function getMimetype($path);
    public function getTimestamp($path);
    public function getVisibility($path);
    public function write($path, $contents, array $config = []);
    public function writeStream($path, $resource, array $config = []);
    public function update($path, $contents, array $config = []);
    public function updateStream($path, $resource, array $config = []);
    public function rename($path, $newpath);
    public function copy($path, $newpath);
    public function delete($path);
    public function deleteDir($dirname);
    public function createDir($dirname, array $config = []);
    public function setVisibility($path, $visibility);
    public function put($path, $contents, array $config = []);
    public function putStream($path, $resource, array $config = []);
    public function readAndDelete($path);
    public function get($path, Handler $handler = null);
    public function addPlugin(PluginInterface $plugin);
}
}

namespace League\Flysystem\Plugin {
use BadMethodCallException;
use League\Flysystem\FilesystemInterface;
use League\Flysystem\PluginInterface;
use LogicException;
trait PluggableTrait
{
    protected $plugins = [];
    public function addPlugin(PluginInterface $plugin)
    {
        if (!method_exists($plugin, 'handle')) {
            throw new LogicException(get_class($plugin) . ' does not have a handle method.');
        }
        $this->plugins[$plugin->getMethod()] = $plugin;
        return $this;
    }
    protected function findPlugin($method)
    {
        if (!isset($this->plugins[$method])) {
            throw new PluginNotFoundException('Plugin not found for method: ' . $method);
        }
        return $this->plugins[$method];
    }
    protected function invokePlugin($method, array $arguments, FilesystemInterface $filesystem)
    {
        $plugin = $this->findPlugin($method);
        $plugin->setFilesystem($filesystem);
        $callback = [$plugin, 'handle'];
        return call_user_func_array($callback, $arguments);
    }
    public function __call($method, array $arguments)
    {
        try {
            return $this->invokePlugin($method, $arguments, $this);
        } catch (PluginNotFoundException $e) {
            throw new BadMethodCallException('Call to undefined method ' . get_class($this) . '::' . $method);
        }
    }
}
}

namespace League\Flysystem\Adapter {
use League\Flysystem\AdapterInterface;
abstract class AbstractAdapter implements AdapterInterface
{
    protected $pathPrefix;
    protected $pathSeparator = '/';
    public function setPathPrefix($prefix)
    {
        $prefix = (string) $prefix;
        if ($prefix === '') {
            $this->pathPrefix = null;
            return;
        }
        $this->pathPrefix = rtrim($prefix, '\\/') . $this->pathSeparator;
    }
    public function getPathPrefix()
    {
        return $this->pathPrefix;
    }
    public function applyPathPrefix($path)
    {
        return $this->getPathPrefix() . ltrim($path, '\\/');
    }
    public function removePathPrefix($path)
    {
        return substr($path, strlen($this->getPathPrefix()));
    }
}
}

namespace League\Flysystem\Adapter {
use DirectoryIterator;
use FilesystemIterator;
use finfo as Finfo;
use League\Flysystem\AdapterInterface;
use League\Flysystem\Config;
use League\Flysystem\Exception;
use League\Flysystem\NotSupportedException;
use League\Flysystem\UnreadableFileException;
use League\Flysystem\Util;
use LogicException;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use SplFileInfo;
class Local extends AbstractAdapter
{
    const SKIP_LINKS = 01;
    const DISALLOW_LINKS = 02;
    protected static $permissions = ['file' => ['public' => 0644, 'private' => 0600], 'dir' => ['public' => 0755, 'private' => 0700]];
    protected $pathSeparator = DIRECTORY_SEPARATOR;
    protected $permissionMap;
    protected $writeFlags;
    private $linkHandling;
    public function __construct($root, $writeFlags = LOCK_EX, $linkHandling = self::DISALLOW_LINKS, array $permissions = [])
    {
        $root = is_link($root) ? realpath($root) : $root;
        $this->permissionMap = array_replace_recursive(static::$permissions, $permissions);
        $this->ensureDirectory($root);
        if (!is_dir($root) || !is_readable($root)) {
            throw new LogicException('The root path ' . $root . ' is not readable.');
        }
        $this->setPathPrefix($root);
        $this->writeFlags = $writeFlags;
        $this->linkHandling = $linkHandling;
    }
    protected function ensureDirectory($root)
    {
        if (!is_dir($root)) {
            $umask = umask(0);
            @mkdir($root, $this->permissionMap['dir']['public'], true);
            umask($umask);
            if (!is_dir($root)) {
                throw new Exception(sprintf('Impossible to create the root directory "%s".', $root));
            }
        }
    }
    public function has($path)
    {
        $location = $this->applyPathPrefix($path);
        return file_exists($location);
    }
    public function write($path, $contents, Config $config)
    {
        $location = $this->applyPathPrefix($path);
        $this->ensureDirectory(dirname($location));
        if (($size = file_put_contents($location, $contents, $this->writeFlags)) === false) {
            return false;
        }
        $type = 'file';
        $result = compact('contents', 'type', 'size', 'path');
        if ($visibility = $config->get('visibility')) {
            $result['visibility'] = $visibility;
            $this->setVisibility($path, $visibility);
        }
        return $result;
    }
    public function writeStream($path, $resource, Config $config)
    {
        $location = $this->applyPathPrefix($path);
        $this->ensureDirectory(dirname($location));
        $stream = fopen($location, 'w+b');
        if (!$stream) {
            return false;
        }
        stream_copy_to_stream($resource, $stream);
        if (!fclose($stream)) {
            return false;
        }
        if ($visibility = $config->get('visibility')) {
            $this->setVisibility($path, $visibility);
        }
        $type = 'file';
        return compact('type', 'path', 'visibility');
    }
    public function readStream($path)
    {
        $location = $this->applyPathPrefix($path);
        $stream = fopen($location, 'rb');
        return ['type' => 'file', 'path' => $path, 'stream' => $stream];
    }
    public function updateStream($path, $resource, Config $config)
    {
        return $this->writeStream($path, $resource, $config);
    }
    public function update($path, $contents, Config $config)
    {
        $location = $this->applyPathPrefix($path);
        $mimetype = Util::guessMimeType($path, $contents);
        $size = file_put_contents($location, $contents, $this->writeFlags);
        if ($size === false) {
            return false;
        }
        $type = 'file';
        return compact('type', 'path', 'size', 'contents', 'mimetype');
    }
    public function read($path)
    {
        $location = $this->applyPathPrefix($path);
        $contents = file_get_contents($location);
        if ($contents === false) {
            return false;
        }
        return ['type' => 'file', 'path' => $path, 'contents' => $contents];
    }
    public function rename($path, $newpath)
    {
        $location = $this->applyPathPrefix($path);
        $destination = $this->applyPathPrefix($newpath);
        $parentDirectory = $this->applyPathPrefix(Util::dirname($newpath));
        $this->ensureDirectory($parentDirectory);
        return rename($location, $destination);
    }
    public function copy($path, $newpath)
    {
        $location = $this->applyPathPrefix($path);
        $destination = $this->applyPathPrefix($newpath);
        $this->ensureDirectory(dirname($destination));
        return copy($location, $destination);
    }
    public function delete($path)
    {
        $location = $this->applyPathPrefix($path);
        return unlink($location);
    }
    public function listContents($directory = '', $recursive = false)
    {
        $result = [];
        $location = $this->applyPathPrefix($directory);
        if (!is_dir($location)) {
            return [];
        }
        $iterator = $recursive ? $this->getRecursiveDirectoryIterator($location) : $this->getDirectoryIterator($location);
        foreach ($iterator as $file) {
            $path = $this->getFilePath($file);
            if (preg_match('#(^|/|\\\\)\\.{1,2}$#', $path)) {
                continue;
            }
            $result[] = $this->normalizeFileInfo($file);
        }
        return array_filter($result);
    }
    public function getMetadata($path)
    {
        $location = $this->applyPathPrefix($path);
        $info = new SplFileInfo($location);
        return $this->normalizeFileInfo($info);
    }
    public function getSize($path)
    {
        return $this->getMetadata($path);
    }
    public function getMimetype($path)
    {
        $location = $this->applyPathPrefix($path);
        $finfo = new Finfo(FILEINFO_MIME_TYPE);
        $mimetype = $finfo->file($location);
        if (in_array($mimetype, ['application/octet-stream', 'inode/x-empty'])) {
            $mimetype = Util\MimeType::detectByFilename($location);
        }
        return ['path' => $path, 'type' => 'file', 'mimetype' => $mimetype];
    }
    public function getTimestamp($path)
    {
        return $this->getMetadata($path);
    }
    public function getVisibility($path)
    {
        $location = $this->applyPathPrefix($path);
        clearstatcache(false, $location);
        $permissions = octdec(substr(sprintf('%o', fileperms($location)), -4));
        $visibility = $permissions & 044 ? AdapterInterface::VISIBILITY_PUBLIC : AdapterInterface::VISIBILITY_PRIVATE;
        return compact('path', 'visibility');
    }
    public function setVisibility($path, $visibility)
    {
        $location = $this->applyPathPrefix($path);
        $type = is_dir($location) ? 'dir' : 'file';
        $success = chmod($location, $this->permissionMap[$type][$visibility]);
        if ($success === false) {
            return false;
        }
        return compact('path', 'visibility');
    }
    public function createDir($dirname, Config $config)
    {
        $location = $this->applyPathPrefix($dirname);
        $umask = umask(0);
        $visibility = $config->get('visibility', 'public');
        if (!is_dir($location) && !mkdir($location, $this->permissionMap['dir'][$visibility], true)) {
            $return = false;
        } else {
            $return = ['path' => $dirname, 'type' => 'dir'];
        }
        umask($umask);
        return $return;
    }
    public function deleteDir($dirname)
    {
        $location = $this->applyPathPrefix($dirname);
        if (!is_dir($location)) {
            return false;
        }
        $contents = $this->getRecursiveDirectoryIterator($location, RecursiveIteratorIterator::CHILD_FIRST);
        foreach ($contents as $file) {
            $this->guardAgainstUnreadableFileInfo($file);
            $this->deleteFileInfoObject($file);
        }
        return rmdir($location);
    }
    protected function deleteFileInfoObject(SplFileInfo $file)
    {
        switch ($file->getType()) {
            case 'dir':
                rmdir($file->getRealPath());
                break;
            case 'link':
                unlink($file->getPathname());
                break;
            default:
                unlink($file->getRealPath());
        }
    }
    protected function normalizeFileInfo(SplFileInfo $file)
    {
        if (!$file->isLink()) {
            return $this->mapFileInfo($file);
        }
        if ($this->linkHandling & self::DISALLOW_LINKS) {
            throw NotSupportedException::forLink($file);
        }
    }
    protected function getFilePath(SplFileInfo $file)
    {
        $location = $file->getPathname();
        $path = $this->removePathPrefix($location);
        return trim(str_replace('\\', '/', $path), '/');
    }
    protected function getRecursiveDirectoryIterator($path, $mode = RecursiveIteratorIterator::SELF_FIRST)
    {
        return new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path, FilesystemIterator::SKIP_DOTS), $mode);
    }
    protected function getDirectoryIterator($path)
    {
        $iterator = new DirectoryIterator($path);
        return $iterator;
    }
    protected function mapFileInfo(SplFileInfo $file)
    {
        $normalized = ['type' => $file->getType(), 'path' => $this->getFilePath($file)];
        $normalized['timestamp'] = $file->getMTime();
        if ($normalized['type'] === 'file') {
            $normalized['size'] = $file->getSize();
        }
        return $normalized;
    }
    protected function guardAgainstUnreadableFileInfo(SplFileInfo $file)
    {
        if (!$file->isReadable()) {
            throw UnreadableFileException::forFileInfo($file);
        }
    }
}
}

namespace League\Flysystem {
use InvalidArgumentException;
use League\Flysystem\Adapter\CanOverwriteFiles;
use League\Flysystem\Plugin\PluggableTrait;
use League\Flysystem\Util\ContentListingFormatter;
class Filesystem implements FilesystemInterface
{
    use PluggableTrait;
    use ConfigAwareTrait;
    protected $adapter;
    public function __construct(AdapterInterface $adapter, $config = null)
    {
        $this->adapter = $adapter;
        $this->setConfig($config);
    }
    public function getAdapter()
    {
        return $this->adapter;
    }
    public function has($path)
    {
        $path = Util::normalizePath($path);
        return strlen($path) === 0 ? false : (bool) $this->getAdapter()->has($path);
    }
    public function write($path, $contents, array $config = [])
    {
        $path = Util::normalizePath($path);
        $this->assertAbsent($path);
        $config = $this->prepareConfig($config);
        return (bool) $this->getAdapter()->write($path, $contents, $config);
    }
    public function writeStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $path = Util::normalizePath($path);
        $this->assertAbsent($path);
        $config = $this->prepareConfig($config);
        Util::rewindStream($resource);
        return (bool) $this->getAdapter()->writeStream($path, $resource, $config);
    }
    public function put($path, $contents, array $config = [])
    {
        $path = Util::normalizePath($path);
        $config = $this->prepareConfig($config);
        if (!$this->adapter instanceof CanOverwriteFiles && $this->has($path)) {
            return (bool) $this->getAdapter()->update($path, $contents, $config);
        }
        return (bool) $this->getAdapter()->write($path, $contents, $config);
    }
    public function putStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $path = Util::normalizePath($path);
        $config = $this->prepareConfig($config);
        Util::rewindStream($resource);
        if (!$this->adapter instanceof CanOverwriteFiles && $this->has($path)) {
            return (bool) $this->getAdapter()->updateStream($path, $resource, $config);
        }
        return (bool) $this->getAdapter()->writeStream($path, $resource, $config);
    }
    public function readAndDelete($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        $contents = $this->read($path);
        if ($contents === false) {
            return false;
        }
        $this->delete($path);
        return $contents;
    }
    public function update($path, $contents, array $config = [])
    {
        $path = Util::normalizePath($path);
        $config = $this->prepareConfig($config);
        $this->assertPresent($path);
        return (bool) $this->getAdapter()->update($path, $contents, $config);
    }
    public function updateStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $path = Util::normalizePath($path);
        $config = $this->prepareConfig($config);
        $this->assertPresent($path);
        Util::rewindStream($resource);
        return (bool) $this->getAdapter()->updateStream($path, $resource, $config);
    }
    public function read($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->read($path))) {
            return false;
        }
        return $object['contents'];
    }
    public function readStream($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->readStream($path))) {
            return false;
        }
        return $object['stream'];
    }
    public function rename($path, $newpath)
    {
        $path = Util::normalizePath($path);
        $newpath = Util::normalizePath($newpath);
        $this->assertPresent($path);
        $this->assertAbsent($newpath);
        return (bool) $this->getAdapter()->rename($path, $newpath);
    }
    public function copy($path, $newpath)
    {
        $path = Util::normalizePath($path);
        $newpath = Util::normalizePath($newpath);
        $this->assertPresent($path);
        $this->assertAbsent($newpath);
        return $this->getAdapter()->copy($path, $newpath);
    }
    public function delete($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        return $this->getAdapter()->delete($path);
    }
    public function deleteDir($dirname)
    {
        $dirname = Util::normalizePath($dirname);
        if ($dirname === '') {
            throw new RootViolationException('Root directories can not be deleted.');
        }
        return (bool) $this->getAdapter()->deleteDir($dirname);
    }
    public function createDir($dirname, array $config = [])
    {
        $dirname = Util::normalizePath($dirname);
        $config = $this->prepareConfig($config);
        return (bool) $this->getAdapter()->createDir($dirname, $config);
    }
    public function listContents($directory = '', $recursive = false)
    {
        $directory = Util::normalizePath($directory);
        $contents = $this->getAdapter()->listContents($directory, $recursive);
        return (new ContentListingFormatter($directory, $recursive))->formatListing($contents);
    }
    public function getMimetype($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->getMimetype($path)) || !array_key_exists('mimetype', $object)) {
            return false;
        }
        return $object['mimetype'];
    }
    public function getTimestamp($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->getTimestamp($path)) || !array_key_exists('timestamp', $object)) {
            return false;
        }
        return $object['timestamp'];
    }
    public function getVisibility($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->getVisibility($path)) || !array_key_exists('visibility', $object)) {
            return false;
        }
        return $object['visibility'];
    }
    public function getSize($path)
    {
        $path = Util::normalizePath($path);
        if (!($object = $this->getAdapter()->getSize($path)) || !array_key_exists('size', $object)) {
            return false;
        }
        return (int) $object['size'];
    }
    public function setVisibility($path, $visibility)
    {
        $path = Util::normalizePath($path);
        return (bool) $this->getAdapter()->setVisibility($path, $visibility);
    }
    public function getMetadata($path)
    {
        $path = Util::normalizePath($path);
        $this->assertPresent($path);
        return $this->getAdapter()->getMetadata($path);
    }
    public function get($path, Handler $handler = null)
    {
        $path = Util::normalizePath($path);
        if (!$handler) {
            $metadata = $this->getMetadata($path);
            $handler = $metadata['type'] === 'file' ? new File($this, $path) : new Directory($this, $path);
        }
        $handler->setPath($path);
        $handler->setFilesystem($this);
        return $handler;
    }
    public function assertPresent($path)
    {
        if ($this->config->get('disable_asserts', false) === false && !$this->has($path)) {
            throw new FileNotFoundException($path);
        }
    }
    public function assertAbsent($path)
    {
        if ($this->config->get('disable_asserts', false) === false && $this->has($path)) {
            throw new FileExistsException($path);
        }
    }
}
}

namespace League\Flysystem {
trait ConfigAwareTrait
{
    protected $config;
    protected function setConfig($config)
    {
        $this->config = $config ? Util::ensureConfig($config) : new Config();
    }
    public function getConfig()
    {
        return $this->config;
    }
    protected function prepareConfig(array $config)
    {
        $config = new Config($config);
        $config->setFallback($this->getConfig());
        return $config;
    }
}
}

namespace Royalcms\Component\Container {
use Closure;
use ArrayAccess;
use ReflectionClass;
use ReflectionMethod;
use ReflectionFunction;
use ReflectionParameter;
use InvalidArgumentException;
use Royalcms\Component\Contracts\Container\Container as ContainerContract;
use Royalcms\Component\Contracts\Container\BindingResolutionException as BindingResolutionContractException;
class Container implements ArrayAccess, ContainerContract
{
    protected static $instance;
    protected $resolved = [];
    protected $bindings = [];
    protected $instances = [];
    protected $aliases = [];
    protected $extenders = [];
    protected $tags = [];
    protected $buildStack = [];
    public $contextual = [];
    protected $reboundCallbacks = [];
    protected $globalResolvingCallbacks = [];
    protected $globalAfterResolvingCallbacks = [];
    protected $resolvingCallbacks = [];
    protected $afterResolvingCallbacks = [];
    public function when($concrete)
    {
        return new ContextualBindingBuilder($this, $concrete);
    }
    public function bound($abstract)
    {
        return isset($this->bindings[$abstract]) || isset($this->instances[$abstract]) || $this->isAlias($abstract);
    }
    public function resolved($abstract)
    {
        if ($this->isAlias($abstract)) {
            $abstract = $this->getAlias($abstract);
        }
        return isset($this->resolved[$abstract]) || isset($this->instances[$abstract]);
    }
    public function isAlias($name)
    {
        return isset($this->aliases[$name]);
    }
    public function bind($abstract, $concrete = null, $shared = false)
    {
        if (is_array($abstract)) {
            list($abstract, $alias) = $this->extractAlias($abstract);
            $this->alias($abstract, $alias);
        }
        $this->dropStaleInstances($abstract);
        if (is_null($concrete)) {
            $concrete = $abstract;
        }
        if (!$concrete instanceof Closure) {
            $concrete = $this->getClosure($abstract, $concrete);
        }
        $this->bindings[$abstract] = compact('concrete', 'shared');
        if ($this->resolved($abstract)) {
            $this->rebound($abstract);
        }
    }
    protected function getClosure($abstract, $concrete)
    {
        return function ($c, $parameters = []) use($abstract, $concrete) {
            $method = $abstract == $concrete ? 'build' : 'make';
            return $c->{$method}($concrete, $parameters);
        };
    }
    public function addContextualBinding($concrete, $abstract, $implementation)
    {
        $this->contextual[$concrete][$abstract] = $implementation;
    }
    public function bindIf($abstract, $concrete = null, $shared = false)
    {
        if (!$this->bound($abstract)) {
            $this->bind($abstract, $concrete, $shared);
        }
    }
    public function singleton($abstract, $concrete = null)
    {
        $this->bind($abstract, $concrete, true);
    }
    public function share(Closure $closure)
    {
        return function ($container) use($closure) {
            static $object;
            if (is_null($object)) {
                $object = $closure($container);
            }
            return $object;
        };
    }
    public function bindShared($abstract, Closure $closure)
    {
        $this->bind($abstract, $this->share($closure), true);
    }
    public function extend($abstract, Closure $closure)
    {
        if (isset($this->instances[$abstract])) {
            $this->instances[$abstract] = $closure($this->instances[$abstract], $this);
            $this->rebound($abstract);
        } else {
            $this->extenders[$abstract][] = $closure;
        }
    }
    public function instance($abstract, $instance)
    {
        if (is_array($abstract)) {
            list($abstract, $alias) = $this->extractAlias($abstract);
            $this->alias($abstract, $alias);
        }
        unset($this->aliases[$abstract]);
        $bound = $this->bound($abstract);
        $this->instances[$abstract] = $instance;
        if ($bound) {
            $this->rebound($abstract);
        }
    }
    public function tag($abstracts, $tags)
    {
        $tags = is_array($tags) ? $tags : array_slice(func_get_args(), 1);
        foreach ($tags as $tag) {
            if (!isset($this->tags[$tag])) {
                $this->tags[$tag] = [];
            }
            foreach ((array) $abstracts as $abstract) {
                $this->tags[$tag][] = $abstract;
            }
        }
    }
    public function tagged($tag)
    {
        $results = [];
        if (isset($this->tags[$tag])) {
            foreach ($this->tags[$tag] as $abstract) {
                $results[] = $this->make($abstract);
            }
        }
        return $results;
    }
    public function alias($abstract, $alias)
    {
        $this->aliases[$alias] = $abstract;
    }
    protected function extractAlias(array $definition)
    {
        return [key($definition), current($definition)];
    }
    public function rebinding($abstract, Closure $callback)
    {
        $this->reboundCallbacks[$abstract][] = $callback;
        if ($this->bound($abstract)) {
            return $this->make($abstract);
        }
    }
    public function refresh($abstract, $target, $method)
    {
        return $this->rebinding($abstract, function ($app, $instance) use($target, $method) {
            $target->{$method}($instance);
        });
    }
    protected function rebound($abstract)
    {
        $instance = $this->make($abstract);
        foreach ($this->getReboundCallbacks($abstract) as $callback) {
            call_user_func($callback, $this, $instance);
        }
    }
    protected function getReboundCallbacks($abstract)
    {
        if (isset($this->reboundCallbacks[$abstract])) {
            return $this->reboundCallbacks[$abstract];
        }
        return [];
    }
    public function wrap(Closure $callback, array $parameters = [])
    {
        return function () use($callback, $parameters) {
            return $this->call($callback, $parameters);
        };
    }
    public function call($callback, array $parameters = [], $defaultMethod = null)
    {
        if ($this->isCallableWithAtSign($callback) || $defaultMethod) {
            return $this->callClass($callback, $parameters, $defaultMethod);
        }
        $dependencies = $this->getMethodDependencies($callback, $parameters);
        return call_user_func_array($callback, $dependencies);
    }
    protected function isCallableWithAtSign($callback)
    {
        if (!is_string($callback)) {
            return false;
        }
        return strpos($callback, '@') !== false;
    }
    protected function getMethodDependencies($callback, array $parameters = [])
    {
        $dependencies = [];
        foreach ($this->getCallReflector($callback)->getParameters() as $key => $parameter) {
            $this->addDependencyForCallParameter($parameter, $parameters, $dependencies);
        }
        return array_merge($dependencies, $parameters);
    }
    protected function getCallReflector($callback)
    {
        if (is_string($callback) && strpos($callback, '::') !== false) {
            $callback = explode('::', $callback);
        }
        if (is_array($callback)) {
            return new ReflectionMethod($callback[0], $callback[1]);
        }
        return new ReflectionFunction($callback);
    }
    protected function addDependencyForCallParameter(ReflectionParameter $parameter, array &$parameters, &$dependencies)
    {
        if (array_key_exists($parameter->name, $parameters)) {
            $dependencies[] = $parameters[$parameter->name];
            unset($parameters[$parameter->name]);
        } elseif ($parameter->getClass()) {
            $dependencies[] = $this->make($parameter->getClass()->name);
        } elseif ($parameter->isDefaultValueAvailable()) {
            $dependencies[] = $parameter->getDefaultValue();
        }
    }
    protected function callClass($target, array $parameters = [], $defaultMethod = null)
    {
        $segments = explode('@', $target);
        $method = count($segments) == 2 ? $segments[1] : $defaultMethod;
        if (is_null($method)) {
            throw new InvalidArgumentException('Method not provided.');
        }
        return $this->call([$this->make($segments[0]), $method], $parameters);
    }
    public function make($abstract, array $parameters = [])
    {
        $abstract = $this->getAlias($abstract);
        if (isset($this->instances[$abstract])) {
            return $this->instances[$abstract];
        }
        $concrete = $this->getConcrete($abstract);
        if ($this->isBuildable($concrete, $abstract)) {
            $object = $this->build($concrete, $parameters);
        } else {
            $object = $this->make($concrete, $parameters);
        }
        foreach ($this->getExtenders($abstract) as $extender) {
            $object = $extender($object, $this);
        }
        if ($this->isShared($abstract)) {
            $this->instances[$abstract] = $object;
        }
        $this->fireResolvingCallbacks($abstract, $object);
        $this->resolved[$abstract] = true;
        return $object;
    }
    protected function getConcrete($abstract)
    {
        if (!is_null($concrete = $this->getContextualConcrete($abstract))) {
            return $concrete;
        }
        if (!isset($this->bindings[$abstract])) {
            if ($this->missingLeadingSlash($abstract) && isset($this->bindings['\\' . $abstract])) {
                $abstract = '\\' . $abstract;
            }
            return $abstract;
        }
        return $this->bindings[$abstract]['concrete'];
    }
    protected function getContextualConcrete($abstract)
    {
        if (isset($this->contextual[end($this->buildStack)][$abstract])) {
            return $this->contextual[end($this->buildStack)][$abstract];
        }
    }
    protected function missingLeadingSlash($abstract)
    {
        return is_string($abstract) && strpos($abstract, '\\') !== 0;
    }
    protected function getExtenders($abstract)
    {
        if (isset($this->extenders[$abstract])) {
            return $this->extenders[$abstract];
        }
        return [];
    }
    public function build($concrete, array $parameters = [])
    {
        if ($concrete instanceof Closure) {
            return $concrete($this, $parameters);
        }
        $reflector = new ReflectionClass($concrete);
        if (!$reflector->isInstantiable()) {
            $message = "Target [{$concrete}] is not instantiable.";
            throw new BindingResolutionContractException($message);
        }
        $this->buildStack[] = $concrete;
        $constructor = $reflector->getConstructor();
        if (is_null($constructor)) {
            array_pop($this->buildStack);
            return new $concrete();
        }
        $dependencies = $constructor->getParameters();
        $parameters = $this->keyParametersByArgument($dependencies, $parameters);
        $instances = $this->getDependencies($dependencies, $parameters);
        array_pop($this->buildStack);
        return $reflector->newInstanceArgs($instances);
    }
    protected function getDependencies(array $parameters, array $primitives = [])
    {
        $dependencies = [];
        foreach ($parameters as $parameter) {
            $dependency = $parameter->getClass();
            if (array_key_exists($parameter->name, $primitives)) {
                $dependencies[] = $primitives[$parameter->name];
            } elseif (is_null($dependency)) {
                $dependencies[] = $this->resolveNonClass($parameter);
            } else {
                $dependencies[] = $this->resolveClass($parameter);
            }
        }
        return (array) $dependencies;
    }
    protected function resolveNonClass(ReflectionParameter $parameter)
    {
        if ($parameter->isDefaultValueAvailable()) {
            return $parameter->getDefaultValue();
        }
        $message = "Unresolvable dependency resolving [{$parameter}] in class {$parameter->getDeclaringClass()->getName()}";
        throw new BindingResolutionContractException($message);
    }
    protected function resolveClass(ReflectionParameter $parameter)
    {
        try {
            return $this->make($parameter->getClass()->name);
        } catch (BindingResolutionContractException $e) {
            if ($parameter->isOptional()) {
                return $parameter->getDefaultValue();
            }
            throw $e;
        }
    }
    protected function keyParametersByArgument(array $dependencies, array $parameters)
    {
        foreach ($parameters as $key => $value) {
            if (is_numeric($key)) {
                unset($parameters[$key]);
                $parameters[$dependencies[$key]->name] = $value;
            }
        }
        return $parameters;
    }
    public function resolving($abstract, Closure $callback = null)
    {
        if ($callback === null && $abstract instanceof Closure) {
            $this->resolvingCallback($abstract);
        } else {
            $this->resolvingCallbacks[$abstract][] = $callback;
        }
    }
    public function afterResolving($abstract, Closure $callback = null)
    {
        if ($abstract instanceof Closure && $callback === null) {
            $this->afterResolvingCallback($abstract);
        } else {
            $this->afterResolvingCallbacks[$abstract][] = $callback;
        }
    }
    protected function resolvingCallback(Closure $callback)
    {
        $abstract = $this->getFunctionHint($callback);
        if ($abstract) {
            $this->resolvingCallbacks[$abstract][] = $callback;
        } else {
            $this->globalResolvingCallbacks[] = $callback;
        }
    }
    protected function afterResolvingCallback(Closure $callback)
    {
        $abstract = $this->getFunctionHint($callback);
        if ($abstract) {
            $this->afterResolvingCallbacks[$abstract][] = $callback;
        } else {
            $this->globalAfterResolvingCallbacks[] = $callback;
        }
    }
    protected function getFunctionHint(Closure $callback)
    {
        $function = new ReflectionFunction($callback);
        if ($function->getNumberOfParameters() == 0) {
            return;
        }
        $expected = $function->getParameters()[0];
        if (!$expected->getClass()) {
            return;
        }
        return $expected->getClass()->name;
    }
    protected function fireResolvingCallbacks($abstract, $object)
    {
        $this->fireCallbackArray($object, $this->globalResolvingCallbacks);
        $this->fireCallbackArray($object, $this->getCallbacksForType($abstract, $object, $this->resolvingCallbacks));
        $this->fireCallbackArray($object, $this->globalAfterResolvingCallbacks);
        $this->fireCallbackArray($object, $this->getCallbacksForType($abstract, $object, $this->afterResolvingCallbacks));
    }
    protected function getCallbacksForType($abstract, $object, array $callbacksPerType)
    {
        $results = [];
        foreach ($callbacksPerType as $type => $callbacks) {
            if ($type === $abstract || $object instanceof $type) {
                $results = array_merge($results, $callbacks);
            }
        }
        return $results;
    }
    protected function fireCallbackArray($object, array $callbacks)
    {
        foreach ($callbacks as $callback) {
            $callback($object, $this);
        }
    }
    public function isShared($abstract)
    {
        if (isset($this->bindings[$abstract]['shared'])) {
            $shared = $this->bindings[$abstract]['shared'];
        } else {
            $shared = false;
        }
        return isset($this->instances[$abstract]) || $shared === true;
    }
    protected function isBuildable($concrete, $abstract)
    {
        return $concrete === $abstract || $concrete instanceof Closure;
    }
    protected function getAlias($abstract)
    {
        if (!isset($this->aliases[$abstract])) {
            return $abstract;
        }
        return $this->getAlias($this->aliases[$abstract]);
    }
    public function getBindings()
    {
        return $this->bindings;
    }
    protected function dropStaleInstances($abstract)
    {
        unset($this->instances[$abstract], $this->aliases[$abstract]);
    }
    public function forgetInstance($abstract)
    {
        unset($this->instances[$abstract]);
    }
    public function forgetInstances()
    {
        $this->instances = [];
    }
    public function flush()
    {
        $this->aliases = [];
        $this->resolved = [];
        $this->bindings = [];
        $this->instances = [];
    }
    public static function getInstance()
    {
        return static::$instance;
    }
    public static function setInstance(ContainerContract $container)
    {
        static::$instance = $container;
    }
    public function offsetExists($key)
    {
        return $this->bound($key);
    }
    public function offsetGet($key)
    {
        return $this->make($key);
    }
    public function offsetSet($key, $value)
    {
        if (!$value instanceof Closure) {
            $value = function () use($value) {
                return $value;
            };
        }
        $this->bind($key, $value);
    }
    public function offsetUnset($key)
    {
        unset($this->bindings[$key], $this->instances[$key], $this->resolved[$key]);
    }
    public function __get($key)
    {
        return $this[$key];
    }
    public function __set($key, $value)
    {
        $this[$key] = $value;
    }
}
}

namespace Royalcms\Component\Contracts\Container {
use Closure;
interface Container
{
    public function bound($abstract);
    public function alias($abstract, $alias);
    public function tag($abstracts, $tags);
    public function tagged($tag);
    public function bind($abstract, $concrete = null, $shared = false);
    public function bindIf($abstract, $concrete = null, $shared = false);
    public function singleton($abstract, $concrete = null);
    public function extend($abstract, Closure $closure);
    public function instance($abstract, $instance);
    public function when($concrete);
    public function make($abstract, array $parameters = []);
    public function call($callback, array $parameters = [], $defaultMethod = null);
    public function resolved($abstract);
    public function resolving($abstract, Closure $callback = null);
    public function afterResolving($abstract, Closure $callback = null);
}
}

namespace Royalcms\Component\Contracts\Container {
interface ContextualBindingBuilder
{
    public function needs($abstract);
    public function give($implementation);
}
}

namespace Royalcms\Component\Contracts\Foundation {
use Royalcms\Component\Contracts\Container\Container;
interface Royalcms extends Container
{
    public function version();
    public function basePath();
    public function environment();
    public function isDownForMaintenance();
    public function registerConfiguredProviders();
    public function register($provider, $options = [], $force = false);
    public function registerDeferredProvider($provider, $service = null);
    public function boot();
    public function booting($callback);
    public function booted($callback);
    public function getCachedCompilePath();
    public function getCachedServicesPath();
}
}

namespace Royalcms\Component\Contracts\Foundation {
interface Application extends Royalcms
{
}
}

namespace Royalcms\Component\Contracts\Bus {
use Closure;
use ArrayAccess;
interface Dispatcher
{
    public function dispatchFromArray($command, array $array);
    public function dispatchFrom($command, ArrayAccess $source, array $extras = []);
    public function dispatch($command, Closure $afterResolving = null);
    public function dispatchNow($command, Closure $afterResolving = null);
    public function pipeThrough(array $pipes);
}
}

namespace Royalcms\Component\Contracts\Bus {
interface QueueingDispatcher extends Dispatcher
{
    public function dispatchToQueue($command);
}
}

namespace Royalcms\Component\Contracts\Bus {
use Closure;
interface HandlerResolver
{
    public function resolveHandler($command);
    public function getHandlerClass($command);
    public function getHandlerMethod($command);
    public function maps(array $commands);
    public function mapUsing(Closure $mapper);
}
}

namespace Royalcms\Component\Contracts\Pipeline {
use Closure;
interface Pipeline
{
    public function send($traveler);
    public function through($stops);
    public function via($method);
    public function then(Closure $destination);
}
}

namespace Royalcms\Component\Contracts\Pipeline {
interface Hub
{
    public function pipe($object, $pipeline = null);
}
}

namespace Royalcms\Component\Contracts\Logging {
interface Log
{
    public function alert($message, array $context = []);
    public function critical($message, array $context = []);
    public function error($message, array $context = []);
    public function warning($message, array $context = []);
    public function notice($message, array $context = []);
    public function info($message, array $context = []);
    public function debug($message, array $context = []);
    public function log($level, $message, array $context = []);
    public function useFiles($path, $level = 'debug');
    public function useDailyFiles($path, $days = 0, $level = 'debug');
}
}

namespace Royalcms\Component\Contracts\Debug {
use Exception;
interface ExceptionHandler
{
    public function report(Exception $e);
    public function render($request, Exception $e);
    public function renderForConsole($output, Exception $e);
}
}

namespace Royalcms\Component\Contracts\Config {
interface Repository
{
    public function has($key);
    public function get($key, $default = null);
    public function all();
    public function set($key, $value = null);
    public function prepend($key, $value);
    public function push($key, $value);
}
}

namespace Royalcms\Component\Contracts\Events {
interface Dispatcher
{
    public function listen($events, $listener, $priority = 0);
    public function hasListeners($eventName);
    public function push($event, $payload = []);
    public function subscribe($subscriber);
    public function until($event, $payload = []);
    public function flush($event);
    public function fire($event, $payload = [], $halt = false);
    public function firing();
    public function forget($event);
    public function forgetPushed();
}
}

namespace Royalcms\Component\Contracts\Support {
interface Renderable
{
    public function render();
}
}

namespace Royalcms\Component\Contracts\Support {
interface Arrayable
{
    public function toArray();
}
}

namespace Royalcms\Component\Contracts\Support {
interface Jsonable
{
    public function toJson($options = 0);
}
}

namespace Royalcms\Component\Contracts\Support {
interface MessageProvider
{
    public function getMessageBag();
}
}

namespace Royalcms\Component\Contracts\Support {
interface MessageBag
{
    public function keys();
    public function add($key, $message);
    public function merge($messages);
    public function has($key = null);
    public function first($key = null, $format = null);
    public function get($key, $format = null);
    public function all($format = null);
    public function getFormat();
    public function setFormat($format = ':message');
    public function isEmpty();
    public function count();
    public function toArray();
}
}

namespace Royalcms\Component\Contracts\Support {
interface Htmlable
{
    public function toHtml();
}
}

namespace Royalcms\Component\Contracts\Cookie {
interface Factory
{
    public function make($name, $value, $minutes = 0, $path = null, $domain = null, $secure = false, $httpOnly = true);
    public function forever($name, $value, $path = null, $domain = null, $secure = false, $httpOnly = true);
    public function forget($name, $path = null, $domain = null);
}
}

namespace Royalcms\Component\Contracts\Cookie {
interface QueueingFactory extends Factory
{
    public function queue();
    public function unqueue($name);
    public function getQueuedCookies();
}
}

namespace Royalcms\Component\Contracts\Encryption {
interface Encrypter
{
    public function encrypt($value);
    public function decrypt($payload);
}
}

namespace Royalcms\Component\Contracts\Queue {
interface QueueableEntity
{
    public function getQueueableId();
}
}

namespace Royalcms\Component\Contracts\Routing {
use Closure;
interface Registrar
{
    public function get($uri, $action);
    public function post($uri, $action);
    public function put($uri, $action);
    public function delete($uri, $action);
    public function patch($uri, $action);
    public function options($uri, $action);
    public function match($methods, $uri, $action);
    public function resource($name, $controller, array $options = []);
    public function group(array $attributes, Closure $callback);
}
}

namespace Royalcms\Component\Contracts\Routing {
interface ResponseFactory
{
    public function make($content = '', $status = 200, array $headers = []);
    public function view($view, $data = [], $status = 200, array $headers = []);
    public function json($data = [], $status = 200, array $headers = [], $options = 0);
    public function jsonp($callback, $data = [], $status = 200, array $headers = [], $options = 0);
    public function stream($callback, $status = 200, array $headers = []);
    public function download($file, $name = null, array $headers = [], $disposition = 'attachment');
    public function redirectTo($path, $status = 302, $headers = [], $secure = null);
    public function redirectToRoute($route, $parameters = [], $status = 302, $headers = []);
    public function redirectToAction($action, $parameters = [], $status = 302, $headers = []);
    public function redirectGuest($path, $status = 302, $headers = [], $secure = null);
    public function redirectToIntended($default = '/', $status = 302, $headers = [], $secure = null);
}
}

namespace Royalcms\Component\Contracts\Routing {
interface UrlGenerator
{
    public function to($path, $extra = [], $secure = null);
    public function secure($path, $parameters = []);
    public function asset($path, $secure = null);
    public function route($name, $parameters = [], $absolute = true);
    public function action($action, $parameters = [], $absolute = true);
    public function setRootControllerNamespace($rootNamespace);
}
}

namespace Royalcms\Component\Contracts\Routing {
interface UrlRoutable
{
    public function getRouteKey();
    public function getRouteKeyName();
}
}

namespace Royalcms\Component\Contracts\Routing {
interface TerminableMiddleware extends Middleware
{
    public function terminate($request, $response);
}
}

namespace Royalcms\Component\Contracts\Routing {
use Closure;
interface Middleware
{
    public function handle($request, Closure $next);
}
}

namespace Royalcms\Component\Contracts\Validation {
interface ValidatesWhenResolved
{
    public function validate();
}
}

namespace Royalcms\Component\Contracts\Validation {
interface Factory
{
    public function make(array $data, array $rules, array $messages = [], array $customAttributes = []);
    public function extend($rule, $extension, $message = null);
    public function extendImplicit($rule, $extension, $message = null);
    public function replacer($rule, $replacer);
}
}

namespace Royalcms\Component\Contracts\Validation {
use Royalcms\Component\Contracts\Support\MessageProvider;
interface Validator extends MessageProvider
{
    public function fails();
    public function failed();
    public function sometimes($attribute, $rules, callable $callback);
    public function after($callback);
}
}

namespace Royalcms\Component\Contracts\View {
interface Factory
{
    public function exists($view);
    public function file($path, $data = [], $mergeData = []);
    public function make($view, $data = [], $mergeData = []);
    public function share($key, $value = null);
    public function composer($views, $callback, $priority = null);
    public function creator($views, $callback);
    public function addNamespace($namespace, $hints);
    public function replaceNamespace($namespace, $hints);
}
}

namespace Royalcms\Component\Contracts\View {
use Royalcms\Component\Contracts\Support\Renderable;
interface View extends Renderable
{
    public function name();
    public function with($key, $value = null);
}
}

namespace Royalcms\Component\Contracts\View {
interface Engine
{
    public function get($path, array $data = []);
}
}

namespace Royalcms\Component\Contracts\Http {
interface Kernel
{
    public function bootstrap();
    public function handle($request);
    public function terminate($request, $response);
    public function getRoyalcms();
    public function getApplication();
}
}

namespace Royalcms\Component\Contracts\Auth {
interface Guard
{
    public function check();
    public function guest();
    public function user();
    public function once(array $credentials = []);
    public function attempt(array $credentials = [], $remember = false, $login = true);
    public function basic($field = 'email');
    public function onceBasic($field = 'email');
    public function validate(array $credentials = []);
    public function login(Authenticatable $user, $remember = false);
    public function loginUsingId($id, $remember = false);
    public function viaRemember();
    public function logout();
}
}

namespace Royalcms\Component\Contracts\Auth\Access {
interface Gate
{
    public function has($ability);
    public function define($ability, $callback);
    public function policy($class, $policy);
    public function check($ability, $arguments = []);
}
}

namespace Royalcms\Component\Contracts\Auth\Access {
interface Authorizable
{
    public function can($ability, $arguments = []);
}
}

namespace Royalcms\Component\Contracts\Auth {
interface UserProvider
{
    public function retrieveById($identifier);
    public function retrieveByToken($identifier, $token);
    public function updateRememberToken(Authenticatable $user, $token);
    public function retrieveByCredentials(array $credentials);
    public function validateCredentials(Authenticatable $user, array $credentials);
}
}

namespace Royalcms\Component\Contracts\Hashing {
interface Hasher
{
    public function make($value, array $options = []);
    public function check($value, $hashedValue, array $options = []);
    public function needsRehash($hashedValue, array $options = []);
}
}

namespace Royalcms\Component\Contracts\Pagination {
interface Paginator
{
    public function url($page);
    public function appends($key, $value = null);
    public function fragment($fragment = null);
    public function nextPageUrl();
    public function previousPageUrl();
    public function items();
    public function firstItem();
    public function lastItem();
    public function perPage();
    public function currentPage();
    public function hasPages();
    public function hasMorePages();
    public function isEmpty();
    public function render(Presenter $presenter = null);
}
}

namespace Royalcms\Component\Contracts\Cache {
interface Factory
{
    public function store($name = null);
}
}

namespace Royalcms\Component\Contracts\Cache {
interface Store
{
    public function get($key);
    public function put($key, $value, $minutes);
    public function increment($key, $value = 1);
    public function decrement($key, $value = 1);
    public function forever($key, $value);
    public function forget($key);
    public function flush();
    public function getPrefix();
}
}

namespace Royalcms\Component\Contracts\Cache {
use Closure;
interface Repository
{
    public function has($key);
    public function get($key, $default = null);
    public function pull($key, $default = null);
    public function put($key, $value, $minutes);
    public function add($key, $value, $minutes);
    public function forever($key, $value);
    public function remember($key, $minutes, Closure $callback);
    public function sear($key, Closure $callback);
    public function rememberForever($key, Closure $callback);
    public function forget($key);
}
}

namespace Royalcms\Component\Contracts\Filesystem {
interface Cloud extends Filesystem
{
}
}

namespace Royalcms\Component\Contracts\Filesystem {
interface Factory
{
    public function disk($name = null);
}
}

namespace Royalcms\Component\Contracts\Filesystem {
interface Filesystem
{
    const VISIBILITY_PUBLIC = 'public';
    const VISIBILITY_PRIVATE = 'private';
    public function exists($path);
    public function get($path);
    public function put($path, $contents, $visibility = null);
    public function getVisibility($path);
    public function setVisibility($path, $visibility);
    public function prepend($path, $data);
    public function append($path, $data);
    public function delete($paths);
    public function copy($from, $to);
    public function move($from, $to);
    public function size($path);
    public function lastModified($path);
    public function files($directory = null, $recursive = false);
    public function allFiles($directory = null);
    public function directories($directory = null, $recursive = false);
    public function allDirectories($directory = null);
    public function makeDirectory($path);
    public function deleteDirectory($directory);
}
}

namespace Royalcms\Component\Contracts\Filesystem {
use Exception;
class FileNotFoundException extends Exception
{
}
}

namespace Royalcms\Component\Http {
use Closure;
use ArrayAccess;
use SplFileInfo;
use RuntimeException;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Symfony\Component\HttpFoundation\ParameterBag;
use Symfony\Component\HttpFoundation\Request as SymfonyRequest;
class Request extends SymfonyRequest implements ArrayAccess
{
    protected $json;
    protected $userResolver;
    protected $routeResolver;
    public static function capture()
    {
        static::enableHttpMethodParameterOverride();
        return static::createFromBase(SymfonyRequest::createFromGlobals());
    }
    public function instance()
    {
        return $this;
    }
    public function method()
    {
        return $this->getMethod();
    }
    public function root()
    {
        return rtrim($this->getSchemeAndHttpHost() . $this->getBaseUrl(), '/');
    }
    public function url()
    {
        return rtrim(preg_replace('/\\?.*/', '', $this->getUri()), '/');
    }
    public function fullUrl()
    {
        $query = $this->getQueryString();
        return $query ? $this->url() . '?' . $query : $this->url();
    }
    public function path()
    {
        $pattern = trim($this->getPathInfo(), '/');
        return $pattern == '' ? '/' : $pattern;
    }
    public function decodedPath()
    {
        return rawurldecode($this->path());
    }
    public function segment($index, $default = null)
    {
        return Arr::get($this->segments(), $index - 1, $default);
    }
    public function segments()
    {
        $segments = explode('/', $this->path());
        return array_values(array_filter($segments, function ($v) {
            return $v != '';
        }));
    }
    public function is()
    {
        foreach (func_get_args() as $pattern) {
            if (Str::is($pattern, urldecode($this->path()))) {
                return true;
            }
        }
        return false;
    }
    public function ajax()
    {
        return $this->isXmlHttpRequest();
    }
    public function pjax()
    {
        return $this->headers->get('X-PJAX') == true;
    }
    public function secure()
    {
        return $this->isSecure();
    }
    public function ip()
    {
        return $this->getClientIp();
    }
    public function ips()
    {
        return $this->getClientIps();
    }
    public function exists($key)
    {
        $keys = is_array($key) ? $key : func_get_args();
        $input = $this->all();
        foreach ($keys as $value) {
            if (!array_key_exists($value, $input)) {
                return false;
            }
        }
        return true;
    }
    public function has($key)
    {
        $keys = is_array($key) ? $key : func_get_args();
        foreach ($keys as $value) {
            if ($this->isEmptyString($value)) {
                return false;
            }
        }
        return true;
    }
    protected function isEmptyString($key)
    {
        $value = $this->input($key);
        $boolOrArray = is_bool($value) || is_array($value);
        return !$boolOrArray && trim((string) $value) === '';
    }
    public function all()
    {
        return array_replace_recursive($this->input(), $this->files->all());
    }
    public function input($key = null, $default = null)
    {
        $input = $this->getInputSource()->all() + $this->query->all();
        return Arr::get($input, $key, $default);
    }
    public function only($keys)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        $results = [];
        $input = $this->all();
        foreach ($keys as $key) {
            Arr::set($results, $key, Arr::get($input, $key));
        }
        return $results;
    }
    public function except($keys)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        $results = $this->all();
        Arr::forget($results, $keys);
        return $results;
    }
    public function query($key = null, $default = null)
    {
        return $this->retrieveItem('query', $key, $default);
    }
    public function hasCookie($key)
    {
        return !is_null($this->cookie($key));
    }
    public function cookie($key = null, $default = null)
    {
        return $this->retrieveItem('cookies', $key, $default);
    }
    public function file($key = null, $default = null)
    {
        return Arr::get($this->files->all(), $key, $default);
    }
    public function hasFile($key)
    {
        if (!is_array($files = $this->file($key))) {
            $files = [$files];
        }
        foreach ($files as $file) {
            if ($this->isValidFile($file)) {
                return true;
            }
        }
        return false;
    }
    protected function isValidFile($file)
    {
        return $file instanceof SplFileInfo && $file->getPath() != '';
    }
    public function header($key = null, $default = null)
    {
        return $this->retrieveItem('headers', $key, $default);
    }
    public function server($key = null, $default = null)
    {
        return $this->retrieveItem('server', $key, $default);
    }
    public function old($key = null, $default = null)
    {
        return $this->session()->getOldInput($key, $default);
    }
    public function flash($filter = null, $keys = [])
    {
        $flash = !is_null($filter) ? $this->{$filter}($keys) : $this->input();
        $this->session()->flashInput($flash);
    }
    public function flashOnly($keys)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        return $this->flash('only', $keys);
    }
    public function flashExcept($keys)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        return $this->flash('except', $keys);
    }
    public function flush()
    {
        $this->session()->flashInput([]);
    }
    protected function retrieveItem($source, $key, $default)
    {
        if (is_null($key)) {
            return $this->{$source}->all();
        }
        return $this->{$source}->get($key, $default, true);
    }
    public function merge(array $input)
    {
        $this->getInputSource()->add($input);
    }
    public function replace(array $input)
    {
        $this->getInputSource()->replace($input);
    }
    public function json($key = null, $default = null)
    {
        if (!isset($this->json)) {
            $this->json = new ParameterBag((array) json_decode($this->getContent(), true));
        }
        if (is_null($key)) {
            return $this->json;
        }
        return Arr::get($this->json->all(), $key, $default);
    }
    protected function getInputSource()
    {
        if ($this->isJson()) {
            return $this->json();
        }
        return $this->getMethod() == 'GET' ? $this->query : $this->request;
    }
    public static function matchesType($actual, $type)
    {
        if ($actual === $type) {
            return true;
        }
        $split = explode('/', $actual);
        return isset($split[1]) && preg_match('#' . preg_quote($split[0], '#') . '/.+\\+' . preg_quote($split[1], '#') . '#', $type);
    }
    public function isJson()
    {
        return Str::contains($this->header('CONTENT_TYPE'), ['/json', '+json']);
    }
    public function wantsJson()
    {
        $acceptable = $this->getAcceptableContentTypes();
        return isset($acceptable[0]) && Str::contains($acceptable[0], ['/json', '+json']);
    }
    public function accepts($contentTypes)
    {
        $accepts = $this->getAcceptableContentTypes();
        if (count($accepts) === 0) {
            return true;
        }
        $types = (array) $contentTypes;
        foreach ($accepts as $accept) {
            if ($accept === '*/*' || $accept === '*') {
                return true;
            }
            foreach ($types as $type) {
                if ($this->matchesType($accept, $type) || $accept === strtok($type, '/') . '/*') {
                    return true;
                }
            }
        }
        return false;
    }
    public function prefers($contentTypes)
    {
        $accepts = $this->getAcceptableContentTypes();
        $contentTypes = (array) $contentTypes;
        foreach ($accepts as $accept) {
            if (in_array($accept, ['*/*', '*'])) {
                return $contentTypes[0];
            }
            foreach ($contentTypes as $contentType) {
                $type = $contentType;
                if (!is_null($mimeType = $this->getMimeType($contentType))) {
                    $type = $mimeType;
                }
                if ($this->matchesType($type, $accept) || $accept === strtok($type, '/') . '/*') {
                    return $contentType;
                }
            }
        }
    }
    public function acceptsJson()
    {
        return $this->accepts('application/json');
    }
    public function acceptsHtml()
    {
        return $this->accepts('text/html');
    }
    public function format($default = 'html')
    {
        foreach ($this->getAcceptableContentTypes() as $type) {
            if ($format = $this->getFormat($type)) {
                return $format;
            }
        }
        return $default;
    }
    public static function createFromBase(SymfonyRequest $request)
    {
        if ($request instanceof static) {
            return $request;
        }
        $content = $request->content;
        $request = (new static())->duplicate($request->query->all(), $request->request->all(), $request->attributes->all(), $request->cookies->all(), $request->files->all(), $request->server->all());
        $request->content = $content;
        $request->request = $request->getInputSource();
        return $request;
    }
    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)
    {
        return parent::duplicate($query, $request, $attributes, $cookies, array_filter((array) $files), $server);
    }
    public function session()
    {
        if (!$this->hasSession()) {
            throw new RuntimeException('Session store not set on request.');
        }
        return $this->getSession();
    }
    public function user()
    {
        return call_user_func($this->getUserResolver());
    }
    public function route($param = null)
    {
        $route = call_user_func($this->getRouteResolver());
        if (is_null($route) || is_null($param)) {
            return $route;
        } else {
            return $route->parameter($param);
        }
    }
    public function getUserResolver()
    {
        return $this->userResolver ?: function () {
        };
    }
    public function setUserResolver(Closure $callback)
    {
        $this->userResolver = $callback;
        return $this;
    }
    public function getRouteResolver()
    {
        return $this->routeResolver ?: function () {
        };
    }
    public function setRouteResolver(Closure $callback)
    {
        $this->routeResolver = $callback;
        return $this;
    }
    public function offsetExists($offset)
    {
        return array_key_exists($offset, $this->all());
    }
    public function offsetGet($offset)
    {
        return Arr::get($this->all(), $offset);
    }
    public function offsetSet($offset, $value)
    {
        return $this->getInputSource()->set($offset, $value);
    }
    public function offsetUnset($offset)
    {
        return $this->getInputSource()->remove($offset);
    }
    public function __isset($key)
    {
        return !is_null($this->__get($key));
    }
    public function __get($key)
    {
        $all = $this->all();
        if (array_key_exists($key, $all)) {
            return $all[$key];
        } else {
            return $this->route($key);
        }
    }
}
}

namespace Royalcms\Component\Http\Middleware {
use Closure;
class FrameGuard
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);
        $response->headers->set('X-Frame-Options', 'SAMEORIGIN', false);
        return $response;
    }
}
}

namespace Royalcms\Component\Http {
trait ResponseTrait
{
    public function status()
    {
        return $this->getStatusCode();
    }
    public function content()
    {
        return $this->getContent();
    }
    public function header($key, $value, $replace = true)
    {
        $this->headers->set($key, $value, $replace);
        return $this;
    }
    public function withCookie($cookie)
    {
        if (is_string($cookie) && function_exists('cookie')) {
            $cookie = call_user_func_array('cookie', func_get_args());
        }
        $this->headers->setCookie($cookie);
        return $this;
    }
}
}

namespace Royalcms\Component\Http {
use ArrayObject;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Support\Renderable;
use Symfony\Component\HttpFoundation\Response as BaseResponse;
class Response extends BaseResponse
{
    use ResponseTrait;
    public $original;
    public $exception;
    public function setContent($content)
    {
        $this->original = $content;
        if ($this->shouldBeJson($content)) {
            $this->header('Content-Type', 'application/json');
            $content = $this->morphToJson($content);
        } elseif ($content instanceof Renderable) {
            $content = $content->render();
        }
        return parent::setContent($content);
    }
    protected function morphToJson($content)
    {
        if ($content instanceof Jsonable) {
            return $content->toJson();
        }
        return json_encode($content);
    }
    protected function shouldBeJson($content)
    {
        return $content instanceof Jsonable || $content instanceof ArrayObject || is_array($content);
    }
    public function getOriginalContent()
    {
        return $this->original;
    }
}
}

namespace Royalcms\Component\Foundation {
use Closure;
use RuntimeException;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Http\Request;
use Royalcms\Component\Container\Container;
use Royalcms\Component\Filesystem\Filesystem;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Events\EventServiceProvider;
use Royalcms\Component\Routing\RoutingServiceProvider;
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\HttpFoundation\Request as SymfonyRequest;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Royalcms\Component\Contracts\Foundation\Royalcms as RoyalcmsContract;
use Royalcms\Component\Contracts\Debug\ExceptionHandler;
class Royalcms extends Container implements RoyalcmsContract, HttpKernelInterface
{
    const VERSION = '5.15.0';
    const RELEASE = '2019-06-14';
    protected $basePath;
    protected $hasBeenBootstrapped = false;
    protected $booted = false;
    protected $bootingCallbacks = [];
    protected $bootedCallbacks = [];
    protected $terminatingCallbacks = [];
    protected $serviceProviders = [];
    protected $loadedProviders = [];
    protected $deferredServices = [];
    protected $monologConfigurator;
    protected $databasePath;
    protected $storagePath;
    protected $environmentPath;
    protected $useStoragePathForOptimizations = false;
    protected $environmentFile = '.env';
    protected $namespace = null;
    public function __construct($basePath = null)
    {
        $this->registerBaseBindings();
        $this->registerBaseServiceProviders();
        $this->registerCoreContainerAliases();
        if ($basePath) {
            $this->setBasePath($basePath);
        }
    }
    public function version()
    {
        return static::VERSION;
    }
    public function release()
    {
        return static::RELEASE;
    }
    protected function registerBaseBindings()
    {
        static::setInstance($this);
        $this->instance('royalcms', $this);
        $this->instance('Royalcms\\Component\\Container\\Container', $this);
    }
    protected function registerBaseServiceProviders()
    {
        $this->register(new EventServiceProvider($this));
        $this->register(new RoutingServiceProvider($this));
    }
    public function bootstrapWith(array $bootstrappers)
    {
        $this->hasBeenBootstrapped = true;
        foreach ($bootstrappers as $bootstrapper) {
            $this['events']->fire('bootstrapping: ' . $bootstrapper, [$this]);
            $this->make($bootstrapper)->bootstrap($this);
            $this['events']->fire('bootstrapped: ' . $bootstrapper, [$this]);
        }
    }
    public function afterLoadingEnvironment(Closure $callback)
    {
        return $this->afterBootstrapping('Royalcms\\Component\\Foundation\\Bootstrap\\DetectEnvironment', $callback);
    }
    public function beforeBootstrapping($bootstrapper, Closure $callback)
    {
        $this['events']->listen('bootstrapping: ' . $bootstrapper, $callback);
    }
    public function afterBootstrapping($bootstrapper, Closure $callback)
    {
        $this['events']->listen('bootstrapped: ' . $bootstrapper, $callback);
    }
    public function hasBeenBootstrapped()
    {
        return $this->hasBeenBootstrapped;
    }
    public function setBasePath($basePath)
    {
        $this->basePath = rtrim($basePath, '\\/');
        $this->bindPathsInContainer();
        return $this;
    }
    protected function bindPathsInContainer()
    {
        $this->instance('path', $this->path());
        foreach (['base', 'content', 'site', 'system', 'config', 'database', 'lang', 'app', 'plugin', 'theme', 'upload', 'storage', 'bootstrap', 'resource', 'vendor'] as $path) {
            $this->instance('path.' . $path, $this->{$path . 'Path'}());
        }
    }
    public function basePath()
    {
        return $this->basePath;
    }
    public function path()
    {
        if ($this->runningInSite()) {
            return $this->sitePath() . DIRECTORY_SEPARATOR . RC_SITE;
        } else {
            return $this->basePath();
        }
    }
    public function contentPath()
    {
        return $this->basePath() . DIRECTORY_SEPARATOR . 'content';
    }
    public function siteContentPath()
    {
        return $this->path() . DIRECTORY_SEPARATOR . 'content';
    }
    public function sitePath()
    {
        return $this->basePath . DIRECTORY_SEPARATOR . 'sites';
    }
    public function systemPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'system';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'system';
        }
    }
    public function bootstrapPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'bootstrap';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'bootstrap';
        }
    }
    public function appPath($dir = null)
    {
        if (!is_null($dir)) {
            $dir = DIRECTORY_SEPARATOR . $dir;
        }
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'apps' . $dir;
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'apps' . $dir;
        }
    }
    public function pluginPath($dir = null)
    {
        if (!is_null($dir)) {
            $dir = DIRECTORY_SEPARATOR . $dir;
        }
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'plugins' . $dir;
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'plugins' . $dir;
        }
    }
    public function themePath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'themes';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'themes';
        }
    }
    public function uploadPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'uploads';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'uploads';
        }
    }
    public function resourcePath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'resources';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'resources';
        }
    }
    public function testPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'tests';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'tests';
        }
    }
    public function configPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'configs';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'configs';
        }
    }
    public function databasePath()
    {
        if ($this->databasePath) {
            return $this->databasePath;
        } else {
            $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'database';
            if ($this->runningInSite() && is_dir($path)) {
                return $path;
            } else {
                return $this->contentPath() . DIRECTORY_SEPARATOR . 'database';
            }
        }
    }
    public function useDatabasePath($path)
    {
        $this->databasePath = $path;
        $this->instance('path.database', $path);
        return $this;
    }
    public function langPath()
    {
        $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'languages';
        if ($this->runningInSite() && is_dir($path)) {
            return $path;
        } else {
            return $this->contentPath() . DIRECTORY_SEPARATOR . 'languages';
        }
    }
    public function publicPath()
    {
        return $this->basePath();
    }
    public function vendorPath()
    {
        return $this->basePath() . DIRECTORY_SEPARATOR . 'vendor';
    }
    public function storagePath()
    {
        if ($this->storagePath) {
            return $this->storagePath;
        } else {
            $path = $this->siteContentPath() . DIRECTORY_SEPARATOR . 'storages';
            if ($this->runningInSite() && is_dir($path)) {
                return $path;
            } else {
                return $this->contentPath() . DIRECTORY_SEPARATOR . 'storages';
            }
        }
    }
    public function useStoragePath($path)
    {
        $this->storagePath = $path;
        $this->instance('path.storage', $path);
        return $this;
    }
    public function environmentPath()
    {
        return $this->environmentPath ?: $this->basePath;
    }
    public function useEnvironmentPath($path)
    {
        $this->environmentPath = $path;
        return $this;
    }
    public function loadEnvironmentFrom($file)
    {
        $this->environmentFile = $file;
        return $this;
    }
    public function environmentFile()
    {
        return $this->environmentFile ?: '.env';
    }
    public function environment()
    {
        if (func_num_args() > 0) {
            $patterns = is_array(func_get_arg(0)) ? func_get_arg(0) : func_get_args();
            foreach ($patterns as $pattern) {
                if (Str::is($pattern, $this['env'])) {
                    return true;
                }
            }
            return false;
        }
        return $this['env'];
    }
    public function isLocal()
    {
        return $this['env'] == 'local';
    }
    public function detectEnvironment(Closure $callback)
    {
        $args = isset($_SERVER['argv']) ? $_SERVER['argv'] : null;
        return $this['env'] = (new EnvironmentDetector())->detect($callback, $args);
    }
    public function runningInSite()
    {
        return defined('RC_SITE');
    }
    public function runningInConsole()
    {
        return php_sapi_name() == 'cli';
    }
    public function runningUnitTests()
    {
        return $this['env'] == 'testing';
    }
    public function registerConfiguredProviders()
    {
        $manifestPath = $this->getCachedServicesPath();
        (new ProviderRepository($this, new Filesystem(), $manifestPath))->load($this->config['coreservice.providers']);
    }
    public function forgeRegister($provider, $options = array())
    {
        return $this->register($provider, $options, true);
    }
    public function register($provider, $options = [], $force = false)
    {
        if (($registered = $this->getProvider($provider)) && !$force) {
            return $registered;
        }
        if (is_string($provider)) {
            $provider = $this->resolveProviderClass($provider);
        }
        $provider->register();
        foreach ($options as $key => $value) {
            $this[$key] = $value;
        }
        $this->markAsRegistered($provider);
        if ($this->booted) {
            $this->bootProvider($provider);
        }
        return $provider;
    }
    public function getProvider($provider)
    {
        $name = is_string($provider) ? $provider : get_class($provider);
        return Arr::first($this->serviceProviders, function ($value, $key) use($name) {
            return $value instanceof $name;
        });
    }
    public function resolveProviderClass($provider)
    {
        return new $provider($this);
    }
    protected function markAsRegistered($provider)
    {
        $this['events']->fire($class = get_class($provider), [$provider]);
        $this->serviceProviders[] = $provider;
        $this->loadedProviders[$class] = true;
    }
    public function loadDeferredProviders()
    {
        foreach ($this->deferredServices as $service => $provider) {
            $this->loadDeferredProvider($service);
        }
        $this->deferredServices = [];
    }
    public function loadDeferredProvider($service)
    {
        if (!isset($this->deferredServices[$service])) {
            return;
        }
        $provider = $this->deferredServices[$service];
        if (!isset($this->loadedProviders[$provider])) {
            $this->registerDeferredProvider($provider, $service);
        }
    }
    public function registerDeferredProvider($provider, $service = null)
    {
        if ($service) {
            unset($this->deferredServices[$service]);
        }
        $this->register($instance = new $provider($this));
        if (!$this->booted) {
            $this->booting(function () use($instance) {
                $this->bootProvider($instance);
            });
        }
    }
    public function make($abstract, array $parameters = [])
    {
        $abstract = $this->getAlias($abstract);
        if (isset($this->deferredServices[$abstract])) {
            $this->loadDeferredProvider($abstract);
        }
        return parent::make($abstract, $parameters);
    }
    public function bound($abstract)
    {
        return isset($this->deferredServices[$abstract]) || parent::bound($abstract);
    }
    public function isBooted()
    {
        return $this->booted;
    }
    public function boot()
    {
        if ($this->booted) {
            return;
        }
        $this->fireAppCallbacks($this->bootingCallbacks);
        array_walk($this->serviceProviders, function ($p) {
            $this->bootProvider($p);
        });
        $this->booted = true;
        $this->fireAppCallbacks($this->bootedCallbacks);
    }
    protected function bootProvider(ServiceProvider $provider)
    {
        if (method_exists($provider, 'boot')) {
            return $this->call([$provider, 'boot']);
        }
    }
    public function booting($callback)
    {
        $this->bootingCallbacks[] = $callback;
    }
    public function booted($callback)
    {
        $this->bootedCallbacks[] = $callback;
        if ($this->isBooted()) {
            $this->fireAppCallbacks([$callback]);
        }
    }
    protected function fireAppCallbacks(array $callbacks)
    {
        foreach ($callbacks as $callback) {
            call_user_func($callback, $this);
        }
    }
    public function handle(SymfonyRequest $request, $type = self::MASTER_REQUEST, $catch = true)
    {
        return $this['Royalcms\\Component\\Contracts\\Http\\Kernel']->handle(Request::createFromBase($request));
    }
    public function shouldSkipMiddleware()
    {
        return $this->bound('middleware.disable') && $this->make('middleware.disable') === true;
    }
    public function configurationIsCached()
    {
        return $this['files']->exists($this->getCachedConfigPath());
    }
    public function getCachedConfigPath()
    {
        if ($this->vendorIsWritableForOptimizations()) {
            return $this->contentPath() . '/bootstrap/cache/config.php';
        } else {
            return $this->storagePath() . '/framework/config.php';
        }
    }
    public function getCachedTranslationPath($locale = null)
    {
        if (is_null($locale)) {
            $locale = $this['config']->get('system.locale');
        }
        if ($this->vendorIsWritableForOptimizations()) {
            return $this->contentPath() . "/bootstrap/cache/{$locale}.php";
        } else {
            return $this->storagePath() . "/framework/{$locale}.php";
        }
    }
    public function routesAreCached()
    {
        return $this['files']->exists($this->getCachedRoutesPath());
    }
    public function getCachedRoutesPath()
    {
        if ($this->vendorIsWritableForOptimizations()) {
            return $this->contentPath() . '/bootstrap/cache/routes.php';
        } else {
            return $this->storagePath() . '/framework/routes.php';
        }
    }
    public function getCachedCompilePath()
    {
        if ($this->vendorIsWritableForOptimizations()) {
            return $this->contentPath() . '/bootstrap/cache/compiled.php';
        } else {
            return $this->storagePath() . '/framework/compiled.php';
        }
    }
    public function getCachedServicesPath()
    {
        if ($this->vendorIsWritableForOptimizations()) {
            return $this->contentPath() . '/bootstrap/cache/services.json';
        } else {
            return $this->storagePath() . '/framework/services.json';
        }
    }
    public function vendorIsWritableForOptimizations()
    {
        if ($this->useStoragePathForOptimizations) {
            return false;
        }
        return is_writable($this->basePath() . '/vendor');
    }
    public function useStoragePathForOptimizations($value = true)
    {
        $this->useStoragePathForOptimizations = $value;
        return $this;
    }
    public function isDownForMaintenance()
    {
        return file_exists($this->storagePath() . '/framework/down');
    }
    public function abort($code, $message = '', array $headers = [])
    {
        if ($code == 404) {
            throw new NotFoundHttpException($message);
        }
        throw new HttpException($code, $message, null, $headers);
    }
    public function missing(Closure $callback)
    {
        $this->error(function (NotFoundHttpException $e) use($callback) {
            return call_user_func($callback, $e);
        });
    }
    public function error(Closure $callback)
    {
        $this['exception.handler']->error($callback);
    }
    public function pushError(Closure $callback)
    {
        $this['exception.handler']->pushError($callback);
    }
    public function fatal(Closure $callback)
    {
        $this->error(function (\Symfony\Component\Debug\Exception\FatalErrorException $e) use($callback) {
            return call_user_func($callback, $e);
        });
    }
    public function terminating(Closure $callback)
    {
        $this->terminatingCallbacks[] = $callback;
        return $this;
    }
    public function terminate()
    {
        foreach ($this->terminatingCallbacks as $terminating) {
            $this->call($terminating);
        }
    }
    public function getLoadedProviders()
    {
        return $this->loadedProviders;
    }
    public function getDeferredServices()
    {
        return $this->deferredServices;
    }
    public function setDeferredServices(array $services)
    {
        $this->deferredServices = $services;
    }
    public function addDeferredServices(array $services)
    {
        $this->deferredServices = array_merge($this->deferredServices, $services);
    }
    public function isDeferredService($service)
    {
        return isset($this->deferredServices[$service]);
    }
    public function configureMonologUsing(callable $callback)
    {
        $this->monologConfigurator = $callback;
        return $this;
    }
    public function hasMonologConfigurator()
    {
        return !is_null($this->monologConfigurator);
    }
    public function getMonologConfigurator()
    {
        return $this->monologConfigurator;
    }
    public function getLocale()
    {
        return $this['config']->get('system.locale');
    }
    public function setLocale($locale)
    {
        $this['config']->set('system.locale', $locale);
        $this['translator']->setLocale($locale);
        $this['events']->fire('locale.changed', [$locale]);
    }
    public function registerCoreContainerAliases()
    {
        $aliases = ['royalcms' => ['Royalcms\\Component\\Foundation\\Royalcms', 'Royalcms\\Component\\Contracts\\Container\\Container', 'Royalcms\\Component\\Contracts\\Foundation\\Royalcms'], 'auth' => 'Royalcms\\Component\\Auth\\AuthManager', 'auth.driver' => ['Royalcms\\Component\\Auth\\Guard', 'Royalcms\\Component\\Contracts\\Auth\\Guard'], 'auth.password.tokens' => 'Royalcms\\Component\\Auth\\Passwords\\TokenRepositoryInterface', 'blade.compiler' => 'Royalcms\\Component\\View\\Compilers\\BladeCompiler', 'cache' => ['Royalcms\\Component\\Cache\\CacheManager', 'Royalcms\\Component\\Contracts\\Cache\\Factory'], 'cache.store' => ['Royalcms\\Component\\Cache\\Repository', 'Royalcms\\Component\\Contracts\\Cache\\Repository'], 'config' => ['Royalcms\\Component\\Config\\Repository', 'Royalcms\\Component\\Contracts\\Config\\Repository'], 'cookie' => ['Royalcms\\Component\\Cookie\\CookieJar', 'Royalcms\\Component\\Contracts\\Cookie\\Factory', 'Royalcms\\Component\\Contracts\\Cookie\\QueueingFactory'], 'encrypter' => ['Royalcms\\Component\\Encryption\\Encrypter', 'Royalcms\\Component\\Contracts\\Encryption\\Encrypter'], 'db' => 'Royalcms\\Component\\Database\\DatabaseManager', 'db.connection' => ['Royalcms\\Component\\Database\\Connection', 'Royalcms\\Component\\Database\\ConnectionInterface'], 'events' => ['Royalcms\\Component\\Events\\Dispatcher', 'Royalcms\\Component\\Contracts\\Events\\Dispatcher'], 'files' => 'Royalcms\\Component\\Filesystem\\Filesystem', 'filesystem' => ['Royalcms\\Component\\Filesystem\\FilesystemManager', 'Royalcms\\Component\\Contracts\\Filesystem\\Factory'], 'filesystem.disk' => 'Royalcms\\Component\\Contracts\\Filesystem\\Filesystem', 'filesystem.cloud' => 'Royalcms\\Component\\Contracts\\Filesystem\\Cloud', 'hash' => 'Royalcms\\Component\\Contracts\\Hashing\\Hasher', 'translator' => ['Royalcms\\Component\\Translation\\Translator', 'Symfony\\Component\\Translation\\TranslatorInterface'], 'log' => ['Royalcms\\Component\\Log\\Writer', 'Royalcms\\Component\\Contracts\\Logging\\Log', 'Psr\\Log\\LoggerInterface'], 'mailer' => ['Royalcms\\Component\\Mail\\Mailer', 'Royalcms\\Component\\Contracts\\Mail\\Mailer', 'Royalcms\\Component\\Contracts\\Mail\\MailQueue'], 'auth.password' => ['Royalcms\\Component\\Auth\\Passwords\\PasswordBroker', 'Royalcms\\Component\\Contracts\\Auth\\PasswordBroker'], 'queue' => ['Royalcms\\Component\\Queue\\QueueManager', 'Royalcms\\Component\\Contracts\\Queue\\Factory', 'Royalcms\\Component\\Contracts\\Queue\\Monitor'], 'queue.connection' => 'Royalcms\\Component\\Contracts\\Queue\\Queue', 'redirect' => 'Royalcms\\Component\\Routing\\Redirector', 'redis' => ['Royalcms\\Component\\Redis\\Database', 'Royalcms\\Component\\Contracts\\Redis\\Database'], 'request' => 'Royalcms\\Component\\Http\\Request', 'router' => ['Royalcms\\Component\\Routing\\Router', 'Royalcms\\Component\\Contracts\\Routing\\Registrar'], 'session' => 'Royalcms\\Component\\Session\\SessionManager', 'session.store' => ['Royalcms\\Component\\Session\\Store', 'Symfony\\Component\\HttpFoundation\\Session\\SessionInterface'], 'url' => ['Royalcms\\Component\\Routing\\UrlGenerator', 'Royalcms\\Component\\Contracts\\Routing\\UrlGenerator'], 'validator' => ['Royalcms\\Component\\Validation\\Factory', 'Royalcms\\Component\\Contracts\\Validation\\Factory'], 'view' => ['Royalcms\\Component\\View\\Factory', 'Royalcms\\Component\\Contracts\\View\\Factory']];
        foreach ($aliases as $key => $aliases) {
            foreach ((array) $aliases as $alias) {
                $this->alias($key, $alias);
            }
        }
    }
    public function flush()
    {
        parent::flush();
        $this->loadedProviders = [];
    }
    protected function getKernel()
    {
        $kernelContract = $this->runningInConsole() ? 'Royalcms\\Component\\Contracts\\Console\\Kernel' : 'Royalcms\\Component\\Contracts\\Http\\Kernel';
        return $this->make($kernelContract);
    }
    public function getNamespace()
    {
        if (!is_null($this->namespace)) {
            return $this->namespace;
        }
        $composer = json_decode(file_get_contents(base_path('composer.json')), true);
        foreach ((array) data_get($composer, 'autoload.psr-4') as $namespace => $path) {
            foreach ((array) $path as $pathChoice) {
                if (realpath(app_path()) == realpath(base_path() . '/' . $pathChoice)) {
                    return $this->namespace = $namespace;
                }
            }
        }
        throw new RuntimeException('Unable to detect application namespace.');
    }
    public function down(Closure $callback)
    {
        $this['events']->listen('royalcms.app.down', $callback);
    }
}
}

namespace Royalcms\Component\Foundation {
use Closure;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
class EnvironmentDetector
{
    public function detect(Closure $callback, $consoleArgs = null)
    {
        if ($consoleArgs) {
            return $this->detectConsoleEnvironment($callback, $consoleArgs);
        }
        return $this->detectWebEnvironment($callback);
    }
    protected function detectWebEnvironment(Closure $callback)
    {
        return call_user_func($callback);
    }
    protected function detectConsoleEnvironment(Closure $callback, array $args)
    {
        if (!is_null($value = $this->getEnvironmentArgument($args))) {
            return head(array_slice(explode('=', $value), 1));
        }
        return $this->detectWebEnvironment($callback);
    }
    protected function getEnvironmentArgument(array $args)
    {
        return Arr::first($args, function ($v, $k) {
            return Str::startsWith($v, '--env');
        });
    }
    public function isMachine($name)
    {
        return str_is($name, gethostname());
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Log\Writer;
use Monolog\Logger as Monolog;
use Royalcms\Component\Contracts\Foundation\Royalcms;
class ConfigureLogging
{
    public function bootstrap(Royalcms $royalcms)
    {
        $log = $this->registerLogger($royalcms);
        if ($royalcms->hasMonologConfigurator()) {
            call_user_func($royalcms->getMonologConfigurator(), $log->getMonolog());
        } else {
            $this->configureHandlers($royalcms, $log);
        }
    }
    protected function registerLogger(Royalcms $royalcms)
    {
        $royalcms->instance('log', $log = new Writer(new Monolog($royalcms->environment()), $royalcms['events']));
        return $log;
    }
    protected function configureHandlers(Royalcms $royalcms, Writer $log)
    {
        $method = 'configure' . ucfirst($royalcms['config']['system.log']) . 'Handler';
        $this->{$method}($royalcms, $log);
    }
    protected function configureSingleHandler(Royalcms $royalcms, Writer $log)
    {
        $log->useFiles($royalcms->storagePath() . '/logs/royalcms.log');
    }
    protected function configureDailyHandler(Royalcms $royalcms, Writer $log)
    {
        $log->useDailyFiles($royalcms->storagePath() . '/logs/royalcms.log', $royalcms->make('config')->get('system.log_max_files', 5));
    }
    protected function configureSyslogHandler(Royalcms $app, Writer $log)
    {
        $log->useSyslog('royalcms');
    }
    protected function configureErrorlogHandler(Royalcms $royalcms, Writer $log)
    {
        $log->useErrorLog();
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Royalcms\Component\Exception\ExceptionServiceProvider;
class HandleExceptions
{
    protected $royalcms;
    public function bootstrap(Royalcms $royalcms)
    {
        $this->royalcms = $royalcms;
        $this->royalcms->register(new ExceptionServiceProvider($royalcms));
        $this->startExceptionHandling();
    }
    public function startExceptionHandling()
    {
        $this->royalcms['exception']->register($this->royalcms->environment());
        $this->royalcms['exception.display']->setDebug($this->royalcms['config']['system.debug']);
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Support\Facades\Facade;
use Royalcms\Component\Foundation\AliasLoader;
use Royalcms\Component\Contracts\Foundation\Royalcms;
class RegisterFacades
{
    public function bootstrap(Royalcms $royalcms)
    {
        Facade::clearResolvedInstances();
        Facade::setFacadeRoyalcms($royalcms);
        AliasLoader::getInstance($royalcms->make('config')->get('coreservice.aliases'));
        AliasLoader::getInstance($royalcms->make('config')->get('facade'));
        AliasLoader::getInstance()->register();
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
class RegisterProviders
{
    public function bootstrap(Royalcms $royalcms)
    {
        $royalcms->registerConfiguredProviders();
        collect($royalcms['config']->get('provider', array()))->map(function ($provider) use($royalcms) {
            if (class_exists($provider)) {
                $royalcms->register($provider);
            }
        });
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
class BootProviders
{
    public function bootstrap(Royalcms $royalcms)
    {
        $path = $royalcms['path.system'] . '/start/bootstrap.php';
        if (file_exists($path)) {
            require $path;
        }
        $royalcms->boot();
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Config\Repository;
use Symfony\Component\Finder\Finder;
use Symfony\Component\Finder\SplFileInfo;
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Royalcms\Component\Contracts\Config\Repository as RepositoryContract;
use Royalcms\Component\Config\FileLoader;
use Royalcms\Component\Filesystem\Filesystem;
class LoadConfiguration
{
    public function bootstrap(Royalcms $royalcms)
    {
        $items = [];
        if (file_exists($cached = $royalcms->getCachedConfigPath())) {
            $items = (require $cached);
            $loadedFromCache = true;
        }
        $config = new Repository($this->getConfigLoader($royalcms), $royalcms['env'], $items);
        $royalcms->instance('config', $config);
        if (!isset($loadedFromCache)) {
        }
        date_default_timezone_set($config['system.timezone']);
        mb_internal_encoding('UTF-8');
    }
    protected function getConfigLoader(Royalcms $royalcms)
    {
        return new FileLoader(new Filesystem(), $royalcms['path'] . '/content/configs', $royalcms['path.base'] . '/content/configs');
    }
    protected function loadConfigurationFiles(Royalcms $royalcms, RepositoryContract $repository)
    {
        foreach ($this->getConfigurationFiles($royalcms) as $key => $path) {
            $repository->set($key, require $path);
        }
    }
    protected function getConfigurationFiles(Royalcms $royalcms)
    {
        $files = [];
        $configPath = realpath($royalcms->configPath());
        foreach (Finder::create()->files()->name('*.php')->in($configPath) as $file) {
            $nesting = $this->getConfigurationNesting($file, $configPath);
            $files[$nesting . basename($file->getRealPath(), '.php')] = $file->getRealPath();
        }
        return $files;
    }
    protected function getConfigurationNesting(SplFileInfo $file, $configPath)
    {
        $directory = dirname($file->getRealPath());
        if ($tree = trim(str_replace($configPath, '', $directory), DIRECTORY_SEPARATOR)) {
            $tree = str_replace(DIRECTORY_SEPARATOR, '.', $tree) . '.';
        }
        return $tree;
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Config\Dotenv;
use InvalidArgumentException;
use Royalcms\Component\Contracts\Foundation\Royalcms;
class DetectEnvironment
{
    public function bootstrap(Royalcms $royalcms)
    {
        try {
            Dotenv::load($royalcms->environmentPath(), $royalcms->environmentFile());
        } catch (InvalidArgumentException $e) {
        }
        $royalcms->detectEnvironment(function () {
            return env('ROYALCMS_ENV', 'production');
        });
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Royalcms\Component\ClassLoader\ClassManager;
class RegisterNamespaces
{
    public function bootstrap(Royalcms $royalcms)
    {
        ClassManager::addNamespaces($royalcms['config']->get('namespaces', array()));
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
use RC_Loader;
use RC_Hook;
class Booted
{
    public function bootstrap(Royalcms $royalcms)
    {
        $royalcms->booted(function () use($royalcms) {
            $_POST = rc_addslashes($_POST);
            $_GET = rc_addslashes($_GET);
            $_REQUEST = rc_addslashes($_REQUEST);
            $_COOKIE = rc_addslashes($_COOKIE);
            RC_Loader::auto_load_func();
            $path = $royalcms['path.system'] . '/start/global.php';
            if (file_exists($path)) {
                require $path;
            }
            $env = $royalcms['env'];
            $path = $royalcms['path.system'] . "/start/{$env}.php";
            if (file_exists($path)) {
                require $path;
            }
            $routes = $royalcms['path.system'] . '/start/routes.php';
            if (file_exists($routes)) {
                require $routes;
            }
            RC_Hook::do_action('init');
        });
    }
}
}

namespace Royalcms\Component\Foundation\Bootstrap {
use Royalcms\Component\Contracts\Foundation\Royalcms;
use InvalidArgumentException;
use Royalcms\Component\Config\Dotenv;
class Starting
{
    public function bootstrap(Royalcms $royalcms)
    {
        error_reporting(-1);
        if (!extension_loaded('mcrypt') && version_compare(PHP_VERSION, '7.2', '<')) {
            echo 'Mcrypt PHP extension required.' . PHP_EOL;
            exit(1);
        }
        if (!interface_exists('Throwable')) {
            class_alias('\\Royalcms\\Component\\Foundation\\Compatible\\Throwable', 'Throwable');
        }
        if (!class_exists('Error')) {
            class_alias('\\Royalcms\\Component\\Foundation\\Compatible\\Error', 'Error');
        }
        \Royalcms\Component\ClassLoader\ClassManager::auto_loader_class();
        try {
            Dotenv::load(SITE_PATH, $royalcms->environmentFile());
        } catch (InvalidArgumentException $e) {
            try {
                Dotenv::load(SITE_ROOT, $royalcms->environmentFile());
            } catch (InvalidArgumentException $e) {
            }
        }
        $royalcms->detectEnvironment(function () {
            return env('ROYALCMS_ENV', 'production');
        });
    }
}
}

namespace Royalcms\Component\Foundation\Http {
use Exception;
use Throwable;
use Royalcms\Component\Routing\Router;
use Royalcms\Component\Pipeline\Pipeline;
use Royalcms\Component\Support\Facades\Facade;
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Royalcms\Component\Contracts\Http\Kernel as KernelContract;
use Symfony\Component\Debug\Exception\FatalThrowableError;
class Kernel implements KernelContract
{
    protected $royalcms;
    protected $router;
    protected $bootstrappers = ['Royalcms\\Component\\Foundation\\Bootstrap\\Starting', 'Royalcms\\Component\\Foundation\\Bootstrap\\DetectEnvironment', 'Royalcms\\Component\\Foundation\\Bootstrap\\LoadConfiguration', 'Royalcms\\Component\\Foundation\\Bootstrap\\RegisterNamespaces', 'Royalcms\\Component\\Foundation\\Bootstrap\\ConfigureLogging', 'Royalcms\\Component\\Foundation\\Bootstrap\\HandleExceptions', 'Royalcms\\Component\\Foundation\\Bootstrap\\RegisterFacades', 'Royalcms\\Component\\Foundation\\Bootstrap\\RegisterProviders', 'Royalcms\\Component\\Foundation\\Bootstrap\\BootProviders', 'Royalcms\\Component\\Foundation\\Bootstrap\\Booted'];
    protected $middleware = [];
    protected $routeMiddleware = [];
    public function __construct(Royalcms $royalcms, Router $router)
    {
        $this->royalcms = $royalcms;
        $this->router = $router;
        foreach ($this->routeMiddleware as $key => $middleware) {
            $router->middleware($key, $middleware);
        }
    }
    public function handle($request)
    {
        try {
            $request->enableHttpMethodParameterOverride();
            $response = $this->sendRequestThroughRouter($request);
        } catch (Exception $e) {
            $this->reportException($e);
            $response = $this->renderException($request, $e);
        } catch (Throwable $e) {
            $e = new FatalThrowableError($e);
            $this->reportException($e);
            $response = $this->renderException($request, $e);
        }
        $this->royalcms['events']->fire('kernel.handled', [$request, $response]);
        return $response;
    }
    protected function sendRequestThroughRouter($request)
    {
        $this->royalcms->instance('request', $request);
        Facade::clearResolvedInstance('request');
        $this->bootstrap();
        return with(new Pipeline($this->royalcms))->send($request)->through($this->royalcms->shouldSkipMiddleware() ? [] : $this->middleware)->then($this->dispatchToRouter());
    }
    public function terminate($request, $response)
    {
        $middlewares = $this->royalcms->shouldSkipMiddleware() ? [] : array_merge($this->gatherRouteMiddlewares($request), $this->middleware);
        foreach ($middlewares as $middleware) {
            list($name, $parameters) = $this->parseMiddleware($middleware);
            $instance = $this->royalcms->make($name);
            if (method_exists($instance, 'terminate')) {
                $instance->terminate($request, $response);
            }
        }
        $this->royalcms->terminate();
    }
    protected function gatherRouteMiddlewares($request)
    {
        if ($route = $request->route()) {
            return $this->router->gatherRouteMiddlewares($route);
        }
        return [];
    }
    protected function parseMiddleware($middleware)
    {
        list($name, $parameters) = array_pad(explode(':', $middleware, 2), 2, []);
        if (is_string($parameters)) {
            $parameters = explode(',', $parameters);
        }
        return [$name, $parameters];
    }
    public function prependMiddleware($middleware)
    {
        if (array_search($middleware, $this->middleware) === false) {
            array_unshift($this->middleware, $middleware);
        }
        return $this;
    }
    public function pushMiddleware($middleware)
    {
        if (array_search($middleware, $this->middleware) === false) {
            $this->middleware[] = $middleware;
        }
        return $this;
    }
    public function bootstrap()
    {
        if (!$this->royalcms->hasBeenBootstrapped()) {
            $this->royalcms->bootstrapWith($this->bootstrappers());
        }
    }
    protected function dispatchToRouter()
    {
        return function ($request) {
            $this->royalcms->instance('request', $request);
            return $this->router->dispatch($request);
        };
    }
    public function hasMiddleware($middleware)
    {
        return in_array($middleware, $this->middleware);
    }
    protected function bootstrappers()
    {
        return $this->bootstrappers;
    }
    protected function reportException(Exception $e)
    {
        $this->royalcms['Royalcms\\Component\\Contracts\\Debug\\ExceptionHandler']->report($e);
    }
    protected function renderException($request, Exception $e)
    {
        return $this->royalcms['Royalcms\\Component\\Contracts\\Debug\\ExceptionHandler']->render($request, $e);
    }
    public function getRoyalcms()
    {
        return $this->royalcms;
    }
    public function getApplication()
    {
        return $this->royalcms;
    }
}
}

namespace Royalcms\Component\Foundation\Auth {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Support\Facades\Auth;
use Royalcms\Component\Support\Facades\Lang;
trait AuthenticatesUsers
{
    use RedirectsUsers;
    public function getLogin()
    {
        if (view()->exists('auth.authenticate')) {
            return view('auth.authenticate');
        }
        return view('auth.login');
    }
    public function postLogin(Request $request)
    {
        $this->validate($request, [$this->loginUsername() => 'required', 'password' => 'required']);
        $throttles = $this->isUsingThrottlesLoginsTrait();
        if ($throttles && $this->hasTooManyLoginAttempts($request)) {
            return $this->sendLockoutResponse($request);
        }
        $credentials = $this->getCredentials($request);
        if (Auth::attempt($credentials, $request->has('remember'))) {
            return $this->handleUserWasAuthenticated($request, $throttles);
        }
        if ($throttles) {
            $this->incrementLoginAttempts($request);
        }
        return redirect($this->loginPath())->withInput($request->only($this->loginUsername(), 'remember'))->withErrors([$this->loginUsername() => $this->getFailedLoginMessage()]);
    }
    protected function handleUserWasAuthenticated(Request $request, $throttles)
    {
        if ($throttles) {
            $this->clearLoginAttempts($request);
        }
        if (method_exists($this, 'authenticated')) {
            return $this->authenticated($request, Auth::user());
        }
        return redirect()->intended($this->redirectPath());
    }
    protected function getCredentials(Request $request)
    {
        return $request->only($this->loginUsername(), 'password');
    }
    protected function getFailedLoginMessage()
    {
        return Lang::has('auth.failed') ? Lang::get('auth.failed') : 'These credentials do not match our records.';
    }
    public function getLogout()
    {
        Auth::logout();
        return redirect(property_exists($this, 'redirectAfterLogout') ? $this->redirectAfterLogout : '/');
    }
    public function loginPath()
    {
        return property_exists($this, 'loginPath') ? $this->loginPath : '/auth/login';
    }
    public function loginUsername()
    {
        return property_exists($this, 'username') ? $this->username : 'email';
    }
    protected function isUsingThrottlesLoginsTrait()
    {
        return in_array(ThrottlesLogins::class, class_uses_recursive(get_class($this)));
    }
}
}

namespace Royalcms\Component\Foundation\Auth {
trait RedirectsUsers
{
    public function redirectPath()
    {
        if (property_exists($this, 'redirectPath')) {
            return $this->redirectPath;
        }
        return property_exists($this, 'redirectTo') ? $this->redirectTo : '/home';
    }
}
}

namespace Royalcms\Component\Foundation\Auth {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Support\Facades\Auth;
trait RegistersUsers
{
    use RedirectsUsers;
    public function getRegister()
    {
        return view('auth.register');
    }
    public function postRegister(Request $request)
    {
        $validator = $this->validator($request->all());
        if ($validator->fails()) {
            $this->throwValidationException($request, $validator);
        }
        Auth::login($this->create($request->all()));
        return redirect($this->redirectPath());
    }
}
}

namespace Royalcms\Component\Foundation\Auth {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Mail\Message;
use Royalcms\Component\Support\Facades\Auth;
use Royalcms\Component\Support\Facades\Password;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
trait ResetsPasswords
{
    use RedirectsUsers;
    public function getEmail()
    {
        return view('auth.password');
    }
    public function postEmail(Request $request)
    {
        $this->validate($request, ['email' => 'required|email']);
        $response = Password::sendResetLink($request->only('email'), function (Message $message) {
            $message->subject($this->getEmailSubject());
        });
        switch ($response) {
            case Password::RESET_LINK_SENT:
                return redirect()->back()->with('status', trans($response));
            case Password::INVALID_USER:
                return redirect()->back()->withErrors(['email' => trans($response)]);
        }
    }
    protected function getEmailSubject()
    {
        return property_exists($this, 'subject') ? $this->subject : 'Your Password Reset Link';
    }
    public function getReset($token = null)
    {
        if (is_null($token)) {
            throw new NotFoundHttpException();
        }
        return view('auth.reset')->with('token', $token);
    }
    public function postReset(Request $request)
    {
        $this->validate($request, ['token' => 'required', 'email' => 'required|email', 'password' => 'required|confirmed|min:6']);
        $credentials = $request->only('email', 'password', 'password_confirmation', 'token');
        $response = Password::reset($credentials, function ($user, $password) {
            $this->resetPassword($user, $password);
        });
        switch ($response) {
            case Password::PASSWORD_RESET:
                return redirect($this->redirectPath())->with('status', trans($response));
            default:
                return redirect()->back()->withInput($request->only('email'))->withErrors(['email' => trans($response)]);
        }
    }
    protected function resetPassword($user, $password)
    {
        $user->password = bcrypt($password);
        $user->save();
        Auth::login($user);
    }
}
}

namespace Royalcms\Component\Foundation\Auth\Access {
use Royalcms\Component\Contracts\Auth\Access\Gate;
use Royalcms\Component\Auth\Access\UnauthorizedException;
use Symfony\Component\HttpKernel\Exception\HttpException;
trait AuthorizesRequests
{
    public function authorize($ability, $arguments = [])
    {
        list($ability, $arguments) = $this->parseAbilityAndArguments($ability, $arguments);
        return $this->authorizeAtGate(royalcms(Gate::class), $ability, $arguments);
    }
    public function authorizeForUser($user, $ability, $arguments = [])
    {
        list($ability, $arguments) = $this->parseAbilityAndArguments($ability, $arguments);
        $gate = royalcms(Gate::class)->forUser($user);
        return $this->authorizeAtGate($gate, $ability, $arguments);
    }
    public function authorizeAtGate(Gate $gate, $ability, $arguments)
    {
        try {
            return $gate->authorize($ability, $arguments);
        } catch (UnauthorizedException $e) {
            throw $this->createGateUnauthorizedException($ability, $arguments, $e->getMessage(), $e);
        }
    }
    protected function parseAbilityAndArguments($ability, $arguments)
    {
        if (is_string($ability)) {
            return [$ability, $arguments];
        }
        return [debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3)[2]['function'], $ability];
    }
    protected function createGateUnauthorizedException($ability, $arguments, $message = 'This action is unauthorized.', $previousException = null)
    {
        return new HttpException(403, $message, $previousException);
    }
}
}

namespace Royalcms\Component\Foundation\Http\Middleware {
use Closure;
use Royalcms\Component\Support\Str;
use Symfony\Component\HttpFoundation\Cookie;
use Royalcms\Component\Contracts\Encryption\Encrypter;
use Royalcms\Component\Session\TokenMismatchException;
class VerifyCsrfToken
{
    protected $encrypter;
    protected $except = [];
    public function __construct(Encrypter $encrypter)
    {
        $this->encrypter = $encrypter;
    }
    public function handle($request, Closure $next)
    {
        if ($this->isReading($request) || $this->shouldPassThrough($request) || $this->tokensMatch($request)) {
            return $this->addCookieToResponse($request, $next($request));
        }
        throw new TokenMismatchException();
    }
    protected function shouldPassThrough($request)
    {
        foreach ($this->except as $except) {
            if ($except !== '/') {
                $except = trim($except, '/');
            }
            if ($request->is($except)) {
                return true;
            }
        }
        return false;
    }
    protected function tokensMatch($request)
    {
        $sessionToken = $request->session()->token();
        $token = $request->input('_token') ?: $request->header('X-CSRF-TOKEN');
        if (!$token && ($header = $request->header('X-XSRF-TOKEN'))) {
            $token = $this->encrypter->decrypt($header);
        }
        if (!is_string($sessionToken) || !is_string($token)) {
            return false;
        }
        return Str::equals($sessionToken, $token);
    }
    protected function addCookieToResponse($request, $response)
    {
        $config = config('session');
        $response->headers->setCookie(new Cookie('XSRF-TOKEN', $request->session()->token(), time() + 60 * 120, $config['path'], $config['domain'], $config['secure'], false));
        return $response;
    }
    protected function isReading($request)
    {
        return in_array($request->method(), ['HEAD', 'GET', 'OPTIONS']);
    }
}
}

namespace Royalcms\Component\Foundation\Http\Middleware {
use Closure;
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Symfony\Component\HttpKernel\Exception\HttpException;
class CheckForMaintenanceMode
{
    protected $royalcms;
    public function __construct(Royalcms $royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public function handle($request, Closure $next)
    {
        if ($this->royalcms->isDownForMaintenance()) {
            throw new HttpException(503);
        }
        return $next($request);
    }
}
}

namespace Royalcms\Component\Foundation\Http {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Http\Response;
use Royalcms\Component\Http\JsonResponse;
use Royalcms\Component\Routing\Redirector;
use Royalcms\Component\Container\Container;
use Royalcms\Component\Contracts\Validation\Validator;
use Royalcms\Component\Http\Exception\HttpResponseException;
use Royalcms\Component\Validation\ValidatesWhenResolvedTrait;
use Royalcms\Component\Contracts\Validation\ValidatesWhenResolved;
use Royalcms\Component\Contracts\Validation\Factory as ValidationFactory;
class FormRequest extends Request implements ValidatesWhenResolved
{
    use ValidatesWhenResolvedTrait;
    protected $container;
    protected $redirector;
    protected $redirect;
    protected $redirectRoute;
    protected $redirectAction;
    protected $errorBag = 'default';
    protected $dontFlash = ['password', 'password_confirmation'];
    protected function getValidatorInstance()
    {
        $factory = $this->container->make(ValidationFactory::class);
        if (method_exists($this, 'validator')) {
            return $this->container->call([$this, 'validator'], compact('factory'));
        }
        return $factory->make($this->all(), $this->container->call([$this, 'rules']), $this->messages(), $this->attributes());
    }
    protected function failedValidation(Validator $validator)
    {
        throw new HttpResponseException($this->response($this->formatErrors($validator)));
    }
    protected function passesAuthorization()
    {
        if (method_exists($this, 'authorize')) {
            return $this->container->call([$this, 'authorize']);
        }
        return false;
    }
    protected function failedAuthorization()
    {
        throw new HttpResponseException($this->forbiddenResponse());
    }
    public function response(array $errors)
    {
        if ($this->ajax() || $this->wantsJson()) {
            return new JsonResponse($errors, 422);
        }
        return $this->redirector->to($this->getRedirectUrl())->withInput($this->except($this->dontFlash))->withErrors($errors, $this->errorBag);
    }
    public function forbiddenResponse()
    {
        return new Response('Forbidden', 403);
    }
    protected function formatErrors(Validator $validator)
    {
        return $validator->getMessageBag()->toArray();
    }
    protected function getRedirectUrl()
    {
        $url = $this->redirector->getUrlGenerator();
        if ($this->redirect) {
            return $url->to($this->redirect);
        } elseif ($this->redirectRoute) {
            return $url->route($this->redirectRoute);
        } elseif ($this->redirectAction) {
            return $url->action($this->redirectAction);
        }
        return $url->previous();
    }
    public function setRedirector(Redirector $redirector)
    {
        $this->redirector = $redirector;
        return $this;
    }
    public function setContainer(Container $container)
    {
        $this->container = $container;
        return $this;
    }
    public function messages()
    {
        return [];
    }
    public function attributes()
    {
        return [];
    }
}
}

namespace Royalcms\Component\Foundation\Bus {
use ArrayAccess;
trait DispatchesJobs
{
    protected function dispatch($job)
    {
        return royalcms('Royalcms\\Component\\Contracts\\Bus\\Dispatcher')->dispatch($job);
    }
    protected function dispatchFromArray($job, array $array)
    {
        return royalcms('Royalcms\\Component\\Contracts\\Bus\\Dispatcher')->dispatchFromArray($job, $array);
    }
    protected function dispatchFrom($job, ArrayAccess $source, $extras = [])
    {
        return royalcms('Royalcms\\Component\\Contracts\\Bus\\Dispatcher')->dispatchFrom($job, $source, $extras);
    }
}
}

namespace Royalcms\Component\Foundation\Validation {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Http\JsonResponse;
use Royalcms\Component\Routing\UrlGenerator;
use Royalcms\Component\Contracts\Validation\Factory;
use Royalcms\Component\Contracts\Validation\Validator;
use Royalcms\Component\Http\Exception\HttpResponseException;
trait ValidatesRequests
{
    protected $validatesRequestErrorBag;
    public function validate(Request $request, array $rules, array $messages = [], array $customAttributes = [])
    {
        $validator = $this->getValidationFactory()->make($request->all(), $rules, $messages, $customAttributes);
        if ($validator->fails()) {
            $this->throwValidationException($request, $validator);
        }
    }
    public function validateWithBag($errorBag, Request $request, array $rules, array $messages = [], array $customAttributes = [])
    {
        $this->withErrorBag($errorBag, function () use($request, $rules, $messages, $customAttributes) {
            $this->validate($request, $rules, $messages, $customAttributes);
        });
    }
    protected function throwValidationException(Request $request, $validator)
    {
        throw new HttpResponseException($this->buildFailedValidationResponse($request, $this->formatValidationErrors($validator)));
    }
    protected function buildFailedValidationResponse(Request $request, array $errors)
    {
        if ($request->ajax() || $request->wantsJson()) {
            return new JsonResponse($errors, 422);
        }
        return redirect()->to($this->getRedirectUrl())->withInput($request->input())->withErrors($errors, $this->errorBag());
    }
    protected function formatValidationErrors(Validator $validator)
    {
        return $validator->errors()->getMessages();
    }
    protected function getRedirectUrl()
    {
        return royalcms(UrlGenerator::class)->previous();
    }
    protected function getValidationFactory()
    {
        return royalcms(Factory::class);
    }
    protected function withErrorBag($errorBag, callable $callback)
    {
        $this->validatesRequestErrorBag = $errorBag;
        call_user_func($callback);
        $this->validatesRequestErrorBag = null;
    }
    protected function errorBag()
    {
        return $this->validatesRequestErrorBag ?: 'default';
    }
}
}

namespace Royalcms\Component\Foundation\Providers {
use Royalcms\Component\Support\AggregateServiceProvider;
class FoundationServiceProvider extends AggregateServiceProvider
{
    protected $providers = [FormRequestServiceProvider::class];
}
}

namespace Royalcms\Component\Foundation\Providers {
use Royalcms\Component\Routing\Redirector;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Foundation\Http\FormRequest;
use Symfony\Component\HttpFoundation\Request;
class FormRequestServiceProvider extends ServiceProvider
{
    public function register()
    {
    }
    public function boot()
    {
        $this->royalcms['events']->listen('router.matched', function () {
            $this->royalcms->resolving(function (FormRequest $request, $royalcms) {
                $this->initializeRequest($request, $royalcms['request']);
                $request->setContainer($royalcms)->setRedirector($royalcms->make(Redirector::class));
            });
        });
    }
    protected function initializeRequest(FormRequest $form, Request $current)
    {
        $files = $current->files->all();
        $files = is_array($files) ? array_filter($files) : $files;
        $form->initialize($current->query->all(), $current->request->all(), $current->attributes->all(), $current->cookies->all(), $files, $current->server->all(), $current->getContent());
        if ($session = $current->getSession()) {
            $form->setSession($session);
        }
        $form->setUserResolver($current->getUserResolver());
        $form->setRouteResolver($current->getRouteResolver());
    }
}
}

namespace Royalcms\Component\Foundation\Support\Providers {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Contracts\Auth\Access\Gate as GateContract;
class AuthServiceProvider extends ServiceProvider
{
    protected $policies = [];
    public function registerPolicies(GateContract $gate)
    {
        foreach ($this->policies as $key => $value) {
            $gate->policy($key, $value);
        }
    }
    public function register()
    {
    }
}
}

namespace Royalcms\Component\Foundation\Support\Providers {
use Royalcms\Component\Routing\Router;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Contracts\Routing\UrlGenerator;
class RouteServiceProvider extends ServiceProvider
{
    protected $namespace;
    public function boot(Router $router)
    {
        $this->setRootControllerNamespace();
        if ($this->royalcms->routesAreCached()) {
            $this->loadCachedRoutes();
        } else {
            $this->loadRoutes();
            $this->royalcms->booted(function () use($router) {
                $router->getRoutes()->refreshNameLookups();
            });
        }
    }
    protected function setRootControllerNamespace()
    {
        if (is_null($this->namespace)) {
            return;
        }
        $this->royalcms[UrlGenerator::class]->setRootControllerNamespace($this->namespace);
    }
    protected function loadCachedRoutes()
    {
        $this->royalcms->booted(function () {
            require $this->royalcms->getCachedRoutesPath();
        });
    }
    protected function loadRoutes()
    {
        $this->royalcms->call([$this, 'map']);
    }
    protected function loadRoutesFrom($path)
    {
        $router = $this->royalcms->make(Router::class);
        if (is_null($this->namespace)) {
            return require $path;
        }
        $router->group(['namespace' => $this->namespace], function (Router $router) use($path) {
            require $path;
        });
    }
    public function register()
    {
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->royalcms->make(Router::class), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Foundation\Support\Providers {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Contracts\Events\Dispatcher as DispatcherContract;
class EventServiceProvider extends ServiceProvider
{
    protected $listen = [];
    protected $subscribe = [];
    public function boot(DispatcherContract $events)
    {
        foreach ($this->listen as $event => $listeners) {
            foreach ($listeners as $listener) {
                $events->listen($event, $listener);
            }
        }
        foreach ($this->subscribe as $subscriber) {
            $events->subscribe($subscriber);
        }
    }
    public function register()
    {
    }
    public function listens()
    {
        return $this->listen;
    }
}
}

namespace Royalcms\Component\Foundation {
class AliasLoader
{
    protected $aliases;
    protected $registered = false;
    protected static $instance;
    private function __construct($aliases)
    {
        $this->aliases = $aliases;
    }
    public static function getInstance(array $aliases = [])
    {
        if (is_null(static::$instance)) {
            return static::$instance = new static($aliases);
        }
        $aliases = array_merge(static::$instance->getAliases(), $aliases);
        static::$instance->setAliases($aliases);
        return static::$instance;
    }
    public function load($alias)
    {
        if (isset($this->aliases[$alias])) {
            return class_alias($this->aliases[$alias], $alias);
        }
    }
    public function alias($class, $alias)
    {
        $this->aliases[$class] = $alias;
    }
    public function register()
    {
        if (!$this->registered) {
            $this->prependToLoaderStack();
            $this->registered = true;
        }
    }
    protected function prependToLoaderStack()
    {
        spl_autoload_register([$this, 'load'], true, true);
    }
    public function getAliases()
    {
        return $this->aliases;
    }
    public function setAliases(array $aliases)
    {
        $this->aliases = $aliases;
    }
    public function isRegistered()
    {
        return $this->registered;
    }
    public function setRegistered($value)
    {
        $this->registered = $value;
    }
    public static function setInstance($loader)
    {
        static::$instance = $loader;
    }
    private function __clone()
    {
    }
}
}

namespace Royalcms\Component\Foundation {
use Royalcms\Component\Filesystem\Filesystem;
use Royalcms\Component\Contracts\Foundation\Royalcms as RoyalcmsContract;
class ProviderRepository
{
    protected $royalcms;
    protected $files;
    protected $manifestPath;
    protected $default = array('when' => array());
    public function __construct(RoyalcmsContract $royalcms, Filesystem $files, $manifestPath)
    {
        $this->royalcms = $royalcms;
        $this->files = $files;
        $this->manifestPath = $manifestPath;
    }
    public function load(array $providers)
    {
        $manifest = $this->loadManifest();
        if ($this->shouldRecompile($manifest, $providers)) {
            $manifest = $this->compileManifest($providers);
        }
        foreach ($manifest['when'] as $provider => $events) {
            $this->registerLoadEvents($provider, $events);
        }
        foreach ($manifest['eager'] as $provider) {
            $this->royalcms->register($this->createProvider($provider));
        }
        $this->royalcms->addDeferredServices($manifest['deferred']);
    }
    protected function registerLoadEvents($provider, array $events)
    {
        if (count($events) < 1) {
            return;
        }
        $royalcms = $this->royalcms;
        $royalcms->make('events')->listen($events, function () use($royalcms, $provider) {
            $royalcms->register($provider);
        });
    }
    protected function compileManifest($providers)
    {
        $manifest = $this->freshManifest($providers);
        foreach ($providers as $provider) {
            $instance = $this->createProvider($provider);
            if ($instance->isDeferred()) {
                foreach ($instance->provides() as $service) {
                    $manifest['deferred'][$service] = $provider;
                }
                $manifest['when'][$provider] = $instance->when();
            } else {
                $manifest['eager'][] = $provider;
            }
        }
        return $this->writeManifest($manifest);
    }
    public function createProvider($provider)
    {
        return new $provider($this->royalcms);
    }
    public function shouldRecompile($manifest, $providers)
    {
        return is_null($manifest) || $manifest['providers'] != $providers;
    }
    public function loadManifest()
    {
        if ($this->files->exists($this->manifestPath)) {
            $manifest = json_decode($this->files->get($this->manifestPath), true);
            if ($manifest) {
                return array_merge($this->default, $manifest);
            }
        }
    }
    public function writeManifest($manifest)
    {
        $path = dirname($this->manifestPath);
        if (!$this->files->isDirectory($path)) {
            $this->files->makeDirectory($path, 0755, true);
        }
        $this->files->put($this->manifestPath, json_encode($manifest, JSON_PRETTY_PRINT));
        return array_merge($this->default, $manifest);
    }
    protected function freshManifest(array $providers)
    {
        return ['providers' => $providers, 'eager' => [], 'deferred' => []];
    }
}
}

namespace Royalcms\Component\Foundation {
use RC_Config;
use Royalcms\Component\Support\Format;
use RC_Hook;
use RC_Route;
class Uri extends RoyalcmsObject
{
    public static function url($pathinfo, $args = array())
    {
        if (preg_match("/^https?:\\/\\//i", $pathinfo)) {
            return $pathinfo;
        }
        if (strpos($pathinfo, '@') === 0) {
            $pathinfo = str_replace('@', RC_Config::get('system.admin_entrance') . '/', $pathinfo);
        } elseif (strpos($pathinfo, '#') === 0) {
            $pathinfo = str_replace('#', ROUTE_M . '/', $pathinfo);
        }
        $gets = self::build_params($pathinfo, $args);
        $urlType = RC_Config::get('system.url_mode');
        $url = '';
        switch ($urlType) {
            case 'pathinfo':
                foreach ($gets as $value) {
                    $url .= RC_Config::get('system.url_pathinfo_dli') . $value;
                }
                $url = str_replace(array("/" . RC_Config::get('route.module') . "/", "/" . RC_Config::get('route.controller') . "/", "/" . RC_Config::get('route.action') . "/"), "/", $url);
                $url = substr($url, 1);
                break;
            case 'normal':
                foreach ($gets as $k => $value) {
                    if ($k % 2) {
                        if (is_array($value)) {
                            $url .= '=' . implode('', $value);
                        } else {
                            $url .= '=' . $value;
                        }
                    } else {
                        $url .= '&' . $value;
                    }
                }
                $url = substr($url, 1);
                break;
        }
        if ($urlType == 'pathinfo' && RC_Config::get('system.url_pathinfo_suf')) {
            $pathinfo_suf = '.' . trim(RC_Config::get('system.url_pathinfo_suf'), '.');
        } else {
            $pathinfo_suf = '';
        }
        return self::build_root_url($pathinfo) . self::resolve_url($url) . $pathinfo_suf;
    }
    private static function build_params($pathinfo, $args = array())
    {
        $parseUrl = parse_url(trim($pathinfo, '/'));
        $path = trim($parseUrl['path'], '/');
        $vars = explode("/", $path);
        $data = array();
        switch (count($vars)) {
            case 3:
                $data[] = RC_Config::get('route.module');
                $data[] = array_shift($vars);
                $data[] = RC_Config::get('route.controller');
                $data[] = array_shift($vars);
                $data[] = RC_Config::get('route.action');
                $data[] = array_shift($vars);
                break;
            case 2:
                $data[] = RC_Config::get('route.module');
                $data[] = ROUTE_M;
                $data[] = RC_Config::get('route.controller');
                $data[] = array_shift($vars);
                $data[] = RC_Config::get('route.action');
                $data[] = array_shift($vars);
                break;
            case 1:
                $data[] = RC_Config::get('route.module');
                $data[] = ROUTE_M;
                $data[] = RC_Config::get('route.controller');
                $data[] = ROUTE_C;
                $data[] = RC_Config::get('route.action');
                $data[] = array_shift($vars);
                break;
            default:
                $data[] = RC_Config::get('route.module');
                $data[] = array_shift($vars);
                $data[] = RC_Config::get('route.controller');
                $data[] = array_shift($vars);
                $data[] = RC_Config::get('route.action');
                $data[] = array_shift($vars);
                if (is_array($vars)) {
                    foreach ($vars as $v) {
                        $data[] = $v;
                    }
                }
        }
        $gets = array_merge($data, self::build_gets($pathinfo, $args));
        return $gets;
    }
    private static function build_gets($pathinfo, $args = array())
    {
        if (is_string($args)) {
            $args = urldecode($args);
            parse_str($args, $args);
        }
        $parseUrl = parse_url(trim($pathinfo, '/'));
        if (isset($parseUrl['query'])) {
            parse_str($parseUrl['query'], $query);
            $args = array_merge($query, $args);
        }
        $gets = array();
        if (is_array($args)) {
            foreach ($args as $n => $q) {
                array_push($gets, $n);
                array_push($gets, $q);
            }
        }
        return $gets;
    }
    private static function build_root_url($pathinfo)
    {
        $end = strpos($pathinfo, '.php');
        if ($end) {
            $web = self::site_url() . '/' . substr($pathinfo, 0, $end + 4);
            $pathinfo = substr($pathinfo, $end + 4);
        } else {
            $web = self::site_url();
        }
        $urlType = RC_Config::get('system.url_mode');
        switch ($urlType) {
            case 'pathinfo':
                if (RC_Config::get('system.url_rewrite')) {
                    $root = $web . '/';
                } else {
                    $root = $web . '/index.php' . '/';
                }
                break;
            case 'normal':
                $root = $web . '/index.php' . '?';
                break;
        }
        if (RC_Config::get('system.url_rewrite')) {
            $root = preg_replace('/\\w+?\\.php\\/?/i', '', $root);
        }
        return $root;
    }
    private static function resolve_url($url)
    {
        $route = royalcms('default-router');
        $rules = $route->getRule();
        if (!$rules) {
            return $url;
        }
        foreach ($rules as $routeKey => $routeVal) {
            $routeKey = trim($routeKey);
            if (substr($routeKey, 0, 1) === '/') {
                $regGroup = array();
                preg_match_all('@\\(.*?\\)@i', $routeKey, $regGroup, PREG_PATTERN_ORDER);
                $searchRegExp = $routeVal;
                for ($i = 0, $total = count($regGroup[0]); $i < $total; $i++) {
                    $searchRegExp = str_replace('#' . ($i + 1), $regGroup[0][$i], $searchRegExp);
                }
                $urlArgs = array();
                preg_match_all("@" . $searchRegExp . "@i", $url, $urlArgs, PREG_SET_ORDER);
                if ($urlArgs) {
                    $routeUrl = trim(str_replace(array('/^', '$/'), '', $routeKey), '/');
                    foreach ($regGroup[0] as $k => $v) {
                        $v = preg_replace('@([\\*\\$\\(\\)\\+\\?\\[\\]\\{\\}\\\\])@', '\\\\$1', $v);
                        $routeUrl = preg_replace('@' . $v . '@', $urlArgs[0][$k + 1], $routeUrl, $count = 1);
                    }
                    return trim($routeUrl, '/');
                }
            } else {
                $routeGetVars = array();
                preg_match_all('/:([a-z]*)/i', $routeKey, $routeGetVars, PREG_PATTERN_ORDER);
                $getRouteUrl = $routeVal;
                switch (RC_Config::get('system.url_mode')) {
                    case 'pathinfo':
                        $getRouteUrl .= '/';
                        foreach ($routeGetVars[1] as $getK => $getV) {
                            $getRouteUrl .= $getV . '/(.*)/';
                        }
                        $getRouteUrl = '@' . trim($getRouteUrl, '/') . '@i';
                        break;
                    case 'normal':
                        $getRouteUrl .= '&';
                        foreach ($routeGetVars[1] as $getK => $getV) {
                            $getRouteUrl .= $getV . '=(.*)' . '&';
                        }
                        $getRouteUrl = '@' . trim($getRouteUrl, '&') . '@i';
                        break;
                }
                $getArgs = array();
                preg_match_all($getRouteUrl, $url, $getArgs, PREG_SET_ORDER);
                if ($getArgs) {
                    $newUrl = $routeKey;
                    foreach ($routeGetVars[0] as $rk => $getName) {
                        $newUrl = str_replace($getName, $getArgs[0][$rk + 1], $newUrl);
                    }
                    return $newUrl;
                }
            }
        }
        return $url;
    }
    public static function current_url()
    {
        $sys_protocal = isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443' ? 'https://' : 'http://';
        $php_self = $_SERVER['PHP_SELF'] ? safe_replace($_SERVER['PHP_SELF']) : safe_replace($_SERVER['SCRIPT_NAME']);
        $path_info = isset($_SERVER['PATH_INFO']) ? safe_replace($_SERVER['PATH_INFO']) : '';
        $relate_url = isset($_SERVER['REQUEST_URI']) ? safe_replace($_SERVER['REQUEST_URI']) : $php_self . (isset($_SERVER['QUERY_STRING']) ? '?' . safe_replace($_SERVER['QUERY_STRING']) : $path_info);
        $current_url = $sys_protocal . (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '') . $relate_url;
        return RC_Hook::apply_filters('set_current_url', $current_url);
    }
    public static function site_folder()
    {
        $php_self = $_SERVER['PHP_SELF'] ? safe_replace($_SERVER['PHP_SELF']) : safe_replace($_SERVER['SCRIPT_NAME']);
        if (RC_Config::has('site.site_folder')) {
            $site_folder = RC_Config::get('site.site_folder');
        } else {
            if (strpos($php_self, '/sites/') === 0) {
                $site_folder = str_replace('/sites/', '', dirname($php_self));
            } else {
                $site_folder = '';
            }
        }
        return $site_folder;
    }
    public static function web_path()
    {
        $sys_protocal = isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443' ? 'https://' : 'http://';
        $site_host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '';
        $php_self = $_SERVER['PHP_SELF'] ? safe_replace($_SERVER['PHP_SELF']) : safe_replace($_SERVER['SCRIPT_NAME']);
        if (RC_Config::has('site.web_path')) {
            $web_path = RC_Config::get('site.web_path');
        } else {
            $web_path = str_replace($sys_protocal . $site_host, '', dirname($sys_protocal . $site_host . $php_self)) . '/';
        }
        return $web_path;
    }
    public static function original_home_url()
    {
        $sys_protocal = isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443' ? 'https://' : 'http://';
        $site_host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '';
        $site_folder = self::site_folder();
        $site_url = self::original_site_url();
        if ($site_folder) {
            $home_url = str_replace('/sites/' . $site_folder, '', $site_url);
        } else {
            $home_url = $site_url;
        }
        return $home_url;
    }
    public static function original_site_url()
    {
        $sys_protocal = isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443' ? 'https://' : 'http://';
        $site_host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '';
        $site_folder = self::site_folder();
        $web_path = self::web_path();
        if ($site_folder) {
            if (strpos($web_path, 'sites')) {
                $site_url = $sys_protocal . $site_host . rtrim($web_path, '/');
            } else {
                if (RC_Config::get('site.use_sub_domain', false)) {
                    $site_url = $sys_protocal . $site_host . rtrim($web_path, '/');
                } else {
                    $site_url = $sys_protocal . $site_host . rtrim($web_path, '/') . '/sites/' . $site_folder;
                }
            }
        } else {
            $site_url = $sys_protocal . $site_host . rtrim($web_path, '/');
        }
        return $site_url;
    }
    public static function home_url($path = '', $scheme = null)
    {
        $orig_scheme = $scheme;
        $url = self::original_home_url();
        if (!in_array($scheme, array('http', 'https', 'relative'))) {
            if (is_ssl()) {
                $scheme = 'https';
            } else {
                $scheme = parse_url($url, PHP_URL_SCHEME);
            }
        }
        $url = self::set_url_scheme($url, $scheme);
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('home_url', $url, $path, $orig_scheme);
    }
    public static function set_url_scheme($url, $scheme = null)
    {
        $orig_scheme = $scheme;
        if (!in_array($scheme, array('http', 'https', 'relative'))) {
            $scheme = is_ssl() ? 'https' : 'http';
        }
        $url = trim($url);
        if (substr($url, 0, 2) === '//') {
            $url = 'http:' . $url;
        }
        if ('relative' == $scheme) {
            $url = ltrim(preg_replace('#^\\w+://[^/]*#', '', $url));
            if ($url !== '' && $url[0] === '/') {
                $url = '/' . ltrim($url, "/ \t\n\r \v");
            }
        } else {
            $url = preg_replace('#^\\w+://#', $scheme . '://', $url);
        }
        return RC_Hook::apply_filters('set_url_scheme', $url, $scheme, $orig_scheme);
    }
    public static function site_url($path = '', $scheme = null)
    {
        $site_folder = self::site_folder();
        if ($site_folder) {
            $site_url = self::original_site_url();
        } else {
            $site_url = self::original_home_url();
        }
        $url = self::set_url_scheme($site_url, $scheme);
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('site_url', $url, $path, $scheme);
    }
    public static function admin_url($path = '', $scheme = 'admin')
    {
        if (self::site_folder() && Loader::exists_site_system()) {
            $url = self::site_url('content/system/', $scheme);
        } else {
            $url = self::home_url('content/system/', $scheme);
        }
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('admin_url', $url, $path);
    }
    public static function system_static_url($path = '', $scheme = 'admin')
    {
        if (self::site_folder() && Loader::exists_site_system()) {
            $url = self::site_url('content/system/statics/', $scheme);
        } else {
            $url = self::home_url('content/system/statics/', $scheme);
        }
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('system_static_url', $url, $path);
    }
    public static function home_content_url($path = '')
    {
        $url = self::set_url_scheme(Uri::home_url() . '/content');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('home_content_url', $url, $path);
    }
    public static function content_url($path = '')
    {
        $url = self::set_url_scheme(SITE_CONTENT_URL);
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('content_url', $url, $path);
    }
    public static function vendor_url($path = '')
    {
        $url = self::set_url_scheme(self::home_url() . '/vendor');
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('vendor_url', $url, $path);
    }
    public static function admin_path($path = '')
    {
        $system_root = SITE_SYSTEM_PATH;
        if ($path && is_string($path)) {
            $system_root = rtrim($system_root, DIRECTORY_SEPARATOR);
            $system_root .= DIRECTORY_SEPARATOR . ltrim($path, DIRECTORY_SEPARATOR);
        }
        return RC_Hook::apply_filters('admin_path', $system_root, $path);
    }
    public static function add_query_arg()
    {
        $ret = '';
        $args = func_get_args();
        if (is_array($args[0])) {
            if (count($args) < 2 || false === $args[1]) {
                $uri = $_SERVER['REQUEST_URI'];
            } else {
                $uri = $args[1];
            }
        } else {
            if (count($args) < 3 || false === $args[2]) {
                $uri = $_SERVER['REQUEST_URI'];
            } else {
                $uri = $args[2];
            }
        }
        $frag = strstr($uri, '#');
        if ($frag) {
            $uri = substr($uri, 0, -strlen($frag));
        } else {
            $frag = '';
        }
        if (0 === stripos($uri, 'http://')) {
            $protocol = 'http://';
            $uri = substr($uri, 7);
        } elseif (0 === stripos($uri, 'https://')) {
            $protocol = 'https://';
            $uri = substr($uri, 8);
        } else {
            $protocol = '';
        }
        if (strpos($uri, '?') !== false) {
            list($base, $query) = explode('?', $uri, 2);
            $base .= '?';
        } elseif ($protocol || strpos($uri, '=') === false) {
            $base = $uri . '?';
            $query = '';
        } else {
            $base = '';
            $query = $uri;
        }
        rc_parse_str($query, $qs);
        $qs = Format::urlencode_deep($qs);
        if (is_array($args[0])) {
            $kayvees = $args[0];
            $qs = array_merge($qs, $kayvees);
        } else {
            $qs[$args[0]] = $args[1];
        }
        foreach ($qs as $k => $v) {
            if ($v === false) {
                unset($qs[$k]);
            }
        }
        $ret = self::build_query($qs);
        $ret = trim($ret, '?');
        $ret = preg_replace('#=(&|$)#', '$1', $ret);
        $ret = $protocol . $base . $ret . $frag;
        $ret = rtrim($ret, '?');
        return $ret;
    }
    public static function build_query($data)
    {
        return self::_http_build_query($data, null, '&', '', false);
    }
    public static function _http_build_query($data, $prefix = null, $sep = null, $key = '', $urlencode = true)
    {
        $ret = array();
        foreach ((array) $data as $k => $v) {
            if ($urlencode) {
                $k = urlencode($k);
            }
            if (is_int($k) && $prefix != null) {
                $k = $prefix . $k;
            }
            if (!empty($key)) {
                $k = $key . '%5B' . $k . '%5D';
            }
            if ($v === null) {
                continue;
            } elseif ($v === FALSE) {
                $v = '0';
            }
            if (is_array($v) || is_object($v)) {
                array_push($ret, self::_http_build_query($v, '', $sep, $k, $urlencode));
            } elseif ($urlencode) {
                array_push($ret, $k . '=' . urlencode($v));
            } else {
                array_push($ret, $k . '=' . $v);
            }
        }
        if (null === $sep) {
            $sep = ini_get('arg_separator.output');
        }
        return implode($sep, $ret);
    }
}
}

namespace Royalcms\Component\Foundation {
use Royalcms\Component\Support\Facades\Config;
use RC_Hook;
use Royalcms\Component\Support\Facades\Cache as RC_Cache;
use Royalcms\Component\Support\Format;
use Royalcms\Component\Support\Facades\File as RC_File;
use RC_Locale;
class Theme extends RoyalcmsObject
{
    public static function get_theme_data($theme_file, $markup = true, $translate = true)
    {
        $default_headers = array('Name' => 'Template Name', 'TemplateURI' => 'Template URI', 'Description' => 'Description', 'Version' => 'Version', 'Author' => 'Author', 'AuthorURI' => 'Author URI', 'TextDomain' => 'Text Domain', 'DomainPath' => 'Domain Path', 'Logo' => 'Logo filename', 'TemplateType' => 'Template Type', 'Color' => 'Color');
        $theme_data = RC_File::get_file_data($theme_file, $default_headers, 'theme');
        if ($markup || $translate) {
            $theme_data = self::_get_theme_data_markup_translate($theme_file, $theme_data, $markup, $translate);
        } else {
            $theme_data['Title'] = $theme_data['Name'];
            $theme_data['AuthorName'] = $theme_data['Author'];
        }
        return $theme_data;
    }
    public static function _get_theme_data_markup_translate($theme_file, $theme_data, $markup = true, $translate = true)
    {
        if ($translate) {
            if (($textdomain = $theme_data['TextDomain']) == true) {
                if ($theme_data['DomainPath']) {
                    RC_Locale::load_plugin_textdomain($textdomain, false, dirname($theme_file) . $theme_data['DomainPath']);
                } else {
                    RC_Locale::load_plugin_textdomain($textdomain, false, dirname($theme_file));
                }
            }
            if ($textdomain) {
                foreach (array('Name', 'TemplateURI', 'Description', 'Author', 'AuthorURI', 'Version') as $field) {
                    $theme_data[$field] = RC_Locale::translate($theme_data[$field], $textdomain);
                }
            }
        }
        $allowed_tags = $allowed_tags_in_links = array('abbr' => array('title' => true), 'acronym' => array('title' => true), 'code' => true, 'em' => true, 'strong' => true);
        $allowed_tags['a'] = array('href' => true, 'title' => true);
        $theme_data['Name'] = Kses::kses($theme_data['Name'], $allowed_tags_in_links);
        $theme_data['Author'] = Kses::kses($theme_data['Author'], $allowed_tags);
        $theme_data['Description'] = Kses::kses($theme_data['Description'], $allowed_tags);
        $theme_data['Version'] = Kses::kses($theme_data['Version'], $allowed_tags);
        $theme_data['TemplateURI'] = Format::esc_url($theme_data['TemplateURI']);
        $theme_data['AuthorURI'] = Format::esc_url($theme_data['AuthorURI']);
        $theme_data['Title'] = $theme_data['Name'];
        $theme_data['AuthorName'] = $theme_data['Author'];
        if ($markup) {
            if ($theme_data['TemplateURI'] && $theme_data['Name']) {
                $theme_data['Title'] = '<a href="' . $theme_data['TemplateURI'] . '" title="' . esc_attr__('Visit theme homepage') . '">' . $theme_data['Name'] . '</a>';
            }
            if ($theme_data['AuthorURI'] && $theme_data['Author']) {
                $theme_data['Author'] = '<a href="' . $theme_data['AuthorURI'] . '" title="' . esc_attr__('Visit author homepage') . '">' . $theme_data['Author'] . '</a>';
            }
            $theme_data['Description'] = Format::texturize($theme_data['Description']);
            if ($theme_data['Author']) {
                $theme_data['Description'] .= ' <cite>' . sprintf(__('By %s.'), $theme_data['Author']) . '</cite>';
            }
        }
        return $theme_data;
    }
    private static $theme_directories = array();
    public static function get_theme_root_uri($template = false, $theme_root = false)
    {
        if ($template && !$theme_root) {
            $theme_roots = array();
        }
        $theme_roots = self::get_theme_roots();
        if (is_array($theme_roots) && !empty($theme_roots[$template])) {
            $theme_root = $theme_roots[$template];
        }
        if ($template && $theme_root) {
            if (in_array($theme_root, self::$theme_directories)) {
                if (0 === strpos($theme_root, SITE_CONTENT_PATH)) {
                    $theme_root_uri = Uri::content_url(str_replace(SITE_CONTENT_PATH, '', $theme_root));
                } elseif (0 === strpos($theme_root, SITE_PATH)) {
                    $theme_root_uri = Uri::site_url(str_replace(SITE_PATH, '', $theme_root));
                } elseif (0 === strpos($theme_root, SITE_PLUGIN_PATH)) {
                    $theme_root_uri = Plugin::plugins_url(basename($theme_root), $theme_root);
                } else {
                    $theme_root_uri = $theme_root;
                }
            } else {
                $theme_root_uri = Uri::content_url($theme_root);
            }
        } else {
            $theme_root_uri = Uri::content_url('themes');
        }
        return RC_Hook::apply_filters('theme_root_uri', $theme_root_uri, Uri::site_url(), $template);
    }
    public static function get_theme_root($template = false)
    {
        $theme_roots = self::get_theme_roots();
        if (is_array($theme_roots) && !empty($theme_roots[$template])) {
            $theme_root = $theme_roots[$template];
        } else {
            $theme_root = null;
        }
        if ($template && $theme_root) {
            if (!in_array($theme_root, self::$theme_directories)) {
                $theme_root = SITE_CONTENT_PATH . $theme_root;
            }
        } else {
            $theme_root = SITE_CONTENT_PATH . 'themes';
        }
        return RC_Hook::apply_filters('theme_root', $theme_root);
    }
    public static function get_theme_roots()
    {
        if (count(self::$theme_directories) <= 1) {
            return '/themes';
        }
        $theme_roots = RC_Cache::app_cache_get('theme_roots', 'system');
        if (false === $theme_roots) {
            self::search_theme_directories(true);
            $theme_roots = RC_Cache::app_cache_get('theme_roots', 'system');
        }
        return $theme_roots;
    }
    public static function get_template_directory_uri()
    {
        $template = str_replace('%2F', '/', rawurlencode(self::get_template()));
        $theme_root_uri = self::get_theme_root_uri($template);
        $template_dir_uri = "{$theme_root_uri}/{$template}";
        return RC_Hook::apply_filters('template_directory_uri', $template_dir_uri, $template, $theme_root_uri);
    }
    public static function get_template_directory()
    {
        $template = self::get_template();
        $theme_root = self::get_theme_root($template);
        $template_dir = $theme_root . DIRECTORY_SEPARATOR . $template;
        return RC_Hook::apply_filters('template_directory', $template_dir, $template, $theme_root);
    }
    public static function get_template()
    {
        return RC_Hook::apply_filters('template', Config::get('system.tpl_style'));
    }
    private static function search_theme_directories($force = false)
    {
        if (empty(self::$theme_directories)) {
            return false;
        }
        static $found_themes;
        if (!$force && isset($found_themes)) {
            return $found_themes;
        }
        $found_themes = array();
        foreach (self::$theme_directories as $theme_root) {
            if (0 === strpos($theme_root, SITE_CONTENT_PATH)) {
                $relative_theme_roots[str_replace(SITE_CONTENT_PATH, '', $theme_root)] = $theme_root;
            } else {
                $relative_theme_roots[$theme_root] = $theme_root;
            }
        }
        foreach (self::$theme_directories as $theme_root) {
            $dirs = scandir($theme_root);
            if (!$dirs) {
                trigger_error("{$theme_root} is not readable", E_USER_NOTICE);
                continue;
            }
            foreach ($dirs as $dir) {
                if (!is_dir($theme_root . '/' . $dir) || $dir[0] == '.' || $dir == 'CVS') {
                    continue;
                }
                if (file_exists($theme_root . '/' . $dir . '/style.css')) {
                    $found_themes[$dir] = array('theme_file' => $dir . '/style.css', 'theme_root' => $theme_root);
                } else {
                    $found_theme = false;
                    $sub_dirs = scandir($theme_root . '/' . $dir);
                    if (!$sub_dirs) {
                        trigger_error("{$theme_root}/{$dir} is not readable", E_USER_NOTICE);
                        continue;
                    }
                    foreach ($sub_dirs as $sub_dir) {
                        if (!is_dir($theme_root . '/' . $dir . '/' . $sub_dir) || $dir[0] == '.' || $dir == 'CVS') {
                            continue;
                        }
                        if (!file_exists($theme_root . '/' . $dir . '/' . $sub_dir . '/style.css')) {
                            continue;
                        }
                        $found_themes[$dir . '/' . $sub_dir] = array('theme_file' => $dir . '/' . $sub_dir . '/style.css', 'theme_root' => $theme_root);
                        $found_theme = true;
                    }
                    if (!$found_theme) {
                        $found_themes[$dir] = array('theme_file' => $dir . '/style.css', 'theme_root' => $theme_root);
                    }
                }
            }
        }
        asort($found_themes);
        $theme_roots = array();
        $relative_theme_roots = array_flip($relative_theme_roots);
        foreach ($found_themes as $theme_dir => $theme_data) {
            $theme_roots[$theme_dir] = $relative_theme_roots[$theme_data['theme_root']];
        }
        RC_Cache::app_cache_set('theme_roots', $theme_roots, 'system');
        return $found_themes;
    }
    public static function register_theme_directory($directory)
    {
        if (!file_exists($directory)) {
            $directory = SITE_CONTENT_PATH . $directory;
            if (!file_exists($directory)) {
                return false;
            }
        }
        self::$theme_directories[] = $directory;
        return true;
    }
}
}

namespace Royalcms\Component\Support {
use BadMethodCallException;
use ReflectionClass;
abstract class ServiceProvider
{
    protected $royalcms;
    protected $defer = false;
    protected static $publishes = [];
    protected static $publishGroups = [];
    public function __construct($royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public abstract function register();
    protected function mergeConfigFrom($path, $key)
    {
        $config = $this->royalcms['config']->get($key, []);
        $this->royalcms['config']->set($key, array_merge(require $path, $config));
    }
    protected function loadRoutesFrom($path)
    {
        if (!$this->royalcms->routesAreCached()) {
            require $path;
        }
    }
    protected function loadViewsFrom($path, $namespace)
    {
        if (is_dir($appPath = $this->royalcms->basePath() . '/resources/views/vendor/' . $namespace)) {
            $this->royalcms['view']->addNamespace($namespace, $appPath);
        }
        $this->royalcms['view']->addNamespace($namespace, $path);
    }
    protected function loadTranslationsFrom($path, $namespace)
    {
        $this->royalcms['translator']->addNamespace($namespace, $path);
    }
    protected function publishes(array $paths, $group = null)
    {
        $class = get_class($this);
        if (!array_key_exists($class, static::$publishes)) {
            static::$publishes[$class] = [];
        }
        static::$publishes[$class] = array_merge(static::$publishes[$class], $paths);
        if ($group) {
            if (!array_key_exists($group, static::$publishGroups)) {
                static::$publishGroups[$group] = [];
            }
            static::$publishGroups[$group] = array_merge(static::$publishGroups[$group], $paths);
        }
    }
    public static function pathsToPublish($provider = null, $group = null)
    {
        if ($provider && $group) {
            if (empty(static::$publishes[$provider]) || empty(static::$publishGroups[$group])) {
                return [];
            }
            return array_intersect(static::$publishes[$provider], static::$publishGroups[$group]);
        }
        if ($group && array_key_exists($group, static::$publishGroups)) {
            return static::$publishGroups[$group];
        }
        if ($provider && array_key_exists($provider, static::$publishes)) {
            return static::$publishes[$provider];
        }
        if ($group || $provider) {
            return [];
        }
        $paths = [];
        foreach (static::$publishes as $class => $publish) {
            $paths = array_merge($paths, $publish);
        }
        return $paths;
    }
    public function package($package, $namespace = null, $path = null)
    {
        $namespace = $this->getPackageNamespace($package, $namespace);
        $path = $path ?: $this->guessPackagePath($package);
        $config = $path . '/config';
        if ($this->royalcms['files']->isDirectory($config)) {
            $this->royalcms['config']->package($package, $config, $namespace);
        }
        $lang = $path . '/lang';
        if ($this->royalcms['files']->isDirectory($lang)) {
            $this->royalcms['translator']->addNamespace($namespace, $lang);
        }
        $appView = $this->getAppViewPath($package);
        if ($this->royalcms['files']->isDirectory($appView)) {
            $this->royalcms['view']->addNamespace($namespace, $appView);
        }
        $view = $path . '/views';
        if ($this->royalcms['files']->isDirectory($view)) {
            $this->royalcms['view']->addNamespace($namespace, $view);
        }
    }
    public function guessPackagePath($package = null)
    {
        $path = $this->royalcms['path.vendor'] . '/' . $package;
        if ($this->royalcms['files']->isDirectory($path)) {
            return $path;
        } else {
            $path = with(new ReflectionClass($this))->getFileName();
            return realpath(dirname($path) . '/../../../');
        }
    }
    public static function guessPackageClassPath($package = null)
    {
        if (strpos($package, 'royalcms/', 0) !== false) {
            $path = base_path() . '/vendor/' . $package . '/Royalcms/Component/' . self::normalizeName(str_replace('royalcms/', '', $package));
            return $path;
        } else {
            $path = base_path() . '/vendor/' . $package;
            return $path;
        }
    }
    protected static function normalizeName($name)
    {
        $name = implode('', array_map('ucfirst', explode('-', $name)));
        $name = implode('', array_map('ucfirst', explode('_', $name)));
        $name = implode('\\', array_map('ucfirst', explode('/', $name)));
        return $name;
    }
    protected function getPackageNamespace($package, $namespace)
    {
        if (is_null($namespace)) {
            list($vendor, $namespace) = explode('/', $package);
        }
        return $namespace;
    }
    protected function getAppViewPath($package)
    {
        return $this->royalcms['path'] . "/views/packages/{$package}";
    }
    public function commands($commands)
    {
        $commands = is_array($commands) ? $commands : func_get_args();
        $events = $this->royalcms['events'];
        $events->listen('royalcms.start', function ($artisan) use($commands) {
            $artisan->resolveCommands($commands);
        });
    }
    public function provides()
    {
        return [];
    }
    public function when()
    {
        return [];
    }
    public function isDeferred()
    {
        return $this->defer;
    }
    public static function compiles()
    {
        return [];
    }
    public function __call($method, $parameters)
    {
        if ($method == 'boot') {
            return;
        }
        throw new BadMethodCallException("Call to undefined method [{$method}]");
    }
}
}

namespace Royalcms\Component\Support {
class AggregateServiceProvider extends ServiceProvider
{
    protected $providers = [];
    protected $instances = [];
    public function register()
    {
        $this->instances = [];
        foreach ($this->providers as $provider) {
            $this->instances[] = $this->royalcms->register($provider);
        }
    }
    public function provides()
    {
        $provides = [];
        foreach ($this->providers as $provider) {
            $instance = $this->royalcms->resolveProviderClass($provider);
            $provides = array_merge($provides, $instance->provides());
        }
        return $provides;
    }
}
}

namespace Royalcms\Component\Support\Traits {
use Closure;
use BadMethodCallException;
trait Macroable
{
    protected static $macros = [];
    public static function macro($name, callable $macro)
    {
        static::$macros[$name] = $macro;
    }
    public static function hasMacro($name)
    {
        return isset(static::$macros[$name]);
    }
    public static function __callStatic($method, $parameters)
    {
        if (static::hasMacro($method)) {
            if (static::$macros[$method] instanceof Closure) {
                return call_user_func_array(Closure::bind(static::$macros[$method], null, get_called_class()), $parameters);
            } else {
                return call_user_func_array(static::$macros[$method], $parameters);
            }
        }
        throw new BadMethodCallException("Method {$method} does not exist.");
    }
    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            if (static::$macros[$method] instanceof Closure) {
                return call_user_func_array(static::$macros[$method]->bindTo($this, get_class($this)), $parameters);
            } else {
                return call_user_func_array(static::$macros[$method], $parameters);
            }
        }
        throw new BadMethodCallException("Method {$method} does not exist.");
    }
}
}

namespace Royalcms\Component\Support {
use ArrayAccess;
use InvalidArgumentException;
use Royalcms\Component\Support\Traits\Macroable;
class Arr
{
    use Macroable;
    use ArrayHelperTrait;
    public static function accessible($value)
    {
        return is_array($value) || $value instanceof ArrayAccess;
    }
    public static function add($array, $key, $value)
    {
        if (is_null(static::get($array, $key))) {
            static::set($array, $key, $value);
        }
        return $array;
    }
    public static function build($array, callable $callback)
    {
        $results = [];
        foreach ($array as $key => $value) {
            list($innerKey, $innerValue) = call_user_func($callback, $key, $value);
            $results[$innerKey] = $innerValue;
        }
        return $results;
    }
    public static function collapse($array)
    {
        $results = [];
        foreach ($array as $values) {
            if ($values instanceof Collection) {
                $values = $values->all();
            } elseif (!is_array($values)) {
                continue;
            }
            $results = array_merge($results, $values);
        }
        return $results;
    }
    public static function crossJoin($arrays)
    {
        $arrays = func_get_args();
        $results = [[]];
        foreach ($arrays as $index => $array) {
            $append = [];
            foreach ($results as $product) {
                foreach ($array as $item) {
                    $product[$index] = $item;
                    $append[] = $product;
                }
            }
            $results = $append;
        }
        return $results;
    }
    public static function divide($array)
    {
        return [array_keys($array), array_values($array)];
    }
    public static function dot($array, $prepend = '')
    {
        $results = [];
        foreach ($array as $key => $value) {
            if (is_array($value) && !empty($value)) {
                $results = array_merge($results, static::dot($value, $prepend . $key . '.'));
            } else {
                $results[$prepend . $key] = $value;
            }
        }
        return $results;
    }
    public static function except($array, $keys)
    {
        static::forget($array, $keys);
        return $array;
    }
    public static function exists($array, $key)
    {
        if ($array instanceof ArrayAccess) {
            return $array->offsetExists($key);
        }
        return array_key_exists($key, $array);
    }
    public static function fetch($array, $key)
    {
        foreach (explode('.', $key) as $segment) {
            $results = [];
            foreach ($array as $value) {
                if (array_key_exists($segment, $value = (array) $value)) {
                    $results[] = $value[$segment];
                }
            }
            $array = array_values($results);
        }
        return $array;
    }
    public static function first($array, callable $callback = null, $default = null)
    {
        if (is_null($callback)) {
            if (empty($array)) {
                return value($default);
            }
            foreach ($array as $item) {
                return $item;
            }
        }
        foreach ($array as $key => $value) {
            if (call_user_func($callback, $value, $key)) {
                return $value;
            }
        }
        return value($default);
    }
    public static function last($array, callable $callback = null, $default = null)
    {
        if (is_null($callback)) {
            return empty($array) ? value($default) : end($array);
        }
        return static::first(array_reverse($array, true), $callback, $default);
    }
    public static function flatten($array, $depth = INF)
    {
        return array_reduce($array, function ($result, $item) use($depth) {
            $item = $item instanceof Collection ? $item->all() : $item;
            if (!is_array($item)) {
                return array_merge($result, [$item]);
            } elseif ($depth === 1) {
                return array_merge($result, array_values($item));
            } else {
                return array_merge($result, static::flatten($item, $depth - 1));
            }
        }, []);
    }
    public static function forget(&$array, $keys)
    {
        $original =& $array;
        $keys = (array) $keys;
        if (count($keys) === 0) {
            return;
        }
        foreach ($keys as $key) {
            if (static::exists($array, $key)) {
                unset($array[$key]);
                continue;
            }
            $parts = explode('.', $key);
            $array =& $original;
            while (count($parts) > 1) {
                $part = array_shift($parts);
                if (isset($array[$part]) && is_array($array[$part])) {
                    $array =& $array[$part];
                } else {
                    continue 2;
                }
            }
            unset($array[array_shift($parts)]);
        }
    }
    public static function get($array, $key, $default = null)
    {
        if (!static::accessible($array)) {
            return value($default);
        }
        if (is_null($key)) {
            return $array;
        }
        if (static::exists($array, $key)) {
            return $array[$key];
        }
        if (strpos($key, '.') === false) {
            return isset($array[$key]) ? $array[$key] : value($default);
        }
        foreach (explode('.', $key) as $segment) {
            if (static::accessible($array) && static::exists($array, $segment)) {
                $array = $array[$segment];
            } else {
                return value($default);
            }
        }
        return $array;
    }
    public static function has($array, $keys)
    {
        if (is_null($keys)) {
            return false;
        }
        $keys = (array) $keys;
        if (!$array) {
            return false;
        }
        if ($keys === []) {
            return false;
        }
        foreach ($keys as $key) {
            $subKeyArray = $array;
            if (static::exists($array, $key)) {
                continue;
            }
            foreach (explode('.', $key) as $segment) {
                if (static::accessible($subKeyArray) && static::exists($subKeyArray, $segment)) {
                    $subKeyArray = $subKeyArray[$segment];
                } else {
                    return false;
                }
            }
        }
        return true;
    }
    public static function isAssoc(array $array)
    {
        $keys = array_keys($array);
        return array_keys($keys) !== $keys;
    }
    public static function only($array, $keys)
    {
        return array_intersect_key($array, array_flip((array) $keys));
    }
    public static function pluck($array, $value, $key = null)
    {
        $results = [];
        list($value, $key) = static::explodePluckParameters($value, $key);
        foreach ($array as $item) {
            $itemValue = data_get($item, $value);
            if (is_null($key)) {
                $results[] = $itemValue;
            } else {
                $itemKey = data_get($item, $key);
                if (is_object($itemKey) && method_exists($itemKey, '__toString')) {
                    $itemKey = (string) $itemKey;
                }
                $results[$itemKey] = $itemValue;
            }
        }
        return $results;
    }
    protected static function explodePluckParameters($value, $key)
    {
        $value = is_string($value) ? explode('.', $value) : $value;
        $key = is_null($key) || is_array($key) ? $key : explode('.', $key);
        return [$value, $key];
    }
    public static function prepend($array, $value, $key = null)
    {
        if (is_null($key)) {
            array_unshift($array, $value);
        } else {
            $array = [$key => $value] + $array;
        }
        return $array;
    }
    public static function pull(&$array, $key, $default = null)
    {
        $value = static::get($array, $key, $default);
        static::forget($array, $key);
        return $value;
    }
    public static function random($array, $number = null)
    {
        $requested = is_null($number) ? 1 : $number;
        $count = count($array);
        if ($requested > $count) {
            throw new InvalidArgumentException("You requested {$requested} items, but there are only {$count} items available.");
        }
        if (is_null($number)) {
            return $array[array_rand($array)];
        }
        if ((int) $number === 0) {
            return [];
        }
        $keys = array_rand($array, $number);
        $results = [];
        foreach ((array) $keys as $key) {
            $results[] = $array[$key];
        }
        return $results;
    }
    public static function set(&$array, $key, $value)
    {
        if (is_null($key)) {
            return $array = $value;
        }
        $keys = explode('.', $key);
        while (count($keys) > 1) {
            $key = array_shift($keys);
            if (!isset($array[$key]) || !is_array($array[$key])) {
                $array[$key] = [];
            }
            $array =& $array[$key];
        }
        $array[array_shift($keys)] = $value;
        return $array;
    }
    public static function shuffle($array)
    {
        shuffle($array);
        return $array;
    }
    public static function sort($array, $callback)
    {
        return Collection::make($array)->sortBy($callback)->all();
    }
    public static function sortRecursive($array)
    {
        foreach ($array as &$value) {
            if (is_array($value)) {
                $value = static::sortRecursive($value);
            }
        }
        if (static::isAssoc($array)) {
            ksort($array);
        } else {
            sort($array);
        }
        return $array;
    }
    public static function where($array, callable $callback)
    {
        return array_filter($array, $callback);
    }
    public static function wrap($value)
    {
        return !is_array($value) ? [$value] : $value;
    }
}
}

namespace Royalcms\Component\Support {
use Stringy\StaticStringy;
use Royalcms\Component\Support\Traits\Macroable;
class Str
{
    use Macroable;
    use StrHelperTrait;
    protected static $snakeCache = [];
    protected static $camelCache = [];
    protected static $studlyCache = [];
    public static function after($subject, $search)
    {
        return $search === '' ? $subject : array_reverse(explode($search, $subject, 2))[0];
    }
    public static function ascii($value, $language = 'en')
    {
        $languageSpecific = static::languageSpecificCharsArray($language);
        if (!is_null($languageSpecific)) {
            $value = str_replace($languageSpecific[0], $languageSpecific[1], $value);
        }
        foreach (static::charsArray() as $key => $val) {
            $value = str_replace($val, $key, $value);
        }
        return preg_replace('/[^\\x20-\\x7E]/u', '', $value);
    }
    public static function before($subject, $search)
    {
        return $search === '' ? $subject : explode($search, $subject)[0];
    }
    public static function camel($value)
    {
        if (isset(static::$camelCache[$value])) {
            return static::$camelCache[$value];
        }
        return static::$camelCache[$value] = lcfirst(static::studly($value));
    }
    public static function contains($haystack, $needles)
    {
        foreach ((array) $needles as $needle) {
            if ($needle != '' && mb_strpos($haystack, $needle) !== false) {
                return true;
            }
        }
        return false;
    }
    public static function endsWith($haystack, $needles)
    {
        foreach ((array) $needles as $needle) {
            if (substr($haystack, -strlen($needle)) === (string) $needle) {
                return true;
            }
        }
        return false;
    }
    public static function finish($value, $cap)
    {
        $quoted = preg_quote($cap, '/');
        return preg_replace('/(?:' . $quoted . ')+$/u', '', $value) . $cap;
    }
    public static function is($pattern, $value)
    {
        $patterns = is_array($pattern) ? $pattern : (array) $pattern;
        if (empty($patterns)) {
            return false;
        }
        foreach ($patterns as $pattern) {
            if ($pattern == $value) {
                return true;
            }
            $pattern = preg_quote($pattern, '#');
            $pattern = str_replace('\\*', '.*', $pattern);
            if (preg_match('#^' . $pattern . '\\z#u', $value) === 1) {
                return true;
            }
        }
        return false;
    }
    public static function kebab($value)
    {
        return static::snake($value, '-');
    }
    public static function length($value, $encoding = null)
    {
        if ($encoding) {
            return mb_strlen($value, $encoding);
        }
        return mb_strlen($value);
    }
    public static function limit($value, $limit = 100, $end = '...')
    {
        if (mb_strwidth($value, 'UTF-8') <= $limit) {
            return $value;
        }
        return rtrim(mb_strimwidth($value, 0, $limit, '', 'UTF-8')) . $end;
    }
    public static function lower($value)
    {
        return mb_strtolower($value, 'UTF-8');
    }
    public static function words($value, $words = 100, $end = '...')
    {
        preg_match('/^\\s*+(?:\\S++\\s*+){1,' . $words . '}/u', $value, $matches);
        if (!isset($matches[0]) || static::length($value) === static::length($matches[0])) {
            return $value;
        }
        return rtrim($matches[0]) . $end;
    }
    public static function parseCallback($callback, $default)
    {
        return static::contains($callback, '@') ? explode('@', $callback, 2) : [$callback, $default];
    }
    public static function plural($value, $count = 2)
    {
        return Pluralizer::plural($value, $count);
    }
    public static function random($length = 16)
    {
        $string = '';
        while (($len = static::length($string)) < $length) {
            $size = $length - $len;
            $bytes = static::randomBytes($size);
            $string .= static::substr(str_replace(['/', '+', '='], '', base64_encode($bytes)), 0, $size);
        }
        return $string;
    }
    public static function randomBytes($length = 16)
    {
        return random_bytes($length);
    }
    public static function quickRandom($length = 16)
    {
        $pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        return static::substr(str_shuffle(str_repeat($pool, $length)), 0, $length);
    }
    public static function replaceArray($search, array $replace, $subject)
    {
        foreach ($replace as $value) {
            $subject = static::replaceFirst($search, $value, $subject);
        }
        return $subject;
    }
    public static function replaceFirst($search, $replace, $subject)
    {
        if ($search == '') {
            return $subject;
        }
        $position = strpos($subject, $search);
        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }
        return $subject;
    }
    public static function replaceLast($search, $replace, $subject)
    {
        $position = strrpos($subject, $search);
        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }
        return $subject;
    }
    public static function start($value, $prefix)
    {
        $quoted = preg_quote($prefix, '/');
        return $prefix . preg_replace('/^(?:' . $quoted . ')+/u', '', $value);
    }
    public static function equals($knownString, $userInput)
    {
        if (!is_string($knownString)) {
            $knownString = (string) $knownString;
        }
        if (!is_string($userInput)) {
            $userInput = (string) $userInput;
        }
        if (function_exists('hash_equals')) {
            return hash_equals($knownString, $userInput);
        }
        $knownLength = mb_strlen($knownString, '8bit');
        if (mb_strlen($userInput, '8bit') !== $knownLength) {
            return false;
        }
        $result = 0;
        for ($i = 0; $i < $knownLength; ++$i) {
            $result |= ord($knownString[$i]) ^ ord($userInput[$i]);
        }
        return 0 === $result;
    }
    public static function upper($value)
    {
        return mb_strtoupper($value, 'UTF-8');
    }
    public static function title($value)
    {
        return mb_convert_case($value, MB_CASE_TITLE, 'UTF-8');
    }
    public static function singular($value)
    {
        return Pluralizer::singular($value);
    }
    public static function slug($title, $separator = '-')
    {
        $title = static::ascii($title);
        $flip = $separator == '-' ? '_' : '-';
        $title = preg_replace('![' . preg_quote($flip) . ']+!u', $separator, $title);
        $title = preg_replace('![^' . preg_quote($separator) . '\\pL\\pN\\s]+!u', '', mb_strtolower($title));
        $title = preg_replace('![' . preg_quote($separator) . '\\s]+!u', $separator, $title);
        return trim($title, $separator);
    }
    public static function snake($value, $delimiter = '_')
    {
        $key = $value;
        if (isset(static::$snakeCache[$key][$delimiter])) {
            return static::$snakeCache[$key][$delimiter];
        }
        if (!ctype_lower($value)) {
            $value = preg_replace('/\\s+/u', '', $value);
            $value = static::lower(preg_replace('/(.)(?=[A-Z])/u', '$1' . $delimiter, $value));
        }
        return static::$snakeCache[$key][$delimiter] = $value;
    }
    public static function startsWith($haystack, $needles)
    {
        foreach ((array) $needles as $needle) {
            if ($needle !== '' && substr($haystack, 0, strlen($needle)) === (string) $needle) {
                return true;
            }
        }
        return false;
    }
    public static function studly($value)
    {
        $key = $value;
        if (isset(static::$studlyCache[$key])) {
            return static::$studlyCache[$key];
        }
        $value = ucwords(str_replace(['-', '_'], ' ', $value));
        return static::$studlyCache[$key] = str_replace(' ', '', $value);
    }
    public static function substr($string, $start, $length = null)
    {
        return mb_substr($string, $start, $length, 'UTF-8');
    }
    public static function ucfirst($string)
    {
        return static::upper(static::substr($string, 0, 1)) . static::substr($string, 1);
    }
    protected static function charsArray()
    {
        static $charsArray;
        if (isset($charsArray)) {
            return $charsArray;
        }
        return $charsArray = ['0' => ['', '', '', ''], '1' => ['', '', '', ''], '2' => ['', '', '', ''], '3' => ['', '', '', ''], '4' => ['', '', '', '', ''], '5' => ['', '', '', '', ''], '6' => ['', '', '', '', ''], '7' => ['', '', '', ''], '8' => ['', '', '', ''], '9' => ['', '', '', ''], 'a' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'b' => ['', '', '', '', '', ''], 'c' => ['', '', '', '', '', ''], 'd' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'e' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'f' => ['', '', '', '', '', ''], 'g' => ['', '', '', '', '', '', '', '', '', '', ''], 'h' => ['', '', '', '', '', '', '', '', '', ''], 'i' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'j' => ['', '', '', '', '', ''], 'k' => ['', '', '', '', '', '', '', '', '', '', '', ''], 'l' => ['', '', '', '', '', '', '', '', '', '', ''], 'm' => ['', '', '', '', '', ''], 'n' => ['', '', '', '', '', '', '', '', '', '', '', ''], 'o' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'p' => ['', '', '', '', '', ''], 'q' => ['', ''], 'r' => ['', '', '', '', '', '', '', ''], 's' => ['', '', '', '', '', '', '', '', '', '', '', '', ''], 't' => ['', '', '', '', '', '', '', '', '', '', '', '', ''], 'u' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'v' => ['', '', '', ''], 'w' => ['', '', '', '', '', ''], 'x' => ['', '', ''], 'y' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'z' => ['', '', '', '', '', '', '', '', ''], 'aa' => ['', '', ''], 'ae' => ['', ''], 'ai' => [''], 'ch' => ['', '', '', ''], 'dj' => ['', ''], 'dz' => ['', ''], 'ei' => [''], 'gh' => ['', ''], 'ii' => [''], 'ij' => [''], 'kh' => ['', '', ''], 'lj' => [''], 'nj' => [''], 'oe' => ['', '', ''], 'oi' => [''], 'oii' => [''], 'ps' => [''], 'sh' => ['', '', ''], 'shch' => [''], 'ss' => [''], 'sx' => [''], 'th' => ['', '', '', '', ''], 'ts' => ['', '', ''], 'ue' => [''], 'uu' => [''], 'ya' => [''], 'yu' => [''], 'zh' => ['', '', ''], '(c)' => [''], 'A' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'B' => ['', '', '', ''], 'C' => ['', '', '', '', '', ''], 'D' => ['', '', '', '', '', '', '', '', '', '', ''], 'E' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'F' => ['', '', ''], 'G' => ['', '', '', '', '', '', ''], 'H' => ['', '', '', ''], 'I' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'J' => [''], 'K' => ['', '', ''], 'L' => ['', '', '', '', '', '', '', '', ''], 'M' => ['', '', ''], 'N' => ['', '', '', '', '', '', '', ''], 'O' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'P' => ['', '', ''], 'Q' => [''], 'R' => ['', '', '', '', '', ''], 'S' => ['', '', '', '', '', '', '', ''], 'T' => ['', '', '', '', '', '', ''], 'U' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'V' => ['', ''], 'W' => ['', '', '', ''], 'X' => ['', '', ''], 'Y' => ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''], 'Z' => ['', '', '', '', '', ''], 'AE' => ['', ''], 'Ch' => [''], 'Dj' => [''], 'Dz' => [''], 'Gx' => [''], 'Hx' => [''], 'Ij' => [''], 'Jx' => [''], 'Kh' => [''], 'Lj' => [''], 'Nj' => [''], 'Oe' => [''], 'Ps' => [''], 'Sh' => [''], 'Shch' => [''], 'Ss' => [''], 'Th' => [''], 'Ts' => [''], 'Ya' => [''], 'Yu' => [''], 'Zh' => [''], ' ' => ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]];
    }
    protected static function languageSpecificCharsArray($language)
    {
        static $languageSpecific;
        if (!isset($languageSpecific)) {
            $languageSpecific = ['bg' => [['', '', '', '', '', '', '', ''], ['h', 'H', 'sht', 'SHT', 'a', '', 'y', 'Y']], 'de' => [['', '', '', '', '', ''], ['ae', 'oe', 'ue', 'AE', 'OE', 'UE']]];
        }
        return isset($languageSpecific[$language]) ? $languageSpecific[$language] : null;
    }
}
}

namespace Royalcms\Component\Support {
class NamespacedItemResolver
{
    protected $parsed = [];
    public function parseKey($key)
    {
        if (isset($this->parsed[$key])) {
            return $this->parsed[$key];
        }
        if (strpos($key, '::') === false) {
            $segments = explode('.', $key);
            $parsed = $this->parseBasicSegments($segments);
        } else {
            $parsed = $this->parseNamespacedSegments($key);
        }
        return $this->parsed[$key] = $parsed;
    }
    protected function parseBasicSegments(array $segments)
    {
        $group = $segments[0];
        if (count($segments) == 1) {
            return [null, $group, null];
        } else {
            $item = implode('.', array_slice($segments, 1));
            return [null, $group, $item];
        }
    }
    protected function parseNamespacedSegments($key)
    {
        list($namespace, $item) = explode('::', $key);
        $itemSegments = explode('.', $item);
        $groupAndItem = array_slice($this->parseBasicSegments($itemSegments), 1);
        return array_merge([$namespace], $groupAndItem);
    }
    public function setParsedKey($key, $parsed)
    {
        $this->parsed[$key] = $parsed;
    }
}
}

namespace Royalcms\Component\Support {
use Closure;
use InvalidArgumentException;
abstract class Manager
{
    protected $royalcms;
    protected $customCreators = [];
    protected $drivers = [];
    public function __construct($royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public abstract function getDefaultDriver();
    public function driver($driver = null)
    {
        $driver = $driver ?: $this->getDefaultDriver();
        if (!isset($this->drivers[$driver])) {
            $this->drivers[$driver] = $this->createDriver($driver);
        }
        return $this->drivers[$driver];
    }
    protected function createDriver($driver)
    {
        $method = 'create' . ucfirst($driver) . 'Driver';
        if (isset($this->customCreators[$driver])) {
            return $this->callCustomCreator($driver);
        } elseif (method_exists($this, $method)) {
            return $this->{$method}();
        }
        throw new InvalidArgumentException("Driver [{$driver}] not supported.");
    }
    protected function callCustomCreator($driver)
    {
        return $this->customCreators[$driver]($this->royalcms);
    }
    public function extend($driver, Closure $callback)
    {
        $this->customCreators[$driver] = $callback;
        return $this;
    }
    public function getDrivers()
    {
        return $this->drivers;
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->driver(), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Support {
use Countable;
use Exception;
use ArrayAccess;
use Traversable;
use ArrayIterator;
use CachingIterator;
use JsonSerializable;
use IteratorAggregate;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Support\Debug\Dumper;
class Collection implements ArrayAccess, Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable
{
    use Macroable;
    protected $items = array();
    protected static $proxies = ['average', 'avg', 'contains', 'each', 'every', 'filter', 'first', 'flatMap', 'map', 'partition', 'reject', 'sortBy', 'sortByDesc', 'sum'];
    public function __construct($items = [])
    {
        $this->items = $this->getArrayableItems($items);
    }
    public static function make($items = [])
    {
        return new static($items);
    }
    public static function wrap($value)
    {
        return $value instanceof self ? new static($value) : new static(Arr::wrap($value));
    }
    public static function unwrap($value)
    {
        return $value instanceof self ? $value->all() : $value;
    }
    public static function times($number, callable $callback = null)
    {
        if ($number < 1) {
            return new static();
        }
        if (is_null($callback)) {
            return new static(range(1, $number));
        }
        return (new static(range(1, $number)))->map($callback);
    }
    public function all()
    {
        return $this->items;
    }
    public function avg($callback = null)
    {
        if ($count = $this->count()) {
            return $this->sum($callback) / $count;
        }
    }
    public function average($callback = null)
    {
        return $this->avg($callback);
    }
    public function median($key = null)
    {
        $count = $this->count();
        if ($count == 0) {
            return;
        }
        $values = with(isset($key) ? $this->pluck($key) : $this)->sort()->values();
        $middle = (int) ($count / 2);
        if ($count % 2) {
            return $values->get($middle);
        }
        return (new static([$values->get($middle - 1), $values->get($middle)]))->average();
    }
    public function mode($key = null)
    {
        $count = $this->count();
        if ($count == 0) {
            return;
        }
        $collection = isset($key) ? $this->pluck($key) : $this;
        $counts = new self();
        $collection->each(function ($value) use($counts) {
            $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1;
        });
        $sorted = $counts->sort();
        $highestValue = $sorted->last();
        return $sorted->filter(function ($value) use($highestValue) {
            return $value == $highestValue;
        })->sort()->keys()->all();
    }
    public function collapse()
    {
        return new static(Arr::collapse($this->items));
    }
    public function contains($key, $operator = null, $value = null)
    {
        if (func_num_args() == 1) {
            if ($this->useAsCallable($key)) {
                return !is_null($this->first($key));
            }
            return in_array($key, $this->items);
        }
        if (func_num_args() == 2) {
            $value = $operator;
            $operator = '=';
        }
        return $this->contains($this->operatorForWhere($key, $operator, $value));
    }
    public function containsStrict($key, $value = null)
    {
        if (func_num_args() == 2) {
            return $this->contains(function ($item) use($key, $value) {
                return data_get($item, $key) === $value;
            });
        }
        if ($this->useAsCallable($key)) {
            return !is_null($this->first($key));
        }
        return in_array($key, $this->items, true);
    }
    public function crossJoin($lists)
    {
        $lists = func_get_args();
        $lists = array_merge($this->items, array_map([$this, 'getArrayableItems'], $lists));
        return new static(Arr::crossJoin($lists));
    }
    public function dd()
    {
        dd($this->all());
    }
    public function dump()
    {
        (new static(func_get_args()))->push($this)->each(function ($item) {
            (new Dumper())->dump($item);
        });
        return $this;
    }
    public function diff($items)
    {
        return new static(array_diff($this->items, $this->getArrayableItems($items)));
    }
    public function diffAssoc($items)
    {
        return new static(array_diff_assoc($this->items, $this->getArrayableItems($items)));
    }
    public function diffKeys($items)
    {
        return new static(array_diff_key($this->items, $this->getArrayableItems($items)));
    }
    public function each(callable $callback)
    {
        foreach ($this->items as $key => $item) {
            if ($callback($item, $key) === false) {
                break;
            }
        }
        return $this;
    }
    public function eachSpread(callable $callback)
    {
        return $this->each(function ($chunk, $key) use($callback) {
            array_push($chunk, $key);
            return call_user_func_array($callback, $chunk);
        });
    }
    public function every($key, $operator = null, $value = null)
    {
        if (func_num_args() == 1) {
            $callback = $this->valueRetriever($key);
            foreach ($this->items as $k => $v) {
                if (!$callback($v, $k)) {
                    return false;
                }
            }
            return true;
        }
        if (func_num_args() == 2) {
            $value = $operator;
            $operator = '=';
        }
        return $this->every($this->operatorForWhere($key, $operator, $value));
    }
    public function except($keys)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        return new static(Arr::except($this->items, $keys));
    }
    public function fetch($key)
    {
        return new static(array_fetch($this->items, $key));
    }
    public function filter(callable $callback = null)
    {
        if ($callback) {
            $return = [];
            foreach ($this->items as $key => $value) {
                if ($callback($value, $key)) {
                    $return[$key] = $value;
                }
            }
            return new static($return);
        }
        return new static(array_filter($this->items));
    }
    public function when($value, callable $callback, callable $default = null)
    {
        if ($value) {
            return $callback($this);
        } elseif ($default) {
            return $default($this);
        }
        return $this;
    }
    public function unless($value, callable $callback, callable $default = null)
    {
        return $this->when(!$value, $callback, $default);
    }
    public function where($key, $operator, $value = null)
    {
        if (func_num_args() == 2) {
            $value = $operator;
            $operator = '=';
        }
        return $this->filter($this->operatorForWhere($key, $operator, $value));
    }
    protected function operatorForWhere($key, $operator, $value)
    {
        return function ($item) use($key, $operator, $value) {
            $retrieved = data_get($item, $key);
            switch ($operator) {
                default:
                case '=':
                case '==':
                    return $retrieved == $value;
                case '!=':
                case '<>':
                    return $retrieved != $value;
                case '<':
                    return $retrieved < $value;
                case '>':
                    return $retrieved > $value;
                case '<=':
                    return $retrieved <= $value;
                case '>=':
                    return $retrieved >= $value;
                case '===':
                    return $retrieved === $value;
                case '!==':
                    return $retrieved !== $value;
            }
        };
    }
    public function whereStrict($key, $value)
    {
        return $this->where($key, '===', $value);
    }
    public function whereIn($key, $values, $strict = false)
    {
        $values = $this->getArrayableItems($values);
        return $this->filter(function ($item) use($key, $values, $strict) {
            return in_array(data_get($item, $key), $values, $strict);
        });
    }
    public function whereInStrict($key, $values)
    {
        return $this->whereIn($key, $values, true);
    }
    public function whereNotIn($key, $values, $strict = false)
    {
        $values = $this->getArrayableItems($values);
        return $this->reject(function ($item) use($key, $values, $strict) {
            return in_array(data_get($item, $key), $values, $strict);
        });
    }
    public function whereNotInStrict($key, $values)
    {
        return $this->whereNotIn($key, $values, true);
    }
    public function whereLoose($key, $value)
    {
        return $this->where($key, '==', $value);
    }
    public function first(callable $callback = null, $default = null)
    {
        return Arr::first($this->items, $callback, $default);
    }
    public function flatten($depth = INF)
    {
        return new static(Arr::flatten($this->items, $depth));
    }
    public function flip()
    {
        return new static(array_flip($this->items));
    }
    public function forget($keys)
    {
        foreach ((array) $keys as $key) {
            $this->offsetUnset($key);
        }
        return $this;
    }
    public function get($key, $default = null)
    {
        if ($this->offsetExists($key)) {
            return $this->items[$key];
        }
        return value($default);
    }
    public function set($key, $value)
    {
        Arr::set($this->items, $key, $value);
    }
    public function groupBy($groupBy, $preserveKeys = false)
    {
        $groupBy = $this->valueRetriever($groupBy);
        $results = [];
        foreach ($this->items as $key => $value) {
            $groupKeys = $groupBy($value, $key);
            if (!is_array($groupKeys)) {
                $groupKeys = [$groupKeys];
            }
            foreach ($groupKeys as $groupKey) {
                $groupKey = is_bool($groupKey) ? (int) $groupKey : $groupKey;
                if (!array_key_exists($groupKey, $results)) {
                    $results[$groupKey] = new static();
                }
                $results[$groupKey]->offsetSet($preserveKeys ? $key : null, $value);
            }
        }
        return new static($results);
    }
    public function keyBy($keyBy)
    {
        $keyBy = $this->valueRetriever($keyBy);
        $results = [];
        foreach ($this->items as $key => $item) {
            $resolvedKey = $keyBy($item, $key);
            if (is_object($resolvedKey)) {
                $resolvedKey = (string) $resolvedKey;
            }
            $results[$resolvedKey] = $item;
        }
        return new static($results);
    }
    public function has($key)
    {
        $keys = is_array($key) ? $key : func_get_args();
        foreach ($keys as $value) {
            if (!$this->offsetExists($value)) {
                return false;
            }
        }
        return true;
    }
    public function implode($value, $glue = null)
    {
        $first = $this->first();
        if (is_array($first) || is_object($first)) {
            return implode($glue, $this->pluck($value)->all());
        }
        return implode($value, $this->items);
    }
    public function intersect($items)
    {
        return new static(array_intersect($this->items, $this->getArrayableItems($items)));
    }
    public function intersectByKeys($items)
    {
        return new static(array_intersect_key($this->items, $this->getArrayableItems($items)));
    }
    public function isEmpty()
    {
        return empty($this->items);
    }
    public function isNotEmpty()
    {
        return !$this->isEmpty();
    }
    protected function useAsCallable($value)
    {
        return !is_string($value) && is_callable($value);
    }
    public function keys()
    {
        return new static(array_keys($this->items));
    }
    public function last(callable $callback = null, $default = null)
    {
        return Arr::last($this->items, $callback, $default);
    }
    public function pluck($value, $key = null)
    {
        return new static(Arr::pluck($this->items, $value, $key));
    }
    public function lists($value, $key = null)
    {
        return $this->pluck($value, $key);
    }
    public function map(callable $callback)
    {
        $keys = array_keys($this->items);
        $items = array_map($callback, $this->items, $keys);
        return new static(array_combine($keys, $items));
    }
    public function mapSpread(callable $callback)
    {
        return $this->map(function ($chunk, $key) use($callback) {
            array_push($chunk, $key);
            return call_user_func_array($callback, $chunk);
        });
    }
    public function mapToGroups(callable $callback)
    {
        $groups = $this->map($callback)->reduce(function ($groups, $pair) {
            $groups[key($pair)][] = reset($pair);
            return $groups;
        }, []);
        return (new static($groups))->map([$this, 'make']);
    }
    public function mapWithKeys(callable $callback)
    {
        $result = [];
        foreach ($this->items as $key => $value) {
            $assoc = $callback($value, $key);
            foreach ($assoc as $mapKey => $mapValue) {
                $result[$mapKey] = $mapValue;
            }
        }
        return new static($result);
    }
    public function flatMap(callable $callback)
    {
        return $this->map($callback)->collapse();
    }
    public function mapInto($class)
    {
        return $this->map(function ($value, $key) use($class) {
            return new $class($value, $key);
        });
    }
    public function max($callback = null)
    {
        $callback = $this->valueRetriever($callback);
        return $this->filter(function ($value) {
            return !is_null($value);
        })->reduce(function ($result, $item) use($callback) {
            $value = $callback($item);
            return is_null($result) || $value > $result ? $value : $result;
        });
    }
    public function merge($items)
    {
        return new static(array_merge($this->items, $this->getArrayableItems($items)));
    }
    public function combine($values)
    {
        return new static(array_combine($this->all(), $this->getArrayableItems($values)));
    }
    public function union($items)
    {
        return new static($this->items + $this->getArrayableItems($items));
    }
    public function min($callback = null)
    {
        $callback = $this->valueRetriever($callback);
        return $this->filter(function ($value) {
            return !is_null($value);
        })->reduce(function ($result, $item) use($callback) {
            $value = $callback($item);
            return is_null($result) || $value < $result ? $value : $result;
        });
    }
    public function nth($step, $offset = 0)
    {
        $new = [];
        $position = 0;
        foreach ($this->items as $item) {
            if ($position % $step === $offset) {
                $new[] = $item;
            }
            $position++;
        }
        return new static($new);
    }
    public function only($keys)
    {
        if (is_null($keys)) {
            return new static($this->items);
        }
        $keys = is_array($keys) ? $keys : func_get_args();
        return new static(Arr::only($this->items, $keys));
    }
    public function forPage($page, $perPage)
    {
        return $this->slice(($page - 1) * $perPage, $perPage);
    }
    public function partition($callback)
    {
        $partitions = [new static(), new static()];
        $callback = $this->valueRetriever($callback);
        foreach ($this->items as $key => $item) {
            $partitions[(int) (!$callback($item, $key))][$key] = $item;
        }
        return new static($partitions);
    }
    public function pipe(callable $callback)
    {
        return $callback($this);
    }
    public function pop()
    {
        return array_pop($this->items);
    }
    public function prepend($value, $key = null)
    {
        $this->items = Arr::prepend($this->items, $value, $key);
        return $this;
    }
    public function push($value)
    {
        $this->offsetSet(null, $value);
        return $this;
    }
    public function concat($source)
    {
        $result = new static($this);
        foreach ($source as $item) {
            $result->push($item);
        }
        return $result;
    }
    public function pull($key, $default = null)
    {
        return Arr::pull($this->items, $key, $default);
    }
    public function put($key, $value)
    {
        $this->offsetSet($key, $value);
        return $this;
    }
    public function random($number = null)
    {
        if (is_null($number)) {
            return Arr::random($this->items);
        }
        return new static(Arr::random($this->items, $number));
    }
    public function reduce($callback, $initial = null)
    {
        return array_reduce($this->items, $callback, $initial);
    }
    public function reject($callback)
    {
        if ($this->useAsCallable($callback)) {
            return $this->filter(function ($value, $key) use($callback) {
                return !$callback($value, $key);
            });
        }
        return $this->filter(function ($item) use($callback) {
            return $item != $callback;
        });
    }
    public function reverse()
    {
        return new static(array_reverse($this->items, true));
    }
    public function search($value, $strict = false)
    {
        if (!$this->useAsCallable($value)) {
            return array_search($value, $this->items, $strict);
        }
        foreach ($this->items as $key => $item) {
            if (call_user_func($value, $item, $key)) {
                return $key;
            }
        }
        return false;
    }
    public function shift()
    {
        return array_shift($this->items);
    }
    public function shuffle($seed = null)
    {
        $items = $this->items;
        if (is_null($seed)) {
            shuffle($items);
        } else {
            srand($seed);
            usort($items, function () {
                return rand(-1, 1);
            });
        }
        return new static($items);
    }
    public function slice($offset, $length = null)
    {
        return new static(array_slice($this->items, $offset, $length, true));
    }
    public function split($numberOfGroups)
    {
        if ($this->isEmpty()) {
            return new static();
        }
        $groupSize = ceil($this->count() / $numberOfGroups);
        return $this->chunk($groupSize);
    }
    public function chunk($size)
    {
        if ($size <= 0) {
            return new static();
        }
        $chunks = [];
        foreach (array_chunk($this->items, $size, true) as $chunk) {
            $chunks[] = new static($chunk);
        }
        return new static($chunks);
    }
    public function sort(callable $callback = null)
    {
        $items = $this->items;
        $callback ? uasort($items, $callback) : asort($items);
        return new static($items);
    }
    public function sortBy($callback, $options = SORT_REGULAR, $descending = false)
    {
        $results = [];
        $callback = $this->valueRetriever($callback);
        foreach ($this->items as $key => $value) {
            $results[$key] = $callback($value, $key);
        }
        $descending ? arsort($results, $options) : asort($results, $options);
        foreach (array_keys($results) as $key) {
            $results[$key] = $this->items[$key];
        }
        return new static($results);
    }
    public function sortByDesc($callback, $options = SORT_REGULAR)
    {
        return $this->sortBy($callback, $options, true);
    }
    public function splice($offset, $length = null, $replacement = [])
    {
        if (func_num_args() == 1) {
            return new static(array_splice($this->items, $offset));
        }
        return new static(array_splice($this->items, $offset, $length, $replacement));
    }
    public function sum($callback = null)
    {
        if (is_null($callback)) {
            return array_sum($this->items);
        }
        $callback = $this->valueRetriever($callback);
        return $this->reduce(function ($result, $item) use($callback) {
            return $result += $callback($item);
        }, 0);
    }
    public function take($limit)
    {
        if ($limit < 0) {
            return $this->slice($limit, abs($limit));
        }
        return $this->slice(0, $limit);
    }
    public function tap(callable $callback)
    {
        $callback(new static($this->items));
        return $this;
    }
    public function transform(callable $callback)
    {
        $this->items = $this->map($callback)->all();
        return $this;
    }
    public function unique($key = null, $strict = false)
    {
        if (is_null($key)) {
            return new static(array_unique($this->items, SORT_REGULAR));
        }
        $callback = $this->valueRetriever($key);
        $exists = [];
        return $this->reject(function ($item, $key) use($callback, $strict, &$exists) {
            if (in_array($id = $callback($item, $key), $exists, $strict)) {
                return true;
            }
            $exists[] = $id;
        });
    }
    public function uniqueStrict($key = null)
    {
        return $this->unique($key, true);
    }
    public function values()
    {
        return new static(array_values($this->items));
    }
    protected function valueRetriever($value)
    {
        if ($this->useAsCallable($value)) {
            return $value;
        }
        return function ($item) use($value) {
            return data_get($item, $value);
        };
    }
    public function zip($items)
    {
        $arrayableItems = array_map(function ($items) {
            return $this->getArrayableItems($items);
        }, func_get_args());
        $params = array_merge([function () {
            return new static(func_get_args());
        }, $this->items], $arrayableItems);
        return new static(call_user_func_array('array_map', $params));
    }
    public function toArray()
    {
        return array_map(function ($value) {
            return $value instanceof Arrayable ? $value->toArray() : $value;
        }, $this->items);
    }
    public function jsonSerialize()
    {
        return array_map(function ($value) {
            if ($value instanceof JsonSerializable) {
                return $value->jsonSerialize();
            } elseif ($value instanceof Jsonable) {
                return json_decode($value->toJson(), true);
            } elseif ($value instanceof Arrayable) {
                return $value->toArray();
            } else {
                return $value;
            }
        }, $this->items);
    }
    public function toJson($options = 0)
    {
        return json_encode($this->toArray(), $options);
    }
    public function getIterator()
    {
        return new ArrayIterator($this->items);
    }
    public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING)
    {
        return new CachingIterator($this->getIterator(), $flags);
    }
    public function count()
    {
        return count($this->items);
    }
    public function toBase()
    {
        return new self($this);
    }
    public function unserialize($serialized)
    {
        return new static(unserialize($serialized));
    }
    public function offsetExists($key)
    {
        return array_key_exists($key, $this->items);
    }
    public function offsetGet($key)
    {
        return $this->items[$key];
    }
    public function offsetSet($key, $value)
    {
        if (is_null($key)) {
            $this->items[] = $value;
        } else {
            $this->items[$key] = $value;
        }
    }
    public function offsetUnset($key)
    {
        unset($this->items[$key]);
    }
    public function __toString()
    {
        return $this->toJson();
    }
    protected function getArrayableItems($items)
    {
        if (is_array($items)) {
            return $items;
        } elseif ($items instanceof self) {
            return $items->all();
        } elseif ($items instanceof Arrayable) {
            return $items->toArray();
        } elseif ($items instanceof Jsonable) {
            return json_decode($items->toJson(), true);
        } elseif ($items instanceof JsonSerializable) {
            return $items->jsonSerialize();
        } elseif ($items instanceof Traversable) {
            return iterator_to_array($items);
        }
        return (array) $items;
    }
    public static function proxy($method)
    {
        static::$proxies[] = $method;
    }
    public function __get($key)
    {
        if (!in_array($key, static::$proxies)) {
            throw new Exception("Property [{$key}] does not exist on this collection instance.");
        }
        return new HigherOrderCollectionProxy($this, $key);
    }
    public function __set($key, $value)
    {
        $this->set($key, $value);
    }
    public function __isset($key)
    {
        return $this->has($key);
    }
    public function __unset($key)
    {
        $this->forget($key);
    }
    public function __set_state()
    {
        return $this->all();
    }
}
}

namespace Royalcms\Component\Support {
use Countable;
use Royalcms\Component\Contracts\Support\MessageBag as MessageBagContract;
class ViewErrorBag implements Countable
{
    protected $bags = [];
    public function hasBag($key = 'default')
    {
        return isset($this->bags[$key]);
    }
    public function getBag($key)
    {
        return Arr::get($this->bags, $key) ?: new MessageBag();
    }
    public function getBags()
    {
        return $this->bags;
    }
    public function put($key, MessageBagContract $bag)
    {
        $this->bags[$key] = $bag;
        return $this;
    }
    public function count()
    {
        return $this->default->count();
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->default, $method], $parameters);
    }
    public function __get($key)
    {
        return $this->getBag($key);
    }
    public function __set($key, $value)
    {
        $this->put($key, $value);
    }
}
}

namespace Royalcms\Component\Support {
use Countable;
use JsonSerializable;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Contracts\Support\MessageProvider;
use Royalcms\Component\Contracts\Support\MessageBag as MessageBagContract;
class MessageBag implements Arrayable, Countable, Jsonable, JsonSerializable, MessageBagContract, MessageProvider
{
    protected $messages = [];
    protected $format = ':message';
    public function __construct(array $messages = [])
    {
        foreach ($messages as $key => $value) {
            $this->messages[$key] = (array) $value;
        }
    }
    public function keys()
    {
        return array_keys($this->messages);
    }
    public function add($key, $message)
    {
        if ($this->isUnique($key, $message)) {
            $this->messages[$key][] = $message;
        }
        return $this;
    }
    public function merge($messages)
    {
        if ($messages instanceof MessageProvider) {
            $messages = $messages->getMessageBag()->getMessages();
        }
        $this->messages = array_merge_recursive($this->messages, $messages);
        return $this;
    }
    protected function isUnique($key, $message)
    {
        $messages = (array) $this->messages;
        return !isset($messages[$key]) || !in_array($message, $messages[$key]);
    }
    public function has($key = null)
    {
        return $this->first($key) !== '';
    }
    public function first($key = null, $format = null)
    {
        $messages = is_null($key) ? $this->all($format) : $this->get($key, $format);
        return count($messages) > 0 ? $messages[0] : '';
    }
    public function get($key, $format = null)
    {
        if (array_key_exists($key, $this->messages)) {
            return $this->transform($this->messages[$key], $this->checkFormat($format), $key);
        }
        return [];
    }
    public function all($format = null)
    {
        $format = $this->checkFormat($format);
        $all = [];
        foreach ($this->messages as $key => $messages) {
            $all = array_merge($all, $this->transform($messages, $format, $key));
        }
        return $all;
    }
    protected function transform($messages, $format, $messageKey)
    {
        $messages = (array) $messages;
        $replace = [':message', ':key'];
        foreach ($messages as &$message) {
            $message = str_replace($replace, [$message, $messageKey], $format);
        }
        return $messages;
    }
    protected function checkFormat($format)
    {
        return $format ?: $this->format;
    }
    public function getMessages()
    {
        return $this->messages;
    }
    public function getMessageBag()
    {
        return $this;
    }
    public function getFormat()
    {
        return $this->format;
    }
    public function setFormat($format = ':message')
    {
        $this->format = $format;
        return $this;
    }
    public function isEmpty()
    {
        return !$this->any();
    }
    public function any()
    {
        return $this->count() > 0;
    }
    public function count()
    {
        return count($this->messages, COUNT_RECURSIVE) - count($this->messages);
    }
    public function toArray()
    {
        return $this->getMessages();
    }
    public function jsonSerialize()
    {
        return $this->toArray();
    }
    public function toJson($options = 0)
    {
        return json_encode($this->toArray(), $options);
    }
    public function __toString()
    {
        return $this->toJson();
    }
}
}

namespace Royalcms\Component\Support {
trait ArrayHelperTrait
{
    public static function transform_value_case($arr, $type = 'lower')
    {
        $function = $type ? 'strtoupper' : 'strtolower';
        $new_arr = array();
        foreach ($arr as $k => $v) {
            if (is_array($v)) {
                $new_arr[$k] = self::transform_value_case($v, $type);
            } else {
                $new_arr[$k] = $function($v);
            }
        }
        return $new_arr;
    }
    public static function string2array($data)
    {
        if ($data == '') {
            return array();
        }
        $array = array();
        eval("\$array = {$data};");
        return $array;
    }
    public static function object2array($obj)
    {
        if (!is_object($obj) && !is_array($obj)) {
            return $obj;
        }
        $arr = array();
        foreach ($obj as $k => $v) {
            $arr[$k] = self::object2array($v);
        }
        return $arr;
    }
    public static function array2string($data, $isformdata = 1)
    {
        if ($data == '') {
            return '';
        }
        if ($isformdata) {
            $data = rc_stripslashes($data);
        }
        return rc_addslashes(var_export($data, true));
    }
    public static function array_size($arr)
    {
        ob_start();
        print_r($arr);
        $mem = ob_get_contents();
        ob_end_clean();
        $mem = preg_replace("/\n +/", "", $mem);
        $mem = strlen($mem);
        return $mem;
    }
    public static function array_iconv($data, $input = 'gbk', $output = 'utf-8')
    {
        if (!is_array($data)) {
            return iconv($input, $output, $data);
        } else {
            foreach ($data as $key => $val) {
                if (is_array($val)) {
                    $data[$key] = self::array_iconv($val, $input, $output);
                } else {
                    $data[$key] = iconv($input, $output, $val);
                }
            }
            return $data;
        }
    }
}
}

namespace Royalcms\Component\Support {
trait StrHelperTrait
{
    public static function str_cut($string, $length, $dot = '...')
    {
        return self::limit($string, $length, $dot);
    }
    public static function str_exists($haystack, $needle)
    {
        return !(strpos($haystack, $needle) === FALSE);
    }
    public static function unicode2string($uncode)
    {
        $uncode = str_replace('u', '\\u', $uncode);
        return json_decode('"' . $uncode . '"');
    }
    public static function unicode_encode($word)
    {
        $word0 = iconv('gbk', 'utf-8', $word);
        $word1 = iconv('utf-8', 'gbk', $word0);
        $word = $word1 == $word ? $word0 : $word;
        $word = json_encode($word);
        $word = preg_replace_callback('/\\\\u(\\w{4})/', create_function('$hex', 'return \'&#\'.hexdec($hex[1]).\';\';'), substr($word, 1, strlen($word) - 2));
        return $word;
    }
    public static function unicode_decode($uncode)
    {
        $word = json_decode(preg_replace_callback('/&#(\\d{5});/', create_function('$dec', 'return \'\\u\'.dechex($dec[1]);'), '"' . $uncode . '"'));
        return $word;
    }
    public static function str_len($str)
    {
        $length = strlen(preg_replace('/[\\x00-\\x7F]/', '', $str));
        if ($length) {
            return strlen($str) - $length + intval($length / 3) * 2;
        } else {
            return strlen($str);
        }
    }
    public static function sub_str($str, $length = 0, $append = true)
    {
        $str = trim($str);
        $strlength = strlen($str);
        if ($length == 0 || $length >= $strlength) {
            return $str;
        } elseif ($length < 0) {
            $length = $strlength + $length;
            if ($length < 0) {
                $length = $strlength;
            }
        }
        if (function_exists('mb_substr')) {
            $newstr = mb_substr($str, 0, $length, RC_CHARSET);
        } elseif (function_exists('iconv_substr')) {
            $newstr = iconv_substr($str, 0, $length, RC_CHARSET);
        } else {
            $newstr = substr($str, 0, $length);
        }
        if ($append && $str != $newstr) {
            $newstr .= '...';
        }
        return $newstr;
    }
    public static function str_to_key($str, $owner = '')
    {
        if (!$str) {
            return '';
        }
        if ($owner) {
            return $owner . '[\'' . str_replace('.', '\'][\'', $str) . '\']';
        } else {
            $parts = explode('.', $str);
            $owner = '$' . $parts[0];
            unset($parts[0]);
            return self::str_to_key(implode('.', $parts), $owner);
        }
    }
}
}

namespace Royalcms\Component\Support {
use Royalcms\Component\Support\Facades\Config;
use RC_Hook;
use Royalcms\Component\Support\Facades\Lang;
use RC_Locale;
class Format
{
    public static function date($timestamp, $showtime = 0)
    {
        if (empty($timestamp)) {
            return false;
        }
        $times = intval($timestamp);
        if (!$times) {
            return true;
        }
        $lang = Config::get('system.lang');
        if ($lang == 'zh-cn') {
            $str = $showtime ? date('Y-m-d H:i:s', $times) : date('Y-m-d', $times);
        } else {
            $str = $showtime ? date('m/d/Y H:i:s', $times) : date('m/d/Y', $times);
        }
        return $str;
    }
    public static function week($timestamp)
    {
        $times = intval($timestamp);
        if (!$times) {
            return true;
        }
        $weekarray = array(Lang::lang('Sunday'), Lang::lang('Monday'), Lang::lang('Tuesday'), Lang::lang('Wednesday'), Lang::lang('Thursday'), Lang::lang('Friday'), Lang::lang('Saturday'));
        return $weekarray[date("w", $timestamp)];
    }
    public static function trailingslashit($string)
    {
        return self::untrailingslashit($string) . '/';
    }
    public static function untrailingslashit($string)
    {
        return rtrim($string, '/\\');
    }
    public static function normalize_path($path)
    {
        $wrapper = '';
        if (rc_is_stream($path)) {
            list($wrapper, $path) = explode('://', $path, 2);
            $wrapper .= '://';
        }
        $path = str_replace('\\', '/', $path);
        $path = preg_replace('|(?<=.)/+|', '/', $path);
        if (':' === substr($path, 1, 1)) {
            $path = ucfirst($path);
        }
        return $wrapper . $path;
    }
    public static function path_join($base, $path)
    {
        if (self::path_is_absolute($path)) {
            return $path;
        }
        return rtrim($base, '/') . '/' . ltrim($path, '/');
    }
    public static function path_is_absolute($path)
    {
        if (realpath($path) == $path) {
            return true;
        }
        if (strlen($path) == 0 || $path[0] == '.') {
            return false;
        }
        if (preg_match('#^[a-zA-Z]:\\\\#', $path)) {
            return true;
        }
        return $path[0] == '/' || $path[0] == '\\';
    }
    public static function format_size($size, $decimals = 2)
    {
        switch (true) {
            case $size >= pow(1024, 3):
                return round($size / pow(1024, 3), $decimals) . " GB";
            case $size >= pow(1024, 2):
                return round($size / pow(1024, 2), $decimals) . " MB";
            case $size >= pow(1024, 1):
                return round($size / pow(1024, 1), $decimals) . " KB";
            default:
                return $size . 'B';
        }
    }
    public static function format_bytes($val)
    {
        $val = trim($val);
        $last = strtolower($val[strlen($val) - 1]);
        switch ($last) {
            case 'g':
                $val *= 1024;
            case 'm':
                $val *= 1024;
            case 'k':
                $val *= 1024;
        }
        return $val;
    }
    public static function format_js($string, $isjs = 1)
    {
        $string = addslashes(str_replace(array("\r", "\n"), array('', ''), $string));
        return $isjs ? 'document.write("' . $string . '");' : $string;
    }
    public static function format_textarea($string)
    {
        $string = nl2br(str_replace(' ', '&nbsp;', $string));
        return $string;
    }
    public static function format_script($str)
    {
        $str = preg_replace('/\\<([\\/]?)script([^\\>]*?)\\>/si', '&lt;\\1script\\2&gt;', $str);
        $str = preg_replace('/\\<([\\/]?)iframe([^\\>]*?)\\>/si', '&lt;\\1iframe\\2&gt;', $str);
        $str = preg_replace('/\\<([\\/]?)frame([^\\>]*?)\\>/si', '&lt;\\1frame\\2&gt;', $str);
        $str = preg_replace('/]]\\>/si', ']] >', $str);
        return $str;
    }
    public static function esc_url($url, $protocols = null, $_context = 'display')
    {
        $original_url = $url;
        if ('' == $url) {
            return $url;
        }
        $url = str_replace(' ', '%20', $url);
        $url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\\|*\'()\\[\\]\\x80-\\xff]|i', '', $url);
        if (0 !== stripos($url, 'mailto:')) {
            $strip = array('%0d', '%0a', '%0D', '%0A');
            $url = self::_deep_replace($strip, $url);
        }
        $url = str_replace(';//', '://', $url);
        if (strpos($url, ':') === false && !in_array($url[0], array('/', '#', '?')) && !preg_match('/^[a-z0-9-]+?\\.php/i', $url)) {
            $url = 'http://' . $url;
        }
        if ('display' == $_context) {
            $url = \RC_Kses::normalize_entities($url);
            $url = str_replace('&amp;', '&#038;', $url);
            $url = str_replace("'", '&#039;', $url);
        }
        if (false !== strpos($url, '[') || false !== strpos($url, ']')) {
            $parsed = rc_parse_url($url);
            $front = '';
            if (isset($parsed['scheme'])) {
                $front .= $parsed['scheme'] . '://';
            } elseif ('/' === $url[0]) {
                $front .= '//';
            }
            if (isset($parsed['user'])) {
                $front .= $parsed['user'];
            }
            if (isset($parsed['pass'])) {
                $front .= ':' . $parsed['pass'];
            }
            if (isset($parsed['user']) || isset($parsed['pass'])) {
                $front .= '@';
            }
            if (isset($parsed['host'])) {
                $front .= $parsed['host'];
            }
            if (isset($parsed['port'])) {
                $front .= ':' . $parsed['port'];
            }
            $end_dirty = str_replace($front, '', $url);
            $end_clean = str_replace(array('[', ']'), array('%5B', '%5D'), $end_dirty);
            $url = str_replace($end_dirty, $end_clean, $url);
        }
        if ('/' === $url[0]) {
            $good_protocol_url = $url;
        } else {
            if (!is_array($protocols)) {
                $protocols = rc_allowed_protocols();
            }
            $good_protocol_url = \RC_Kses::bad_protocol($url, $protocols);
            if (strtolower($good_protocol_url) != strtolower($url)) {
                return '';
            }
        }
        return RC_Hook::apply_filters('clean_url', $good_protocol_url, $original_url, $_context);
    }
    public static function esc_url_raw($url, $protocols = null)
    {
        return self::esc_url($url, $protocols, 'db');
    }
    public static function _deep_replace($search, $subject)
    {
        $subject = (string) $subject;
        $count = 1;
        while ($count) {
            $subject = str_replace($search, '', $subject, $count);
        }
        return $subject;
    }
    public static function urlencode_deep($value)
    {
        $value = is_array($value) ? array_map(array(__CLASS__, 'urlencode_deep'), $value) : urlencode($value);
        return $value;
    }
    public static function rawurlencode_deep($value)
    {
        return is_array($value) ? array_map(array(__CLASS__, 'rawurlencode_deep'), $value) : rawurlencode($value);
    }
    public static function esc_attr($text)
    {
        $safe_text = self::_check_invalid_utf8($text);
        $safe_text = self::_specialchars($safe_text, ENT_QUOTES);
        return RC_Hook::apply_filters('attribute_escape', $safe_text, $text);
    }
    public static function esc_js($text)
    {
        $safe_text = self::_check_invalid_utf8($text);
        $safe_text = self::_specialchars($safe_text, ENT_COMPAT);
        $safe_text = preg_replace('/&#(x)?0*(?(1)27|39);?/i', "'", stripslashes($safe_text));
        $safe_text = str_replace("\r", '', $safe_text);
        $safe_text = str_replace("\n", '\\n', addslashes($safe_text));
        return RC_Hook::apply_filters('js_escape', $safe_text, $text);
    }
    public static function esc_html($text)
    {
        $safe_text = self::_check_invalid_utf8($text);
        $safe_text = self::_specialchars($safe_text, ENT_QUOTES);
        return RC_Hook::apply_filters('esc_html', $safe_text, $text);
    }
    public static function esc_textarea($text)
    {
        $safe_text = htmlspecialchars($text, ENT_QUOTES, RC_CHARSET);
        return RC_Hook::apply_filters('esc_textarea', $safe_text, $text);
    }
    public static function _check_invalid_utf8($string, $strip = false)
    {
        $string = (string) $string;
        if (0 === strlen($string)) {
            return '';
        }
        static $is_utf8;
        if (!isset($is_utf8)) {
            $is_utf8 = in_array(RC_CHARSET, array('utf8', 'utf-8', 'UTF8', 'UTF-8'));
        }
        if (!$is_utf8) {
            return $string;
        }
        static $utf8_pcre;
        if (!isset($utf8_pcre)) {
            $utf8_pcre = @preg_match('/^./u', 'a');
        }
        if (!$utf8_pcre) {
            return $string;
        }
        if (1 === @preg_match('/^./us', $string)) {
            return $string;
        }
        if ($strip && function_exists('iconv')) {
            return iconv('utf-8', 'utf-8', $string);
        }
        return '';
    }
    public static function _specialchars($string, $quote_style = ENT_NOQUOTES, $charset = false, $double_encode = false)
    {
        $string = (string) $string;
        if (0 === strlen($string)) {
            return '';
        }
        if (!preg_match('/[&<>"\']/', $string)) {
            return $string;
        }
        if (empty($quote_style)) {
            $quote_style = ENT_NOQUOTES;
        } elseif (!in_array($quote_style, array(0, 2, 3, 'single', 'double'), true)) {
            $quote_style = ENT_QUOTES;
        }
        if (!$charset) {
            $charset = RC_CHARSET;
        }
        if (in_array($charset, array('utf8', 'utf-8', 'UTF8'))) {
            $charset = 'UTF-8';
        }
        $_quote_style = $quote_style;
        if ($quote_style === 'double') {
            $quote_style = ENT_COMPAT;
            $_quote_style = ENT_COMPAT;
        } elseif ($quote_style === 'single') {
            $quote_style = ENT_NOQUOTES;
        }
        if ($double_encode) {
            $string = @htmlspecialchars($string, $quote_style, $charset);
        } else {
            $string = self::_specialchars_decode($string, $_quote_style);
            $string = preg_split('/(&#?x?[0-9a-z]+;)/i', $string, -1, PREG_SPLIT_DELIM_CAPTURE);
            for ($i = 0; $i < count($string); $i += 2) {
                $string[$i] = @htmlspecialchars($string[$i], $quote_style, $charset);
            }
            $string = implode('', $string);
        }
        if ('single' === $_quote_style) {
            $string = str_replace("'", '&#039;', $string);
        }
        return $string;
    }
    public static function _specialchars_decode($string, $quote_style = ENT_NOQUOTES)
    {
        $string = (string) $string;
        if (0 === strlen($string)) {
            return '';
        }
        if (strpos($string, '&') === false) {
            return $string;
        }
        if (empty($quote_style)) {
            $quote_style = ENT_NOQUOTES;
        } elseif (!in_array($quote_style, array(0, 2, 3, 'single', 'double'), true)) {
            $quote_style = ENT_QUOTES;
        }
        $single = array('&#039;' => '\'', '&#x27;' => '\'');
        $single_preg = array('/&#0*39;/' => '&#039;', '/&#x0*27;/i' => '&#x27;');
        $double = array('&quot;' => '"', '&#034;' => '"', '&#x22;' => '"');
        $double_preg = array('/&#0*34;/' => '&#034;', '/&#x0*22;/i' => '&#x22;');
        $others = array('&lt;' => '<', '&#060;' => '<', '&gt;' => '>', '&#062;' => '>', '&amp;' => '&', '&#038;' => '&', '&#x26;' => '&');
        $others_preg = array('/&#0*60;/' => '&#060;', '/&#0*62;/' => '&#062;', '/&#0*38;/' => '&#038;', '/&#x0*26;/i' => '&#x26;');
        if ($quote_style === ENT_QUOTES) {
            $translation = array_merge($single, $double, $others);
            $translation_preg = array_merge($single_preg, $double_preg, $others_preg);
        } elseif ($quote_style === ENT_COMPAT || $quote_style === 'double') {
            $translation = array_merge($double, $others);
            $translation_preg = array_merge($double_preg, $others_preg);
        } elseif ($quote_style === 'single') {
            $translation = array_merge($single, $others);
            $translation_preg = array_merge($single_preg, $others_preg);
        } elseif ($quote_style === ENT_NOQUOTES) {
            $translation = $others;
            $translation_preg = $others_preg;
        }
        $string = preg_replace(array_keys($translation_preg), array_values($translation_preg), $string);
        return strtr($string, $translation);
    }
    public static function _cleanup_header_comment($str)
    {
        return trim(preg_replace('/\\s*(?:\\*\\/|\\?>).*/', '', $str));
    }
    private static $cockneyreplace;
    public static function texturize($text)
    {
        static $static_characters, $static_replacements, $dynamic_characters, $dynamic_replacements, $default_no_texturize_tags, $default_no_texturize_shortcodes;
        if (!isset($static_characters)) {
            $opening_quote = _x('&#8220;', 'opening curly double quote');
            $closing_quote = _x('&#8221;', 'closing curly double quote');
            $apos = _x('&#8217;', 'apostrophe');
            $prime = _x('&#8242;', 'prime');
            $double_prime = _x('&#8243;', 'double prime');
            $opening_single_quote = _x('&#8216;', 'opening curly single quote');
            $closing_single_quote = _x('&#8217;', 'closing curly single quote');
            $en_dash = _x('&#8211;', 'en dash');
            $em_dash = _x('&#8212;', 'em dash');
            $default_no_texturize_tags = array('pre', 'code', 'kbd', 'style', 'script', 'tt');
            $default_no_texturize_shortcodes = array('code');
            if (isset($wp_cockneyreplace)) {
                $cockney = array_keys(self::$cockneyreplace);
                $cockneyreplace = array_values(self::$cockneyreplace);
            } elseif ("'" != $apos) {
                $cockney = array("'tain't", "'twere", "'twas", "'tis", "'twill", "'til", "'bout", "'nuff", "'round", "'cause");
                $cockneyreplace = array($apos . "tain" . $apos . "t", $apos . "twere", $apos . "twas", $apos . "tis", $apos . "twill", $apos . "til", $apos . "bout", $apos . "nuff", $apos . "round", $apos . "cause");
            } else {
                $cockney = $cockneyreplace = array();
            }
            $static_characters = array_merge(array('---', ' -- ', '--', ' - ', 'xn&#8211;', '...', '``', '\'\'', ' (tm)'), $cockney);
            $static_replacements = array_merge(array($em_dash, ' ' . $em_dash . ' ', $en_dash, ' ' . $en_dash . ' ', 'xn--', '&#8230;', $opening_quote, $closing_quote, ' &#8482;'), $cockneyreplace);
            $spaces = '[\\r\\n\\t ]|\\xC2\\xA0|&nbsp;';
            $dynamic = array();
            if ("'" !== $apos) {
                $dynamic['/\'(?=\\d)/'] = $apos;
            }
            if ("'" !== $opening_single_quote) {
                $dynamic['/(?<=\\A|[([{<"]|' . $spaces . ')\'/'] = $opening_single_quote;
            }
            if ('"' !== $double_prime) {
                $dynamic['/(?<=\\d)"/'] = $double_prime;
            }
            if ("'" !== $prime) {
                $dynamic['/(?<=\\d)\'/'] = $prime;
            }
            if ("'" !== $apos) {
                $dynamic['/(?<!' . $spaces . ')\'(?!\'|' . $spaces . ')/'] = $apos;
            }
            if ('"' !== $opening_quote) {
                $dynamic['/(?<=\\A|[([{<]|' . $spaces . ')"(?!' . $spaces . ')/'] = $opening_quote;
            }
            if ('"' !== $closing_quote) {
                $dynamic['/"/'] = $closing_quote;
            }
            if ("'" !== $closing_single_quote) {
                $dynamic['/\'(?=\\Z|\\.|' . $spaces . ')/'] = $closing_single_quote;
            }
            $dynamic_characters = array_keys($dynamic);
            $dynamic_replacements = array_values($dynamic);
        }
        $no_texturize_tags = '(' . implode('|', RC_Hook::apply_filters('no_texturize_tags', $default_no_texturize_tags)) . ')';
        $no_texturize_shortcodes = '(' . implode('|', RC_Hook::apply_filters('no_texturize_shortcodes', $default_no_texturize_shortcodes)) . ')';
        $no_texturize_tags_stack = array();
        $no_texturize_shortcodes_stack = array();
        $textarr = preg_split('/(<.*>|\\[.*\\])/Us', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
        foreach ($textarr as &$curl) {
            if (empty($curl)) {
                continue;
            }
            $first = $curl[0];
            if ('<' === $first) {
                self::_texturize_pushpop_element($curl, $no_texturize_tags_stack, $no_texturize_tags, '<', '>');
            } elseif ('[' === $first) {
                self::_texturize_pushpop_element($curl, $no_texturize_shortcodes_stack, $no_texturize_shortcodes, '[', ']');
            } elseif (empty($no_texturize_shortcodes_stack) && empty($no_texturize_tags_stack)) {
                $curl = str_replace($static_characters, $static_replacements, $curl);
                $curl = preg_replace($dynamic_characters, $dynamic_replacements, $curl);
                if (1 === preg_match('/(?<=\\d)x\\d/', $text)) {
                    $curl = preg_replace('/\\b(\\d+)x(\\d+)\\b/', '$1&#215;$2', $curl);
                }
            }
            $curl = preg_replace('/&([^#])(?![a-zA-Z1-4]{1,8};)/', '&#038;$1', $curl);
        }
        return implode('', $textarr);
    }
    public static function _texturize_pushpop_element($text, &$stack, $disabled_elements, $opening = '<', $closing = '>')
    {
        if (strncmp($opening . '/', $text, 2)) {
            if (preg_match('/^' . $disabled_elements . '\\b/', substr($text, 1), $matches)) {
                array_push($stack, $matches[1]);
            }
        } else {
            $c = preg_quote($closing, '/');
            if (preg_match('/^' . $disabled_elements . $c . '/', substr($text, 2), $matches)) {
                $last = array_pop($stack);
                if ($last != $matches[1]) {
                    array_push($stack, $last);
                }
            }
        }
    }
    public static function sanitize_title($title, $fallback_title = '', $context = 'save')
    {
        $raw_title = $title;
        if ('save' == $context) {
            $title = self::remove_accents($title);
        }
        $title = RC_Hook::apply_filters('sanitize_title', $title, $raw_title, $context);
        if ('' === $title || false === $title) {
            $title = $fallback_title;
        }
        return $title;
    }
    public static function sanitize_file_name($filename)
    {
        $filename_raw = $filename;
        $special_chars = array("?", "[", "]", "/", "\\", "=", "<", ">", ":", ";", ",", "'", "\"", "&", "\$", "#", "*", "(", ")", "|", "~", "`", "!", "{", "}", chr(0));
        $special_chars = RC_Hook::apply_filters('sanitize_file_name_chars', $special_chars, $filename_raw);
        $filename = preg_replace("#\\x{00a0}#siu", ' ', $filename);
        $filename = str_replace($special_chars, '', $filename);
        $filename = str_replace(array('%20', '+'), '-', $filename);
        $filename = preg_replace('/[\\s-]+/', '-', $filename);
        $filename = trim($filename, '.-_');
        $parts = explode('.', $filename);
        if (count($parts) <= 2) {
            return RC_Hook::apply_filters('sanitize_file_name', $filename, $filename_raw);
        }
        $filename = array_shift($parts);
        $extension = array_pop($parts);
        $mimes = array();
        foreach ((array) $parts as $part) {
            $filename .= '.' . $part;
            if (preg_match('/^[a-zA-Z]{2,5}\\d?$/', $part)) {
                $allowed = false;
                foreach ($mimes as $ext_preg => $mime_match) {
                    $ext_preg = '!^(' . $ext_preg . ')$!i';
                    if (preg_match($ext_preg, $part)) {
                        $allowed = true;
                        break;
                    }
                }
                if (!$allowed) {
                    $filename .= '_';
                }
            }
        }
        $filename .= '.' . $extension;
        return RC_Hook::apply_filters('sanitize_file_name', $filename, $filename_raw);
    }
    public static function remove_accents($string)
    {
        if (!preg_match('/[\\x80-\\xff]/', $string)) {
            return $string;
        }
        if (self::seems_utf8($string)) {
            $chars = array(chr(194) . chr(170) => 'a', chr(194) . chr(186) => 'o', chr(195) . chr(128) => 'A', chr(195) . chr(129) => 'A', chr(195) . chr(130) => 'A', chr(195) . chr(131) => 'A', chr(195) . chr(132) => 'A', chr(195) . chr(133) => 'A', chr(195) . chr(134) => 'AE', chr(195) . chr(135) => 'C', chr(195) . chr(136) => 'E', chr(195) . chr(137) => 'E', chr(195) . chr(138) => 'E', chr(195) . chr(139) => 'E', chr(195) . chr(140) => 'I', chr(195) . chr(141) => 'I', chr(195) . chr(142) => 'I', chr(195) . chr(143) => 'I', chr(195) . chr(144) => 'D', chr(195) . chr(145) => 'N', chr(195) . chr(146) => 'O', chr(195) . chr(147) => 'O', chr(195) . chr(148) => 'O', chr(195) . chr(149) => 'O', chr(195) . chr(150) => 'O', chr(195) . chr(153) => 'U', chr(195) . chr(154) => 'U', chr(195) . chr(155) => 'U', chr(195) . chr(156) => 'U', chr(195) . chr(157) => 'Y', chr(195) . chr(158) => 'TH', chr(195) . chr(159) => 's', chr(195) . chr(160) => 'a', chr(195) . chr(161) => 'a', chr(195) . chr(162) => 'a', chr(195) . chr(163) => 'a', chr(195) . chr(164) => 'a', chr(195) . chr(165) => 'a', chr(195) . chr(166) => 'ae', chr(195) . chr(167) => 'c', chr(195) . chr(168) => 'e', chr(195) . chr(169) => 'e', chr(195) . chr(170) => 'e', chr(195) . chr(171) => 'e', chr(195) . chr(172) => 'i', chr(195) . chr(173) => 'i', chr(195) . chr(174) => 'i', chr(195) . chr(175) => 'i', chr(195) . chr(176) => 'd', chr(195) . chr(177) => 'n', chr(195) . chr(178) => 'o', chr(195) . chr(179) => 'o', chr(195) . chr(180) => 'o', chr(195) . chr(181) => 'o', chr(195) . chr(182) => 'o', chr(195) . chr(184) => 'o', chr(195) . chr(185) => 'u', chr(195) . chr(186) => 'u', chr(195) . chr(187) => 'u', chr(195) . chr(188) => 'u', chr(195) . chr(189) => 'y', chr(195) . chr(190) => 'th', chr(195) . chr(191) => 'y', chr(195) . chr(152) => 'O', chr(196) . chr(128) => 'A', chr(196) . chr(129) => 'a', chr(196) . chr(130) => 'A', chr(196) . chr(131) => 'a', chr(196) . chr(132) => 'A', chr(196) . chr(133) => 'a', chr(196) . chr(134) => 'C', chr(196) . chr(135) => 'c', chr(196) . chr(136) => 'C', chr(196) . chr(137) => 'c', chr(196) . chr(138) => 'C', chr(196) . chr(139) => 'c', chr(196) . chr(140) => 'C', chr(196) . chr(141) => 'c', chr(196) . chr(142) => 'D', chr(196) . chr(143) => 'd', chr(196) . chr(144) => 'D', chr(196) . chr(145) => 'd', chr(196) . chr(146) => 'E', chr(196) . chr(147) => 'e', chr(196) . chr(148) => 'E', chr(196) . chr(149) => 'e', chr(196) . chr(150) => 'E', chr(196) . chr(151) => 'e', chr(196) . chr(152) => 'E', chr(196) . chr(153) => 'e', chr(196) . chr(154) => 'E', chr(196) . chr(155) => 'e', chr(196) . chr(156) => 'G', chr(196) . chr(157) => 'g', chr(196) . chr(158) => 'G', chr(196) . chr(159) => 'g', chr(196) . chr(160) => 'G', chr(196) . chr(161) => 'g', chr(196) . chr(162) => 'G', chr(196) . chr(163) => 'g', chr(196) . chr(164) => 'H', chr(196) . chr(165) => 'h', chr(196) . chr(166) => 'H', chr(196) . chr(167) => 'h', chr(196) . chr(168) => 'I', chr(196) . chr(169) => 'i', chr(196) . chr(170) => 'I', chr(196) . chr(171) => 'i', chr(196) . chr(172) => 'I', chr(196) . chr(173) => 'i', chr(196) . chr(174) => 'I', chr(196) . chr(175) => 'i', chr(196) . chr(176) => 'I', chr(196) . chr(177) => 'i', chr(196) . chr(178) => 'IJ', chr(196) . chr(179) => 'ij', chr(196) . chr(180) => 'J', chr(196) . chr(181) => 'j', chr(196) . chr(182) => 'K', chr(196) . chr(183) => 'k', chr(196) . chr(184) => 'k', chr(196) . chr(185) => 'L', chr(196) . chr(186) => 'l', chr(196) . chr(187) => 'L', chr(196) . chr(188) => 'l', chr(196) . chr(189) => 'L', chr(196) . chr(190) => 'l', chr(196) . chr(191) => 'L', chr(197) . chr(128) => 'l', chr(197) . chr(129) => 'L', chr(197) . chr(130) => 'l', chr(197) . chr(131) => 'N', chr(197) . chr(132) => 'n', chr(197) . chr(133) => 'N', chr(197) . chr(134) => 'n', chr(197) . chr(135) => 'N', chr(197) . chr(136) => 'n', chr(197) . chr(137) => 'N', chr(197) . chr(138) => 'n', chr(197) . chr(139) => 'N', chr(197) . chr(140) => 'O', chr(197) . chr(141) => 'o', chr(197) . chr(142) => 'O', chr(197) . chr(143) => 'o', chr(197) . chr(144) => 'O', chr(197) . chr(145) => 'o', chr(197) . chr(146) => 'OE', chr(197) . chr(147) => 'oe', chr(197) . chr(148) => 'R', chr(197) . chr(149) => 'r', chr(197) . chr(150) => 'R', chr(197) . chr(151) => 'r', chr(197) . chr(152) => 'R', chr(197) . chr(153) => 'r', chr(197) . chr(154) => 'S', chr(197) . chr(155) => 's', chr(197) . chr(156) => 'S', chr(197) . chr(157) => 's', chr(197) . chr(158) => 'S', chr(197) . chr(159) => 's', chr(197) . chr(160) => 'S', chr(197) . chr(161) => 's', chr(197) . chr(162) => 'T', chr(197) . chr(163) => 't', chr(197) . chr(164) => 'T', chr(197) . chr(165) => 't', chr(197) . chr(166) => 'T', chr(197) . chr(167) => 't', chr(197) . chr(168) => 'U', chr(197) . chr(169) => 'u', chr(197) . chr(170) => 'U', chr(197) . chr(171) => 'u', chr(197) . chr(172) => 'U', chr(197) . chr(173) => 'u', chr(197) . chr(174) => 'U', chr(197) . chr(175) => 'u', chr(197) . chr(176) => 'U', chr(197) . chr(177) => 'u', chr(197) . chr(178) => 'U', chr(197) . chr(179) => 'u', chr(197) . chr(180) => 'W', chr(197) . chr(181) => 'w', chr(197) . chr(182) => 'Y', chr(197) . chr(183) => 'y', chr(197) . chr(184) => 'Y', chr(197) . chr(185) => 'Z', chr(197) . chr(186) => 'z', chr(197) . chr(187) => 'Z', chr(197) . chr(188) => 'z', chr(197) . chr(189) => 'Z', chr(197) . chr(190) => 'z', chr(197) . chr(191) => 's', chr(200) . chr(152) => 'S', chr(200) . chr(153) => 's', chr(200) . chr(154) => 'T', chr(200) . chr(155) => 't', chr(226) . chr(130) . chr(172) => 'E', chr(194) . chr(163) => '', chr(198) . chr(160) => 'O', chr(198) . chr(161) => 'o', chr(198) . chr(175) => 'U', chr(198) . chr(176) => 'u', chr(225) . chr(186) . chr(166) => 'A', chr(225) . chr(186) . chr(167) => 'a', chr(225) . chr(186) . chr(176) => 'A', chr(225) . chr(186) . chr(177) => 'a', chr(225) . chr(187) . chr(128) => 'E', chr(225) . chr(187) . chr(129) => 'e', chr(225) . chr(187) . chr(146) => 'O', chr(225) . chr(187) . chr(147) => 'o', chr(225) . chr(187) . chr(156) => 'O', chr(225) . chr(187) . chr(157) => 'o', chr(225) . chr(187) . chr(170) => 'U', chr(225) . chr(187) . chr(171) => 'u', chr(225) . chr(187) . chr(178) => 'Y', chr(225) . chr(187) . chr(179) => 'y', chr(225) . chr(186) . chr(162) => 'A', chr(225) . chr(186) . chr(163) => 'a', chr(225) . chr(186) . chr(168) => 'A', chr(225) . chr(186) . chr(169) => 'a', chr(225) . chr(186) . chr(178) => 'A', chr(225) . chr(186) . chr(179) => 'a', chr(225) . chr(186) . chr(186) => 'E', chr(225) . chr(186) . chr(187) => 'e', chr(225) . chr(187) . chr(130) => 'E', chr(225) . chr(187) . chr(131) => 'e', chr(225) . chr(187) . chr(136) => 'I', chr(225) . chr(187) . chr(137) => 'i', chr(225) . chr(187) . chr(142) => 'O', chr(225) . chr(187) . chr(143) => 'o', chr(225) . chr(187) . chr(148) => 'O', chr(225) . chr(187) . chr(149) => 'o', chr(225) . chr(187) . chr(158) => 'O', chr(225) . chr(187) . chr(159) => 'o', chr(225) . chr(187) . chr(166) => 'U', chr(225) . chr(187) . chr(167) => 'u', chr(225) . chr(187) . chr(172) => 'U', chr(225) . chr(187) . chr(173) => 'u', chr(225) . chr(187) . chr(182) => 'Y', chr(225) . chr(187) . chr(183) => 'y', chr(225) . chr(186) . chr(170) => 'A', chr(225) . chr(186) . chr(171) => 'a', chr(225) . chr(186) . chr(180) => 'A', chr(225) . chr(186) . chr(181) => 'a', chr(225) . chr(186) . chr(188) => 'E', chr(225) . chr(186) . chr(189) => 'e', chr(225) . chr(187) . chr(132) => 'E', chr(225) . chr(187) . chr(133) => 'e', chr(225) . chr(187) . chr(150) => 'O', chr(225) . chr(187) . chr(151) => 'o', chr(225) . chr(187) . chr(160) => 'O', chr(225) . chr(187) . chr(161) => 'o', chr(225) . chr(187) . chr(174) => 'U', chr(225) . chr(187) . chr(175) => 'u', chr(225) . chr(187) . chr(184) => 'Y', chr(225) . chr(187) . chr(185) => 'y', chr(225) . chr(186) . chr(164) => 'A', chr(225) . chr(186) . chr(165) => 'a', chr(225) . chr(186) . chr(174) => 'A', chr(225) . chr(186) . chr(175) => 'a', chr(225) . chr(186) . chr(190) => 'E', chr(225) . chr(186) . chr(191) => 'e', chr(225) . chr(187) . chr(144) => 'O', chr(225) . chr(187) . chr(145) => 'o', chr(225) . chr(187) . chr(154) => 'O', chr(225) . chr(187) . chr(155) => 'o', chr(225) . chr(187) . chr(168) => 'U', chr(225) . chr(187) . chr(169) => 'u', chr(225) . chr(186) . chr(160) => 'A', chr(225) . chr(186) . chr(161) => 'a', chr(225) . chr(186) . chr(172) => 'A', chr(225) . chr(186) . chr(173) => 'a', chr(225) . chr(186) . chr(182) => 'A', chr(225) . chr(186) . chr(183) => 'a', chr(225) . chr(186) . chr(184) => 'E', chr(225) . chr(186) . chr(185) => 'e', chr(225) . chr(187) . chr(134) => 'E', chr(225) . chr(187) . chr(135) => 'e', chr(225) . chr(187) . chr(138) => 'I', chr(225) . chr(187) . chr(139) => 'i', chr(225) . chr(187) . chr(140) => 'O', chr(225) . chr(187) . chr(141) => 'o', chr(225) . chr(187) . chr(152) => 'O', chr(225) . chr(187) . chr(153) => 'o', chr(225) . chr(187) . chr(162) => 'O', chr(225) . chr(187) . chr(163) => 'o', chr(225) . chr(187) . chr(164) => 'U', chr(225) . chr(187) . chr(165) => 'u', chr(225) . chr(187) . chr(176) => 'U', chr(225) . chr(187) . chr(177) => 'u', chr(225) . chr(187) . chr(180) => 'Y', chr(225) . chr(187) . chr(181) => 'y', chr(201) . chr(145) => 'a', chr(199) . chr(149) => 'U', chr(199) . chr(150) => 'u', chr(199) . chr(151) => 'U', chr(199) . chr(152) => 'u', chr(199) . chr(141) => 'A', chr(199) . chr(142) => 'a', chr(199) . chr(143) => 'I', chr(199) . chr(144) => 'i', chr(199) . chr(145) => 'O', chr(199) . chr(146) => 'o', chr(199) . chr(147) => 'U', chr(199) . chr(148) => 'u', chr(199) . chr(153) => 'U', chr(199) . chr(154) => 'u', chr(199) . chr(155) => 'U', chr(199) . chr(156) => 'u');
            $locale = RC_Locale::get_locale();
            if ('de_DE' == $locale) {
                $chars[chr(195) . chr(132)] = 'Ae';
                $chars[chr(195) . chr(164)] = 'ae';
                $chars[chr(195) . chr(150)] = 'Oe';
                $chars[chr(195) . chr(182)] = 'oe';
                $chars[chr(195) . chr(156)] = 'Ue';
                $chars[chr(195) . chr(188)] = 'ue';
                $chars[chr(195) . chr(159)] = 'ss';
            } elseif ('da_DK' === $locale) {
                $chars[chr(195) . chr(134)] = 'Ae';
                $chars[chr(195) . chr(166)] = 'ae';
                $chars[chr(195) . chr(152)] = 'Oe';
                $chars[chr(195) . chr(184)] = 'oe';
                $chars[chr(195) . chr(133)] = 'Aa';
                $chars[chr(195) . chr(165)] = 'aa';
            }
            $string = strtr($string, $chars);
        } else {
            $chars['in'] = chr(128) . chr(131) . chr(138) . chr(142) . chr(154) . chr(158) . chr(159) . chr(162) . chr(165) . chr(181) . chr(192) . chr(193) . chr(194) . chr(195) . chr(196) . chr(197) . chr(199) . chr(200) . chr(201) . chr(202) . chr(203) . chr(204) . chr(205) . chr(206) . chr(207) . chr(209) . chr(210) . chr(211) . chr(212) . chr(213) . chr(214) . chr(216) . chr(217) . chr(218) . chr(219) . chr(220) . chr(221) . chr(224) . chr(225) . chr(226) . chr(227) . chr(228) . chr(229) . chr(231) . chr(232) . chr(233) . chr(234) . chr(235) . chr(236) . chr(237) . chr(238) . chr(239) . chr(241) . chr(242) . chr(243) . chr(244) . chr(245) . chr(246) . chr(248) . chr(249) . chr(250) . chr(251) . chr(252) . chr(253) . chr(255);
            $chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy";
            $string = strtr($string, $chars['in'], $chars['out']);
            $double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254));
            $double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th');
            $string = str_replace($double_chars['in'], $double_chars['out'], $string);
        }
        return $string;
    }
    public static function seems_utf8($str)
    {
        $length = strlen($str);
        for ($i = 0; $i < $length; $i++) {
            $c = ord($str[$i]);
            if ($c < 0x80) {
                $n = 0;
            } elseif (($c & 0xe0) == 0xc0) {
                $n = 1;
            } elseif (($c & 0xf0) == 0xe0) {
                $n = 2;
            } elseif (($c & 0xf8) == 0xf0) {
                $n = 3;
            } elseif (($c & 0xfc) == 0xf8) {
                $n = 4;
            } elseif (($c & 0xfe) == 0xfc) {
                $n = 5;
            } else {
                return false;
            }
            for ($j = 0; $j < $n; $j++) {
                if (++$i == $length || (ord($str[$i]) & 0xc0) != 0x80) {
                    return false;
                }
            }
        }
        return true;
    }
    public static function sanitize_html_class($class, $fallback = '')
    {
        $sanitized = preg_replace('|%[a-fA-F0-9][a-fA-F0-9]|', '', $class);
        $sanitized = preg_replace('/[^A-Za-z0-9_-]/', '', $sanitized);
        if ('' == $sanitized) {
            $sanitized = $fallback;
        }
        return RC_Hook::apply_filters('sanitize_html_class', $sanitized, $class, $fallback);
    }
    public static function sanitize_url($url, $check = 'http://')
    {
        if (strpos($url, $check) === false) {
            $url = $check . $url;
        }
        return $url;
    }
    public static function sanitize_key($key)
    {
        $raw_key = $key;
        $key = strtolower($key);
        $key = preg_replace('/[^a-z0-9_\\-]/', '', $key);
        return RC_Hook::apply_filters('sanitize_key', $key, $raw_key);
    }
    public static function sanitize_email($email)
    {
        if (strlen($email) < 3) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'email_too_short');
        }
        if (strpos($email, '@', 1) === false) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'email_no_at');
        }
        list($local, $domain) = explode('@', $email, 2);
        $local = preg_replace('/[^a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~\\.-]/', '', $local);
        if ('' === $local) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'local_invalid_chars');
        }
        $domain = preg_replace('/\\.{2,}/', '', $domain);
        if ('' === $domain) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'domain_period_sequence');
        }
        $domain = trim($domain, " \t\n\r \v.");
        if ('' === $domain) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'domain_period_limits');
        }
        $subs = explode('.', $domain);
        if (2 > count($subs)) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'domain_no_periods');
        }
        $new_subs = array();
        foreach ($subs as $sub) {
            $sub = trim($sub, " \t\n\r \v-");
            $sub = preg_replace('/[^a-z0-9-]+/i', '', $sub);
            if ('' !== $sub) {
                $new_subs[] = $sub;
            }
        }
        if (2 > count($new_subs)) {
            return RC_Hook::apply_filters('sanitize_email', '', $email, 'domain_no_valid_subs');
        }
        $domain = join('.', $new_subs);
        $email = $local . '@' . $domain;
        return RC_Hook::apply_filters('sanitize_email', $email, $email, null);
    }
    public static function is_serialized_string($data)
    {
        if (!is_string($data)) {
            return false;
        }
        $data = trim($data);
        if (strlen($data) < 4) {
            return false;
        } elseif (':' !== $data[1]) {
            return false;
        } elseif (';' !== substr($data, -1)) {
            return false;
        } elseif ($data[0] !== 's') {
            return false;
        } elseif ('"' !== substr($data, -2, 1)) {
            return false;
        } else {
            return true;
        }
    }
    public static function maybe_serialize($data)
    {
        if (is_array($data) || is_object($data)) {
            return serialize($data);
        }
        if (self::is_serialized($data, false)) {
            return serialize($data);
        }
        return $data;
    }
    public static function maybe_unserialize($original)
    {
        if (self::is_serialized($original)) {
            return @unserialize($original);
        }
        return $original;
    }
    public static function is_serialized($data, $strict = true)
    {
        if (!is_string($data)) {
            return false;
        }
        $data = trim($data);
        if ('N;' == $data) {
            return true;
        }
        if (strlen($data) < 4) {
            return false;
        }
        if (':' !== $data[1]) {
            return false;
        }
        if ($strict) {
            $lastc = substr($data, -1);
            if (';' !== $lastc && '}' !== $lastc) {
                return false;
            }
        } else {
            $semicolon = strpos($data, ';');
            $brace = strpos($data, '}');
            if (false === $semicolon && false === $brace) {
                return false;
            }
            if (false !== $semicolon && $semicolon < 3) {
                return false;
            }
            if (false !== $brace && $brace < 4) {
                return false;
            }
        }
        $token = $data[0];
        switch ($token) {
            case 's':
                if ($strict) {
                    if ('"' !== substr($data, -2, 1)) {
                        return false;
                    }
                } elseif (false === strpos($data, '"')) {
                    return false;
                }
            case 'a':
            case 'O':
                return (bool) preg_match("/^{$token}:[0-9]+:/s", $data);
            case 'b':
            case 'i':
            case 'd':
                $end = $strict ? '$' : '';
                return (bool) preg_match("/^{$token}:[0-9.E-]+;{$end}/", $data);
        }
        return false;
    }
    public static function removeEmoji($text)
    {
        $clean_text = "";
        $regexEmoticons = '/[\\x{1F600}-\\x{1F64F}]/u';
        $clean_text = preg_replace($regexEmoticons, '', $text);
        $regexSymbols = '/[\\x{1F300}-\\x{1F5FF}]/u';
        $clean_text = preg_replace($regexSymbols, '', $clean_text);
        $regexTransport = '/[\\x{1F680}-\\x{1F6FF}]/u';
        $clean_text = preg_replace($regexTransport, '', $clean_text);
        $regexMisc = '/[\\x{2600}-\\x{26FF}]/u';
        $clean_text = preg_replace($regexMisc, '', $clean_text);
        $regexDingbats = '/[\\x{2700}-\\x{27BF}]/u';
        $clean_text = preg_replace($regexDingbats, '', $clean_text);
        return $clean_text;
    }
    public static function filterEmoji($str)
    {
        $str = preg_replace_callback('/./u', function (array $match) {
            return strlen($match[0]) >= 4 ? '' : $match[0];
        }, $str);
        return $str;
    }
}
}

namespace Royalcms\Component\Support\Facades {
use Mockery;
use RuntimeException;
use Mockery\MockInterface;
abstract class Facade
{
    protected static $royalcms;
    protected static $resolvedInstance;
    public static function swap($instance)
    {
        static::$resolvedInstance[static::getFacadeAccessor()] = $instance;
        static::$royalcms->instance(static::getFacadeAccessor(), $instance);
    }
    public static function shouldReceive()
    {
        $name = static::getFacadeAccessor();
        if (static::isMock()) {
            $mock = static::$resolvedInstance[$name];
        } else {
            $mock = static::createFreshMockInstance($name);
        }
        return call_user_func_array([$mock, 'shouldReceive'], func_get_args());
    }
    protected static function createFreshMockInstance($name)
    {
        static::$resolvedInstance[$name] = $mock = static::createMockByName($name);
        $mock->shouldAllowMockingProtectedMethods();
        if (isset(static::$royalcms)) {
            static::$royalcms->instance($name, $mock);
        }
        return $mock;
    }
    protected static function createMockByName($name)
    {
        $class = static::getMockableClass($name);
        return $class ? Mockery::mock($class) : Mockery::mock();
    }
    protected static function isMock()
    {
        $name = static::getFacadeAccessor();
        return isset(static::$resolvedInstance[$name]) && static::$resolvedInstance[$name] instanceof MockInterface;
    }
    protected static function getMockableClass()
    {
        if ($root = static::getFacadeRoot()) {
            return get_class($root);
        }
    }
    public static function getFacadeRoot()
    {
        return static::resolveFacadeInstance(static::getFacadeAccessor());
    }
    protected static function getFacadeAccessor()
    {
        throw new RuntimeException('Facade does not implement getFacadeAccessor method.');
    }
    protected static function resolveFacadeInstance($name)
    {
        if (is_object($name)) {
            return $name;
        }
        if (isset(static::$resolvedInstance[$name])) {
            return static::$resolvedInstance[$name];
        }
        return static::$resolvedInstance[$name] = static::$royalcms[$name];
    }
    public static function clearResolvedInstance($name)
    {
        unset(static::$resolvedInstance[$name]);
    }
    public static function clearResolvedInstances()
    {
        static::$resolvedInstance = [];
    }
    public static function getFacadeRoyalcms()
    {
        return static::$royalcms;
    }
    public static function setFacadeRoyalcms($royalcms)
    {
        static::$royalcms = $royalcms;
    }
    public static function __callStatic($method, $args)
    {
        $instance = static::getFacadeRoot();
        if (!$instance) {
            throw new RuntimeException('A facade root has not been set.');
        }
        switch (count($args)) {
            case 0:
                return $instance->{$method}();
            case 1:
                return $instance->{$method}($args[0]);
            case 2:
                return $instance->{$method}($args[0], $args[1]);
            case 3:
                return $instance->{$method}($args[0], $args[1], $args[2]);
            case 4:
                return $instance->{$method}($args[0], $args[1], $args[2], $args[3]);
            default:
                return call_user_func_array([$instance, $method], $args);
        }
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Royalcms extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'royalcms';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Route extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'router';
    }
    public static function is($name)
    {
        return static::$royalcms['router']->currentRouteNamed($name);
    }
    public static function uses($action)
    {
        return static::$royalcms['router']->currentRouteUses($action);
    }
}
}

namespace Royalcms\Component\Support\Facades {
class View extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'view';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Log extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'log';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class DB extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'db';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Request extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'request';
    }
}
}

namespace Royalcms\Component\Support\Facades {
use Royalcms\Component\Support\Traits\Macroable;
class Response extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'Royalcms\\Component\\Contracts\\Routing\\ResponseFactory';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Config extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'config';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Session extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'session';
    }
    public static function start()
    {
        return royalcms('session.start')->start(royalcms('request'));
    }
    public static function close()
    {
        return royalcms('session.start')->close();
    }
}
}

namespace Royalcms\Component\Support\Facades {
use Royalcms\Component\Translation\CompatibleTrait;
class Lang extends Facade
{
    use CompatibleTrait;
    protected static function getFacadeAccessor()
    {
        return 'translator';
    }
}
}

namespace Royalcms\Component\Support\Facades {
use Royalcms\Component\Cache\SpecialStores\AppCache;
use Royalcms\Component\Cache\SpecialStores\UserDataCache;
use Royalcms\Component\Cache\SpecialStores\TableCache;
use Royalcms\Component\Cache\SpecialStores\QueryCache;
use Royalcms\Component\Cache\SpecialStores\MemoryCache;
class Cache extends Facade
{
    use AppCache, UserDataCache, TableCache, QueryCache, MemoryCache;
    protected static function getFacadeAccessor()
    {
        return 'cache';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Event extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'events';
    }
}
}

namespace Royalcms\Component\Support\Facades {
use Royalcms\Component\Filesystem\FileHelperTrait;
class File extends Facade
{
    use FileHelperTrait;
    protected static function getFacadeAccessor()
    {
        return 'files';
    }
}
}

namespace Royalcms\Component\Support\Facades {
class Logger extends Facade
{
    const LOG_ERROR = 'error';
    const LOG_SQL = 'sql';
    const LOG_WARNING = 'warning';
    protected static function getFacadeAccessor()
    {
        return 'log.store';
    }
}
}

namespace Royalcms\Component\Validation {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Contracts\Validation\ValidatesWhenResolved;
class ValidationServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerValidationResolverHook();
        $this->registerPresenceVerifier();
        $this->registerValidationFactory();
    }
    protected function registerValidationResolverHook()
    {
        $this->royalcms->afterResolving(function (ValidatesWhenResolved $resolved) {
            $resolved->validate();
        });
    }
    protected function registerValidationFactory()
    {
        $this->royalcms->singleton('validator', function ($royalcms) {
            $validator = new Factory($royalcms['translator'], $royalcms);
            if (isset($royalcms['validation.presence'])) {
                $validator->setPresenceVerifier($royalcms['validation.presence']);
            }
            return $validator;
        });
    }
    protected function registerPresenceVerifier()
    {
        $this->royalcms->singleton('validation.presence', function ($royalcms) {
            return new DatabasePresenceVerifier($royalcms['db']);
        });
    }
}
}

namespace Royalcms\Component\Validation {
use Royalcms\Component\Contracts\Validation\ValidationException;
use Royalcms\Component\Contracts\Validation\UnauthorizedException;
trait ValidatesWhenResolvedTrait
{
    public function validate()
    {
        $instance = $this->getValidatorInstance();
        if (!$this->passesAuthorization()) {
            $this->failedAuthorization();
        } elseif (!$instance->passes()) {
            $this->failedValidation($instance);
        }
    }
    protected function getValidatorInstance()
    {
        return $this->validator();
    }
    protected function failedValidation(Validator $validator)
    {
        throw new ValidationException($validator);
    }
    protected function passesAuthorization()
    {
        if (method_exists($this, 'authorize')) {
            return $this->authorize();
        }
        return true;
    }
    protected function failedAuthorization()
    {
        throw new UnauthorizedException();
    }
}
}

namespace Royalcms\Component\Hashing {
use Royalcms\Component\Support\ServiceProvider;
class HashServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->singleton('hash', function () {
            return new BcryptHasher();
        });
    }
    public function provides()
    {
        return ['hash'];
    }
}
}

namespace Royalcms\Component\Hashing {
use RuntimeException;
use Royalcms\Component\Contracts\Hashing\Hasher as HasherContract;
class BcryptHasher implements HasherContract
{
    protected $rounds = 10;
    public function make($value, array $options = [])
    {
        $cost = isset($options['rounds']) ? $options['rounds'] : $this->rounds;
        $hash = password_hash($value, PASSWORD_BCRYPT, ['cost' => $cost]);
        if ($hash === false) {
            throw new RuntimeException('Bcrypt hashing not supported.');
        }
        return $hash;
    }
    public function check($value, $hashedValue, array $options = [])
    {
        if (strlen($hashedValue) === 0) {
            return false;
        }
        return password_verify($value, $hashedValue);
    }
    public function needsRehash($hashedValue, array $options = [])
    {
        $cost = isset($options['rounds']) ? $options['rounds'] : $this->rounds;
        return password_needs_rehash($hashedValue, PASSWORD_BCRYPT, ['cost' => $cost]);
    }
    public function setRounds($rounds)
    {
        $this->rounds = (int) $rounds;
        return $this;
    }
}
}

namespace Royalcms\Component\Pagination {
use Closure;
use ArrayIterator;
abstract class AbstractPaginator
{
    protected $items;
    protected $perPage;
    protected $currentPage;
    protected $path = '/';
    protected $query = [];
    protected $fragment = null;
    protected $pageName = 'page';
    protected static $currentPathResolver;
    protected static $currentPageResolver;
    protected static $presenterResolver;
    protected function isValidPageNumber($page)
    {
        return $page >= 1 && filter_var($page, FILTER_VALIDATE_INT) !== false;
    }
    public function getUrlRange($start, $end)
    {
        $urls = [];
        for ($page = $start; $page <= $end; $page++) {
            $urls[$page] = $this->url($page);
        }
        return $urls;
    }
    public function url($page)
    {
        if ($page <= 0) {
            $page = 1;
        }
        $parameters = [$this->pageName => $page];
        if (count($this->query) > 0) {
            $parameters = array_merge($this->query, $parameters);
        }
        return $this->path . '?' . http_build_query($parameters, '', '&') . $this->buildFragment();
    }
    public function previousPageUrl()
    {
        if ($this->currentPage() > 1) {
            return $this->url($this->currentPage() - 1);
        }
    }
    public function fragment($fragment = null)
    {
        if (is_null($fragment)) {
            return $this->fragment;
        }
        $this->fragment = $fragment;
        return $this;
    }
    public function appends($key, $value = null)
    {
        if (is_array($key)) {
            return $this->appendArray($key);
        }
        return $this->addQuery($key, $value);
    }
    protected function appendArray(array $keys)
    {
        foreach ($keys as $key => $value) {
            $this->addQuery($key, $value);
        }
        return $this;
    }
    public function addQuery($key, $value)
    {
        if ($key !== $this->pageName) {
            $this->query[$key] = $value;
        }
        return $this;
    }
    protected function buildFragment()
    {
        return $this->fragment ? '#' . $this->fragment : '';
    }
    public function items()
    {
        return $this->items->all();
    }
    public function firstItem()
    {
        return ($this->currentPage - 1) * $this->perPage + 1;
    }
    public function lastItem()
    {
        return $this->firstItem() + $this->count() - 1;
    }
    public function perPage()
    {
        return $this->perPage;
    }
    public function currentPage()
    {
        return $this->currentPage;
    }
    public function hasPages()
    {
        return !($this->currentPage() == 1 && !$this->hasMorePages());
    }
    public static function resolveCurrentPath($default = '/')
    {
        if (isset(static::$currentPathResolver)) {
            return call_user_func(static::$currentPathResolver);
        }
        return $default;
    }
    public static function currentPathResolver(Closure $resolver)
    {
        static::$currentPathResolver = $resolver;
    }
    public static function resolveCurrentPage($pageName = 'page', $default = 1)
    {
        if (isset(static::$currentPageResolver)) {
            return call_user_func(static::$currentPageResolver, $pageName);
        }
        return $default;
    }
    public static function currentPageResolver(Closure $resolver)
    {
        static::$currentPageResolver = $resolver;
    }
    public static function presenter(Closure $resolver)
    {
        static::$presenterResolver = $resolver;
    }
    public function getPageName()
    {
        return $this->pageName;
    }
    public function setPageName($name)
    {
        $this->pageName = $name;
        return $this;
    }
    public function setPath($path)
    {
        $this->path = $path;
        return $this;
    }
    public function getIterator()
    {
        return new ArrayIterator($this->items->all());
    }
    public function isEmpty()
    {
        return $this->items->isEmpty();
    }
    public function count()
    {
        return $this->items->count();
    }
    public function getCollection()
    {
        return $this->items;
    }
    public function offsetExists($key)
    {
        return $this->items->has($key);
    }
    public function offsetGet($key)
    {
        return $this->items->get($key);
    }
    public function offsetSet($key, $value)
    {
        $this->items->put($key, $value);
    }
    public function offsetUnset($key)
    {
        $this->items->forget($key);
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->getCollection(), $method], $parameters);
    }
    public function __toString()
    {
        return $this->render();
    }
}
}

namespace Royalcms\Component\Pagination {
use Countable;
use ArrayAccess;
use IteratorAggregate;
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Contracts\Pagination\Presenter;
use Royalcms\Component\Contracts\Pagination\Paginator as PaginatorContract;
class Paginator extends AbstractPaginator implements Arrayable, ArrayAccess, Countable, IteratorAggregate, Jsonable, PaginatorContract
{
    protected $hasMore;
    public function __construct($items, $perPage, $currentPage = null, array $options = [])
    {
        foreach ($options as $key => $value) {
            $this->{$key} = $value;
        }
        $this->perPage = $perPage;
        $this->currentPage = $this->setCurrentPage($currentPage);
        $this->path = $this->path != '/' ? rtrim($this->path, '/') : $this->path;
        $this->items = $items instanceof Collection ? $items : Collection::make($items);
        $this->checkForMorePages();
    }
    protected function setCurrentPage($currentPage)
    {
        $currentPage = $currentPage ?: static::resolveCurrentPage();
        return $this->isValidPageNumber($currentPage) ? (int) $currentPage : 1;
    }
    protected function checkForMorePages()
    {
        $this->hasMore = count($this->items) > $this->perPage;
        $this->items = $this->items->slice(0, $this->perPage);
    }
    public function nextPageUrl()
    {
        if ($this->hasMore) {
            return $this->url($this->currentPage() + 1);
        }
    }
    public function hasMorePages()
    {
        return $this->hasMore;
    }
    public function render(Presenter $presenter = null)
    {
        if (is_null($presenter) && static::$presenterResolver) {
            $presenter = call_user_func(static::$presenterResolver, $this);
        }
        $presenter = $presenter ?: new SimpleBootstrapThreePresenter($this);
        return $presenter->render();
    }
    public function toArray()
    {
        return ['per_page' => $this->perPage(), 'current_page' => $this->currentPage(), 'next_page_url' => $this->nextPageUrl(), 'prev_page_url' => $this->previousPageUrl(), 'from' => $this->firstItem(), 'to' => $this->lastItem(), 'data' => $this->items->toArray()];
    }
    public function toJson($options = 0)
    {
        return json_encode($this->toArray(), $options);
    }
}
}

namespace Royalcms\Component\Pagination {
use Royalcms\Component\Support\ServiceProvider;
class PaginationServiceProvider extends ServiceProvider
{
    public function register()
    {
        Paginator::currentPathResolver(function () {
            return $this->app['request']->url();
        });
        Paginator::currentPageResolver(function ($pageName = 'page') {
            $page = $this->app['request']->input($pageName);
            if (filter_var($page, FILTER_VALIDATE_INT) !== false && (int) $page >= 1) {
                return $page;
            }
            return 1;
        });
    }
}
}

namespace Royalcms\Component\Config {
use Closure;
use ArrayAccess;
use Royalcms\Component\Support\NamespacedItemResolver;
use Royalcms\Component\Contracts\Config\Repository as ConfigContract;
class Repository extends NamespacedItemResolver implements ArrayAccess, ConfigContract
{
    use CompatibleTrait;
    protected $loader;
    protected $environment;
    protected $items = array();
    protected $packages = array();
    protected $afterLoad = array();
    public function __construct(LoaderInterface $loader, $environment, array $items = [])
    {
        $this->loader = $loader;
        $this->environment = $environment;
        $this->items = $items;
    }
    public function has($key)
    {
        $default = microtime(true);
        return $this->get($key, $default) !== $default;
    }
    public function hasGroup($key)
    {
        list($namespace, $group, $item) = $this->parseKey($key);
        return $this->loader->exists($group, $namespace);
    }
    public function get($key, $default = null)
    {
        list($namespace, $group, $item) = $this->parseKey($key);
        $collection = $this->getCollection($group, $namespace);
        $this->load($group, $namespace, $collection);
        return array_get($this->items[$collection], $item, $default);
    }
    public function set($key, $value = null)
    {
        list($namespace, $group, $item) = $this->parseKey($key);
        $collection = $this->getCollection($group, $namespace);
        $this->load($group, $namespace, $collection);
        if (is_null($item)) {
            $this->items[$collection] = $value;
        } else {
            array_set($this->items[$collection], $item, $value);
        }
    }
    public function prepend($key, $value)
    {
        $array = $this->get($key);
        array_unshift($array, $value);
        $this->set($key, $array);
    }
    public function push($key, $value)
    {
        $array = $this->get($key);
        $array[] = $value;
        $this->set($key, $array);
    }
    public function all()
    {
        return $this->items;
    }
    protected function load($group, $namespace, $collection)
    {
        $env = $this->environment;
        if (isset($this->items[$collection])) {
            return;
        }
        $items = $this->loader->load($env, $group, $namespace);
        if (isset($this->afterLoad[$namespace])) {
            $items = $this->callAfterLoad($namespace, $group, $items);
        }
        $this->items[$collection] = $items;
    }
    protected function callAfterLoad($namespace, $group, $items)
    {
        $callback = $this->afterLoad[$namespace];
        return call_user_func($callback, $this, $group, $items);
    }
    protected function parseNamespacedSegments($key)
    {
        list($namespace, $item) = explode('::', $key);
        if (in_array($namespace, $this->packages)) {
            return $this->parsePackageSegments($key, $namespace, $item);
        }
        return parent::parseNamespacedSegments($key);
    }
    protected function parsePackageSegments($key, $namespace, $item)
    {
        $itemSegments = explode('.', $item);
        if (!$this->loader->exists($itemSegments[0], $namespace)) {
            return array($namespace, 'config', $item);
        }
        return parent::parseNamespacedSegments($key);
    }
    public function package($package, $hint, $namespace = null)
    {
        $namespace = $this->getPackageNamespace($package, $namespace);
        $this->packages[] = $namespace;
        $this->addNamespace($namespace, $hint);
        $this->afterLoading($namespace, function ($me, $group, $items) use($package) {
            $env = $me->getEnvironment();
            $loader = $me->getLoader();
            return $loader->cascadePackage($env, $package, $group, $items);
        });
    }
    protected function getPackageNamespace($package, $namespace)
    {
        if (is_null($namespace)) {
            list($vendor, $namespace) = explode('/', $package);
        }
        return $namespace;
    }
    public function afterLoading($namespace, Closure $callback)
    {
        $this->afterLoad[$namespace] = $callback;
    }
    protected function getCollection($group, $namespace = null)
    {
        $namespace = $namespace ?: '*';
        return $namespace . '::' . $group;
    }
    public function addNamespace($namespace, $hint)
    {
        $this->loader->addNamespace($namespace, $hint);
    }
    public function getNamespaces()
    {
        return $this->loader->getNamespaces();
    }
    public function getLoader()
    {
        return $this->loader;
    }
    public function setLoader(LoaderInterface $loader)
    {
        $this->loader = $loader;
    }
    public function getEnvironment()
    {
        return $this->environment;
    }
    public function getAfterLoadCallbacks()
    {
        return $this->afterLoad;
    }
    public function getItems()
    {
        return $this->items;
    }
    public function offsetExists($key)
    {
        return $this->has($key);
    }
    public function offsetGet($key)
    {
        return $this->get($key);
    }
    public function offsetSet($key, $value)
    {
        $this->set($key, $value);
    }
    public function offsetUnset($key)
    {
        $this->set($key, null);
    }
}
}

namespace Royalcms\Component\Config {
interface LoaderInterface
{
    public function load($environment, $group, $namespace = null);
    public function exists($group, $namespace = null);
    public function addNamespace($namespace, $hint);
    public function getNamespaces();
    public function cascadePackage($environment, $package, $group, $items);
}
}

namespace Royalcms\Component\Config {
interface EnvironmentVariablesLoaderInterface
{
    public function load($environment = null);
}
}

namespace Royalcms\Component\Config {
use Royalcms\Component\Filesystem\Filesystem;
class FileEnvironmentVariablesLoader implements EnvironmentVariablesLoaderInterface
{
    protected $files;
    protected $path;
    public function __construct(Filesystem $files, $path = null)
    {
        $this->files = $files;
        $this->path = $path ?: base_path();
    }
    public function load($environment = null)
    {
        if ($environment == 'production') {
            $environment = null;
        }
        if (!$this->files->exists($path = $this->getFile($environment))) {
            return array();
        } else {
            return $this->files->getRequire($path);
        }
    }
    protected function getFile($environment)
    {
        if ($environment) {
            return $this->path . '/.env.' . $environment . '.php';
        } else {
            return $this->path . '/.env.php';
        }
    }
}
}

namespace Royalcms\Component\Config {
class EnvironmentVariables
{
    protected $loader;
    public function __construct(EnvironmentVariablesLoaderInterface $loader)
    {
        $this->loader = $loader;
    }
    public function load($environment = null)
    {
        foreach ($this->loader->load($environment) as $key => $value) {
            $_ENV[$key] = $value;
            $_SERVER[$key] = $value;
            putenv("{$key}={$value}");
        }
    }
}
}

namespace Royalcms\Component\Config {
class Dotenv
{
    protected static $immutable = true;
    public static function load($path, $file = '.env')
    {
        if (!is_string($file)) {
            $file = '.env';
        }
        $filePath = rtrim($path, '/') . '/' . $file;
        if (!is_readable($filePath) || !is_file($filePath)) {
            throw new \InvalidArgumentException(sprintf('Dotenv: Environment file %s not found or not readable. ' . 'Create file with your environment settings at %s', $file, $filePath));
        }
        $autodetect = ini_get('auto_detect_line_endings');
        ini_set('auto_detect_line_endings', '1');
        $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        ini_set('auto_detect_line_endings', $autodetect);
        foreach ($lines as $line) {
            if (strpos(trim($line), '#') === 0) {
                continue;
            }
            if (strpos($line, '=') !== false) {
                static::setEnvironmentVariable($line);
            }
        }
    }
    public static function setEnvironmentVariable($name, $value = null)
    {
        list($name, $value) = static::normaliseEnvironmentVariable($name, $value);
        if (static::$immutable === true && !is_null(static::findEnvironmentVariable($name))) {
            return;
        }
        putenv("{$name}={$value}");
        $_ENV[$name] = $value;
        $_SERVER[$name] = $value;
    }
    public static function required($environmentVariables, array $allowedValues = array())
    {
        $environmentVariables = (array) $environmentVariables;
        $missingEnvironmentVariables = array();
        foreach ($environmentVariables as $environmentVariable) {
            $value = static::findEnvironmentVariable($environmentVariable);
            if (is_null($value)) {
                $missingEnvironmentVariables[] = $environmentVariable;
            } elseif ($allowedValues) {
                if (!in_array($value, $allowedValues)) {
                    $missingEnvironmentVariables[] = $environmentVariable;
                }
            }
        }
        if ($missingEnvironmentVariables) {
            throw new \RuntimeException(sprintf("Required environment variable missing, or value not allowed: '%s'", implode("', '", $missingEnvironmentVariables)));
        }
        return true;
    }
    protected static function normaliseEnvironmentVariable($name, $value)
    {
        list($name, $value) = static::splitCompoundStringIntoParts($name, $value);
        $name = static::sanitiseVariableName($name);
        $value = static::sanitiseVariableValue($value);
        $value = static::resolveNestedVariables($value);
        return array($name, $value);
    }
    protected static function splitCompoundStringIntoParts($name, $value)
    {
        if (strpos($name, '=') !== false) {
            list($name, $value) = array_map('trim', explode('=', $name, 2));
        }
        return array($name, $value);
    }
    protected static function sanitiseVariableValue($value)
    {
        $value = trim($value);
        if (!$value) {
            return '';
        }
        if (strpbrk($value[0], '"\'') !== false) {
            $quote = $value[0];
            $regexPattern = sprintf('/^
                %1$s          # match a quote at the start of the value
                (             # capturing sub-pattern used
                 (?:          # we do not need to capture this
                  [^%1$s\\\\] # any character other than a quote or backslash
                  |\\\\\\\\   # or two backslashes together
                  |\\\\%1$s   # or an escaped quote e.g \\"
                 )*           # as many characters that match the previous rules
                )             # end of the capturing sub-pattern
                %1$s          # and the closing quote
                .*$           # and discard any string after the closing quote
                /mx', $quote);
            $value = preg_replace($regexPattern, '$1', $value);
            $value = str_replace("\\{$quote}", $quote, $value);
            $value = str_replace('\\\\', '\\', $value);
        } else {
            $parts = explode(' #', $value, 2);
            $value = $parts[0];
        }
        return trim($value);
    }
    protected static function sanitiseVariableName($name)
    {
        return trim(str_replace(array('export ', '\'', '"'), '', $name));
    }
    protected static function resolveNestedVariables($value)
    {
        if (strpos($value, '$') !== false) {
            $value = preg_replace_callback('/{\\$([a-zA-Z0-9_]+)}/', function ($matchedPatterns) {
                $nestedVariable = Dotenv::findEnvironmentVariable($matchedPatterns[1]);
                if (is_null($nestedVariable)) {
                    return $matchedPatterns[0];
                } else {
                    return $nestedVariable;
                }
            }, $value);
        }
        return $value;
    }
    public static function findEnvironmentVariable($name)
    {
        switch (true) {
            case array_key_exists($name, $_ENV):
                return $_ENV[$name];
            case array_key_exists($name, $_SERVER):
                return $_SERVER[$name];
            default:
                $value = getenv($name);
                return $value === false ? null : $value;
        }
    }
    public static function isImmutable()
    {
        return static::$immutable;
    }
    public static function makeImmutable()
    {
        static::$immutable = true;
    }
    public static function makeMutable()
    {
        static::$immutable = false;
    }
}
}

namespace Royalcms\Component\Config {
trait CompatibleTrait
{
    public function load_config($file, $name = '')
    {
        if ($name) {
            return $this->get($file . '.' . strtolower($name));
        } else {
            return $this->get($file);
        }
    }
    public function system($name)
    {
        return $this->get('system.' . strtolower($name));
    }
    public function cache($name)
    {
        return $this->get('cache.' . strtolower($name));
    }
    public function database($name)
    {
        return $this->get('database.' . strtolower($name));
    }
    public function mail($name)
    {
        return $this->get('mail.' . strtolower($name));
    }
    public function route($name)
    {
        return $this->get('route.' . strtolower($name));
    }
    public function session($name)
    {
        return $this->get('session.' . strtolower($name));
    }
    public function cookie($name)
    {
        return $this->get('session.' . strtolower($name));
    }
}
}

namespace Royalcms\Component\Filesystem {
use finfo;
use RC_Hook;
use RC_Format;
use RC_Config;
use Royalcms\Component\Support\Str;
trait FileHelperTrait
{
    protected static $extensionMap = ['audio/wav' => '.wav', 'audio/x-ms-wma' => '.wma', 'video/x-ms-wmv' => '.wmv', 'video/mp4' => '.mp4', 'audio/mpeg' => '.mp3', 'audio/amr' => '.amr', 'application/vnd.rn-realmedia' => '.rm', 'audio/mid' => '.mid', 'image/bmp' => '.bmp', 'image/gif' => '.gif', 'image/png' => '.png', 'image/tiff' => '.tiff', 'image/jpeg' => '.jpg', 'application/msword' => '.doc', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => '.docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template' => '.dotx', 'application/vnd.ms-word.document.macroEnabled.12' => '.docm', 'application/vnd.ms-word.template.macroEnabled.12' => '.dotm', 'application/vnd.ms-excel' => '.xls', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => '.xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template' => '.xltx', 'application/vnd.ms-excel.sheet.macroEnabled.12' => '.xlsm', 'application/vnd.ms-excel.template.macroEnabled.12' => '.xltm', 'application/vnd.ms-excel.addin.macroEnabled.12' => '.xlam', 'application/vnd.ms-excel.sheet.binary.macroEnabled.12' => '.xlsb', 'application/vnd.ms-powerpoint' => '.ppt', 'application/vnd.openxmlformats-officedocument.presentationml.presentation' => '.pptx', 'application/vnd.openxmlformats-officedocument.presentationml.template' => '.potx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow' => '.ppsx', 'application/vnd.ms-powerpoint.addin.macroEnabled.12' => '.ppam'];
    protected static $signatures = ['ffd8ff' => '.jpg', '424d' => '.bmp', '47494638' => '.gif', '89504e47' => '.png', '494433' => '.mp3', 'fffb' => '.mp3', 'fff3' => '.mp3', '3026b2758e66cf11' => '.wma', '52494646' => '.wav', '57415645' => '.wav', '41564920' => '.avi', '000001ba' => '.mpg', '000001b3' => '.mpg', '2321414d52' => '.amr'];
    public static function getStreamExt($stream)
    {
        if (is_dir(pathinfo($stream, PATHINFO_DIRNAME)) && is_readable($stream)) {
            $stream = file_get_contents($stream);
        }
        $finfo = new finfo(FILEINFO_MIME);
        $mime = strstr($finfo->buffer($stream), ';', true);
        return isset(self::$extensionMap[$mime]) ? self::$extensionMap[$mime] : self::getExtBySignature($stream);
    }
    public static function getExtBySignature($stream)
    {
        $prefix = strval(bin2hex(mb_strcut($stream, 0, 10)));
        foreach (self::$signatures as $signature => $extension) {
            if (0 === strpos($prefix, strval($signature))) {
                return $extension;
            }
        }
        return '';
    }
    public static function getFileNameExtension($filename)
    {
        return self::extension($filename);
    }
    public static function file_ext($filename)
    {
        return strtolower(trim(substr(strrchr($filename, '.'), 1, 10)));
    }
    public static function download($filepath, $filename = '')
    {
        if (!$filename) {
            $filename = basename($filepath);
        }
        if (is_ie()) {
            $filename = rawurlencode($filename);
        }
        $filetype = self::file_ext($filename);
        $filesize = sprintf("%u", filesize($filepath));
        if (ob_get_length() !== false) {
            ob_end_clean();
        }
        header('Pragma: public');
        header('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT');
        header('Cache-Control: no-store, no-cache, must-revalidate');
        header('Cache-Control: pre-check=0, post-check=0, max-age=0');
        header('Content-Transfer-Encoding: binary');
        header('Content-Encoding: none');
        header('Content-type: ' . $filetype);
        header('Content-Disposition: attachment; filename="' . $filename . '"');
        header('Content-length: ' . $filesize);
        readfile($filepath);
        exit;
    }
    public static function file_suffix($file_name, $allow_type = array())
    {
        $file_name_arr = explode('.', $file_name);
        $file_suffix = strtolower(array_pop($file_name_arr));
        if (empty($allow_type)) {
            return $file_suffix;
        } else {
            if (in_array($file_suffix, $allow_type)) {
                return true;
            } else {
                return false;
            }
        }
    }
    public static function file_merge($files, $space = false, $tag = false)
    {
        $str = '';
        foreach ($files as $file) {
            $content = trim(file_get_contents($file));
            if ($space) {
                $con = self::file_compress($content);
            }
            $str .= substr($content, -2) == '?>' ? trim(substr($con, 5, -2)) : trim($content, 5);
        }
        return $tag ? "defined('IN_ROYALCMS') or exit('No permission resources.');" . $str . "\t?>" : $str;
    }
    public static function file_compress($content)
    {
        $str = "";
        $data = token_get_all($content);
        $end = false;
        for ($i = 0, $count = count($data); $i < $count; $i++) {
            if (is_string($data[$i])) {
                $end = false;
                $str .= $data[$i];
            } else {
                switch ($data[$i][0]) {
                    case T_COMMENT:
                    case T_DOC_COMMENT:
                        break;
                    case T_WHITESPACE:
                        if (!$end) {
                            $end = true;
                            $str .= " ";
                        }
                        break;
                    case T_START_HEREDOC:
                        $str .= "<<<ROYALCMS\n";
                        break;
                    case T_END_HEREDOC:
                        $str .= "ROYALCMS;\n";
                        for ($m = $i + 1; $m < $count; $m++) {
                            if (is_string($data[$m]) && $data[$m] == ';') {
                                $i = $m;
                                break;
                            }
                            if ($data[$m] == T_CLOSE_TAG) {
                                break;
                            }
                        }
                        break;
                    default:
                        $end = false;
                        $str .= $data[$i][1];
                }
            }
        }
        return $str;
    }
    public static function get_file_data($file, $default_headers, $context = '')
    {
        $fp = fopen($file, 'r');
        $file_data = fread($fp, 8192);
        fclose($fp);
        $file_data = str_replace("\r", "\n", $file_data);
        if ($context && ($extra_headers = RC_Hook::apply_filters("extra_{$context}_headers", array()))) {
            $extra_headers = array_combine($extra_headers, $extra_headers);
            $all_headers = array_merge($extra_headers, (array) $default_headers);
        } else {
            $all_headers = $default_headers;
        }
        foreach ($all_headers as $field => $regex) {
            if (preg_match('/^[ \\t\\/*#@]*' . preg_quote($regex, '/') . ':(.*)$/mi', $file_data, $match) && $match[1]) {
                $all_headers[$field] = RC_Format::_cleanup_header_comment($match[1]);
            } else {
                $all_headers[$field] = '';
            }
        }
        return $all_headers;
    }
    public static function template_exists($template)
    {
        if (!$template) {
            return false;
        }
        $template = SITE_THEME_PATH . RC_Config::get('system.tpl_style') . DIRECTORY_SEPARATOR . $template . '.php';
        if (file_exists($template)) {
            return true;
        }
        return false;
    }
    public static function get_md5_files($currentdir, $ext = '', $sub = 1, $skip = '')
    {
        $currentdir = SITE_ROOT . str_replace(SITE_ROOT, '', $currentdir);
        $dir = opendir($currentdir);
        $exts = '/(' . $ext . ')$/i';
        $skips = explode(',', $skip);
        static $md5data = array();
        while (($entry = readdir($dir)) == true) {
            $file = $currentdir . $entry;
            if ($entry != '.' && $entry != '..' && $entry != '.svn' && $entry != '.git' && $entry != '.DS_Store' && (preg_match($exts, $entry) || $sub && is_dir($file)) && !in_array($entry, $skips)) {
                if ($sub && is_dir($file)) {
                    $md5data = self::get_md5_files($file . '/', $ext, $sub, $skip);
                } else {
                    $md5data[str_replace(SITE_ROOT, '', $file)] = md5_file($file);
                }
            }
        }
        return $md5data;
    }
    public static function file_mode_info($file_path)
    {
        if (!file_exists($file_path)) {
            return false;
        }
        $mark = 0;
        if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
            $test_file = $file_path . '/cf_test.txt';
            if (is_dir($file_path)) {
                $dir = opendir($file_path);
                if ($dir === false) {
                    return $mark;
                }
                if (readdir($dir) !== false) {
                    $mark ^= 1;
                }
                closedir($dir);
                $fp = fopen($test_file, 'wb');
                if ($fp === false) {
                    return $mark;
                }
                if (fwrite($fp, 'directory access testing.') !== false) {
                    $mark ^= 2;
                }
                fclose($fp);
                unlink($test_file);
                $fp = fopen($test_file, 'ab+');
                if ($fp === false) {
                    return $mark;
                }
                if (fwrite($fp, "modify test.\r\n") !== false) {
                    $mark ^= 4;
                }
                fclose($fp);
                if (rename($test_file, $test_file) !== false) {
                    $mark ^= 8;
                }
                unlink($test_file);
            } elseif (is_file($file_path)) {
                $fp = fopen($file_path, 'rb');
                if ($fp) {
                    $mark ^= 1;
                }
                fclose($fp);
                $fp = fopen($file_path, 'ab+');
                if ($fp && fwrite($fp, '') !== false) {
                    $mark ^= 6;
                }
                fclose($fp);
                if (rename($test_file, $test_file) !== false) {
                    $mark ^= 8;
                }
            }
        } else {
            if (is_readable($file_path)) {
                $mark ^= 1;
            }
            if (is_writable($file_path)) {
                $mark ^= 14;
            }
        }
        return $mark;
    }
    public static function check_file_purview($arr, &$err_msg)
    {
        $read = true;
        $writen = true;
        $modify = true;
        foreach ($arr as $val) {
            $mark = self::file_mode_info(SITE_ROOT . $val);
            if (($mark & 1) < 1) {
                $read = false;
                $err_msg['r'][] = $val;
            }
            if (($mark & 2) < 1) {
                $writen = false;
                $err_msg['w'][] = $val;
            }
            if (($mark & 4) < 1) {
                $modify = false;
                $err_msg['m'][] = $val;
            }
        }
        $mark = 0;
        if ($read) {
            $mark ^= 1;
        }
        if ($writen) {
            $mark ^= 2;
        }
        if ($modify) {
            $mark ^= 4;
        }
        return $mark;
    }
    function check_file_type($filename, $realname = '', $limit_ext_types = '')
    {
        if ($realname) {
            $extname = strtolower(substr($realname, strrpos($realname, '.') + 1));
        } else {
            $extname = strtolower(substr($filename, strrpos($filename, '.') + 1));
        }
        if ($limit_ext_types && stristr($limit_ext_types, '|' . $extname . '|') === false) {
            return '';
        }
        $str = $format = '';
        $file = fopen($filename, 'rb');
        if ($file) {
            $str = fread($file, 0x400);
            fclose($file);
        } else {
            if (stristr($filename, SITE_ROOT) === false) {
                if ($extname == 'jpg' || $extname == 'jpeg' || $extname == 'gif' || $extname == 'png' || $extname == 'doc' || $extname == 'xls' || $extname == 'txt' || $extname == 'zip' || $extname == 'rar' || $extname == 'ppt' || $extname == 'pdf' || $extname == 'rm' || $extname == 'mid' || $extname == 'wav' || $extname == 'bmp' || $extname == 'swf' || $extname == 'chm' || $extname == 'sql' || $extname == 'cert' || $extname == 'pptx' || $extname == 'xlsx' || $extname == 'docx') {
                    $format = $extname;
                }
            } else {
                return '';
            }
        }
        if ($format == '' && strlen($str) >= 2) {
            if (substr($str, 0, 4) == 'MThd' && $extname != 'txt') {
                $format = 'mid';
            } elseif (substr($str, 0, 4) == 'RIFF' && $extname == 'wav') {
                $format = 'wav';
            } elseif (substr($str, 0, 3) == "") {
                $format = 'jpg';
            } elseif (substr($str, 0, 4) == 'GIF8' && $extname != 'txt') {
                $format = 'gif';
            } elseif (substr($str, 0, 8) == "PNG\r\n\n") {
                $format = 'png';
            } elseif (substr($str, 0, 2) == 'BM' && $extname != 'txt') {
                $format = 'bmp';
            } elseif ((substr($str, 0, 3) == 'CWS' || substr($str, 0, 3) == 'FWS') && $extname != 'txt') {
                $format = 'swf';
            } elseif (substr($str, 0, 4) == "") {
                if (substr($str, 0x200, 4) == " " || $extname == 'doc') {
                    $format = 'doc';
                } elseif (substr($str, 0x200, 2) == "\t" || $extname == 'xls') {
                    $format = 'xls';
                } elseif (substr($str, 0x200, 4) == "" || $extname == 'ppt') {
                    $format = 'ppt';
                }
            } elseif (substr($str, 0, 4) == "PK") {
                if (substr($str, 0x200, 4) == " " || $extname == 'docx') {
                    $format = 'docx';
                } elseif (substr($str, 0x200, 2) == "\t" || $extname == 'xlsx') {
                    $format = 'xlsx';
                } elseif (substr($str, 0x200, 4) == "" || $extname == 'pptx') {
                    $format = 'pptx';
                } else {
                    $format = 'zip';
                }
            } elseif (substr($str, 0, 4) == 'Rar!' && $extname != 'txt') {
                $format = 'rar';
            } elseif (substr($str, 0, 4) == "%PDF") {
                $format = 'pdf';
            } elseif (substr($str, 0, 3) == "0\n") {
                $format = 'cert';
            } elseif (substr($str, 0, 4) == 'ITSF' && $extname != 'txt') {
                $format = 'chm';
            } elseif (substr($str, 0, 4) == ".RMF") {
                $format = 'rm';
            } elseif ($extname == 'sql') {
                $format = 'sql';
            } elseif ($extname == 'txt') {
                $format = 'txt';
            }
        }
        if ($limit_ext_types && stristr($limit_ext_types, '|' . $format . '|') === false) {
            $format = '';
        }
        return $format;
    }
    public static function validate_file($file, $allowed_files = '')
    {
        if (false !== strpos($file, '..')) {
            return 1;
        }
        if (false !== strpos($file, './')) {
            return 1;
        }
        if (!empty($allowed_files) && !in_array($file, $allowed_files)) {
            return 3;
        }
        if (':' == substr($file, 1, 1)) {
            return 2;
        }
        return 0;
    }
    public static function move_file($source, $dest)
    {
        if (copy($source, $dest)) {
            unlink($source);
            return true;
        } else {
            return false;
        }
    }
    public static function is_absolute_path($path)
    {
        if (strpos($path, '/') === 0 || strpos($path, ":\\") === 1) {
            return true;
        } else {
            return false;
        }
    }
}
}

namespace Royalcms\Component\Filesystem {
use RuntimeException;
use InvalidArgumentException;
use Royalcms\Component\Support\Collection;
use League\Flysystem\AdapterInterface;
use League\Flysystem\FilesystemInterface;
use League\Flysystem\FileNotFoundException;
use League\Flysystem\Adapter\Local as LocalAdapter;
use Royalcms\Component\Contracts\Filesystem\Filesystem as FilesystemContract;
use Royalcms\Component\Contracts\Filesystem\Cloud as CloudFilesystemContract;
use Royalcms\Component\Contracts\Filesystem\FileNotFoundException as ContractFileNotFoundException;
use Royalcms\Component\Support\Str;
class FilesystemAdapter implements FilesystemContract, CloudFilesystemContract
{
    protected $driver;
    public function __construct(FilesystemInterface $driver)
    {
        $this->driver = $driver;
    }
    public function exists($path)
    {
        return $this->driver->has($path);
    }
    public function path($path)
    {
        return $this->driver->getAdapter()->getPathPrefix() . $path;
    }
    public function get($path)
    {
        try {
            return $this->driver->read($path);
        } catch (FileNotFoundException $e) {
            throw new ContractFileNotFoundException($path, $e->getCode(), $e);
        }
    }
    public function put($path, $contents, $visibility = null)
    {
        if ($visibility = $this->parseVisibility($visibility)) {
            $config = ['visibility' => $visibility];
        } else {
            $config = [];
        }
        if (is_resource($contents)) {
            return $this->driver->putStream($path, $contents, $config);
        } else {
            return $this->driver->put($path, $contents, $config);
        }
    }
    public function putFile($path, $file, $options = [])
    {
        return $this->putFileAs($path, $file, $file->hashName(), $options);
    }
    public function putFileAs($path, $file, $name, $options = [])
    {
        $stream = fopen($file->getRealPath(), 'r+');
        $result = $this->put($path = trim($path . '/' . $name, '/'), $stream, $options);
        if (is_resource($stream)) {
            fclose($stream);
        }
        return $result ? $path : false;
    }
    public function getVisibility($path)
    {
        if ($this->driver->getVisibility($path) == AdapterInterface::VISIBILITY_PUBLIC) {
            return FilesystemContract::VISIBILITY_PUBLIC;
        }
        return FilesystemContract::VISIBILITY_PRIVATE;
    }
    public function setVisibility($path, $visibility)
    {
        return $this->driver->setVisibility($path, $this->parseVisibility($visibility));
    }
    public function prepend($path, $data, $separator = PHP_EOL)
    {
        if ($this->exists($path)) {
            return $this->put($path, $data . $separator . $this->get($path));
        }
        return $this->put($path, $data);
    }
    public function append($path, $data, $separator = PHP_EOL)
    {
        if ($this->exists($path)) {
            return $this->put($path, $this->get($path) . $separator . $data);
        }
        return $this->put($path, $data);
    }
    public function delete($paths)
    {
        $paths = is_array($paths) ? $paths : func_get_args();
        $success = true;
        foreach ($paths as $path) {
            try {
                if (!$this->driver->delete($path)) {
                    $success = false;
                }
            } catch (FileNotFoundException $e) {
                $success = false;
            }
        }
        return $success;
    }
    public function copy($from, $to)
    {
        return $this->driver->copy($from, $to);
    }
    public function move($from, $to)
    {
        return $this->driver->rename($from, $to);
    }
    public function size($path)
    {
        return $this->driver->getSize($path);
    }
    public function mimeType($path)
    {
        return $this->driver->getMimetype($path);
    }
    public function lastModified($path)
    {
        return $this->driver->getTimestamp($path);
    }
    public function url($path)
    {
        $adapter = $this->driver->getAdapter();
        if (method_exists($adapter, 'getUrl')) {
            return $adapter->getUrl($path);
        } elseif ($adapter instanceof LocalAdapter) {
            return $this->getLocalUrl($path);
        } else {
            throw new RuntimeException('This driver does not support retrieving URLs.');
        }
    }
    protected function getLocalUrl($path)
    {
        $config = $this->driver->getConfig();
        if ($config->has('url')) {
            return rtrim($config->get('url'), '/') . '/' . ltrim($path, '/');
        }
        $path = SITE_UPLOAD_URL . '/' . $path;
        if (Str::contains($path, '/content/uploads/public/')) {
            return Str::replaceFirst('/public/', '/', $path);
        } else {
            return $path;
        }
    }
    public function temporaryUrl($path, $expiration, array $options = [])
    {
        $adapter = $this->driver->getAdapter();
        if (method_exists($adapter, 'getTemporaryUrl')) {
            return $adapter->getTemporaryUrl($path, $expiration, $options);
        } else {
            throw new RuntimeException('This driver does not support creating temporary URLs.');
        }
    }
    public function files($directory = null, $recursive = false)
    {
        $contents = $this->driver->listContents($directory, $recursive);
        return $this->filterContentsByType($contents, 'file');
    }
    public function allFiles($directory = null)
    {
        return $this->files($directory, true);
    }
    public function directories($directory = null, $recursive = false)
    {
        $contents = $this->driver->listContents($directory, $recursive);
        return $this->filterContentsByType($contents, 'dir');
    }
    public function allDirectories($directory = null)
    {
        return $this->directories($directory, true);
    }
    public function makeDirectory($path)
    {
        return $this->driver->createDir($path);
    }
    public function deleteDirectory($directory)
    {
        return $this->driver->deleteDir($directory);
    }
    public function getDriver()
    {
        return $this->driver;
    }
    protected function filterContentsByType($contents, $type)
    {
        return Collection::make($contents)->where('type', $type)->pluck('path')->values()->all();
    }
    protected function parseVisibility($visibility)
    {
        if (is_null($visibility)) {
            return null;
        }
        switch ($visibility) {
            case FilesystemContract::VISIBILITY_PUBLIC:
                return AdapterInterface::VISIBILITY_PUBLIC;
            case FilesystemContract::VISIBILITY_PRIVATE:
                return AdapterInterface::VISIBILITY_PRIVATE;
        }
        throw new InvalidArgumentException('Unknown visibility: ' . $visibility);
    }
    public function __call($method, array $parameters)
    {
        return call_user_func_array([$this->driver, $method], $parameters);
    }
}
}

namespace Royalcms\Component\Filesystem {
use ErrorException;
use FilesystemIterator;
use Symfony\Component\Finder\Finder;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Filesystem\FileNotFoundException;
class Filesystem
{
    use Macroable;
    public function exists($path)
    {
        return file_exists($path);
    }
    public function get($path)
    {
        if ($this->isFile($path)) {
            return file_get_contents($path);
        }
        throw new FileNotFoundException("File does not exist at path {$path}");
    }
    public function getRequire($path)
    {
        if ($this->isFile($path)) {
            return require $path;
        }
        throw new FileNotFoundException("File does not exist at path {$path}");
    }
    public function requireOnce($file)
    {
        require_once $file;
    }
    public function put($path, $contents, $lock = false)
    {
        return file_put_contents($path, $contents, $lock ? LOCK_EX : 0);
    }
    public function prepend($path, $data)
    {
        if ($this->exists($path)) {
            return $this->put($path, $data . $this->get($path));
        }
        return $this->put($path, $data);
    }
    public function append($path, $data)
    {
        return file_put_contents($path, $data, FILE_APPEND);
    }
    public function delete($paths)
    {
        $paths = is_array($paths) ? $paths : func_get_args();
        $success = true;
        foreach ($paths as $path) {
            try {
                if (!@unlink($path)) {
                    $success = false;
                }
            } catch (ErrorException $e) {
                $success = false;
            }
        }
        return $success;
    }
    public function move($path, $target)
    {
        return rename($path, $target);
    }
    public function copy($path, $target)
    {
        return copy($path, $target);
    }
    public function name($path)
    {
        return pathinfo($path, PATHINFO_FILENAME);
    }
    public function extension($path)
    {
        return pathinfo($path, PATHINFO_EXTENSION);
    }
    public function type($path)
    {
        return filetype($path);
    }
    public function mimeType($path)
    {
        return finfo_file(finfo_open(FILEINFO_MIME_TYPE), $path);
    }
    public function size($path)
    {
        return filesize($path);
    }
    public function lastModified($path)
    {
        return filemtime($path);
    }
    public function isDirectory($directory)
    {
        return is_dir($directory);
    }
    public function isWritable($path)
    {
        return is_writable($path);
    }
    public function isFile($file)
    {
        return is_file($file);
    }
    public function glob($pattern, $flags = 0)
    {
        return glob($pattern, $flags);
    }
    public function files($directory)
    {
        $glob = glob($directory . '/*');
        if ($glob === false) {
            return [];
        }
        return array_filter($glob, function ($file) {
            return filetype($file) == 'file';
        });
    }
    public function allFiles($directory)
    {
        return iterator_to_array(Finder::create()->files()->in($directory), false);
    }
    public function directories($directory, $depth = 0)
    {
        $directories = [];
        foreach (Finder::create()->in($directory)->directories()->depth($depth) as $dir) {
            $directories[] = $dir->getPathname();
        }
        return $directories;
    }
    public function makeDirectory($path, $mode = 0755, $recursive = false, $force = false)
    {
        if ($force) {
            return @mkdir($path, $mode, $recursive);
        }
        return mkdir($path, $mode, $recursive);
    }
    public function copyDirectory($directory, $destination, $options = null)
    {
        if (!$this->isDirectory($directory)) {
            return false;
        }
        $options = $options ?: FilesystemIterator::SKIP_DOTS;
        if (!$this->isDirectory($destination)) {
            $this->makeDirectory($destination, 0777, true);
        }
        $items = new FilesystemIterator($directory, $options);
        foreach ($items as $item) {
            $target = $destination . '/' . $item->getBasename();
            if ($item->isDir()) {
                $path = $item->getPathname();
                if (!$this->copyDirectory($path, $target, $options)) {
                    return false;
                }
            } else {
                if (!$this->copy($item->getPathname(), $target)) {
                    return false;
                }
            }
        }
        return true;
    }
    public function deleteDirectory($directory, $preserve = false)
    {
        if (!$this->isDirectory($directory)) {
            return false;
        }
        $items = new FilesystemIterator($directory);
        foreach ($items as $item) {
            if ($item->isDir() && !$item->isLink()) {
                $this->deleteDirectory($item->getPathname());
            } else {
                $this->delete($item->getPathname());
            }
        }
        if (!$preserve) {
            @rmdir($directory);
        }
        return true;
    }
    public function cleanDirectory($directory)
    {
        return $this->deleteDirectory($directory, true);
    }
}
}

namespace Royalcms\Component\Filesystem {
use Closure;
use Royalcms\Component\Support\Arr;
use InvalidArgumentException;
use League\Flysystem\AdapterInterface;
use League\Flysystem\FilesystemInterface;
use League\Flysystem\Filesystem as Flysystem;
use League\Flysystem\Adapter\Ftp as FtpAdapter;
use League\Flysystem\Adapter\Local as LocalAdapter;
use Royalcms\Component\Contracts\Filesystem\Factory as FactoryContract;
class FilesystemManager implements FactoryContract
{
    protected $royalcms;
    protected $disks = [];
    protected $customCreators = [];
    public function __construct($royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public function drive($name = null)
    {
        return $this->disk($name);
    }
    public function disk($name = null)
    {
        $name = $name ?: $this->getDefaultDriver();
        return $this->disks[$name] = $this->get($name);
    }
    protected function get($name)
    {
        return isset($this->disks[$name]) ? $this->disks[$name] : $this->resolve($name);
    }
    protected function resolve($name)
    {
        $config = $this->getConfig($name);
        if (isset($this->customCreators[$config['driver']])) {
            return $this->callCustomCreator($config);
        }
        $driverMethod = 'create' . ucfirst($config['driver']) . 'Driver';
        if (method_exists($this, $driverMethod)) {
            return $this->{$driverMethod}($config);
        } else {
            throw new InvalidArgumentException("Driver [{$config['driver']}] not supported.");
        }
    }
    protected function callCustomCreator(array $config)
    {
        $driver = $this->customCreators[$config['driver']]($this->royalcms, $config);
        if ($driver instanceof FilesystemInterface) {
            return $this->adapt($driver);
        }
        return $driver;
    }
    public function createLocalDriver(array $config)
    {
        $permissions = isset($config['permissions']) ? $config['permissions'] : [];
        $links = Arr::get($config, 'links') === 'skip' ? LocalAdapter::SKIP_LINKS : LocalAdapter::DISALLOW_LINKS;
        return $this->adapt($this->createFlysystem(new LocalAdapter($config['root'], LOCK_EX, $links, $permissions), $config));
    }
    public function createFtpDriver(array $config)
    {
        $ftpConfig = Arr::only($config, ['host', 'username', 'password', 'port', 'root', 'passive', 'ssl', 'timeout']);
        return $this->adapt($this->createFlysystem(new FtpAdapter($ftpConfig), $config));
    }
    protected function createFlysystem(AdapterInterface $adapter, array $config)
    {
        $config = Arr::only($config, ['visibility', 'disable_asserts']);
        return new Flysystem($adapter, count($config) > 0 ? $config : null);
    }
    protected function adapt(FilesystemInterface $filesystem)
    {
        return new FilesystemAdapter($filesystem);
    }
    protected function getConfig($name)
    {
        return $this->royalcms['config']["filesystems.disks.{$name}"];
    }
    public function getDefaultDriver()
    {
        return $this->royalcms['config']['filesystems.default'];
    }
    public function extend($driver, Closure $callback)
    {
        $this->customCreators[$driver] = $callback;
        return $this;
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->disk(), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Filesystem {
use Royalcms\Component\Support\ServiceProvider;
class FilesystemServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerNativeFilesystem();
        $this->registerFlysystem();
    }
    protected function registerNativeFilesystem()
    {
        $this->royalcms->singleton('files', function () {
            return new Filesystem();
        });
    }
    protected function registerFlysystem()
    {
        $this->registerManager();
        $this->royalcms->singleton('filesystem.disk', function () {
            return $this->royalcms['filesystem']->disk($this->getDefaultDriver());
        });
        $this->royalcms->singleton('filesystem.cloud', function () {
            return $this->royalcms['filesystem']->disk($this->getCloudDriver());
        });
    }
    protected function registerManager()
    {
        $this->royalcms->singleton('filesystem', function () {
            return new FilesystemManager($this->royalcms);
        });
    }
    protected function getDefaultDriver()
    {
        return $this->royalcms['config']['filesystems.default'];
    }
    protected function getCloudDriver()
    {
        return $this->royalcms['config']['filesystems.cloud'];
    }
}
}

namespace Royalcms\Component\Routing {
use Royalcms\Component\Support\ServiceProvider;
use Zend\Diactoros\Response as PsrResponse;
use Symfony\Bridge\PsrHttpMessage\Factory\DiactorosFactory;
class RoutingServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerRouter();
        $this->registerUrlGenerator();
        $this->registerRedirector();
        $this->registerPsrRequest();
        $this->registerPsrResponse();
        $this->registerResponseFactory();
        $this->registerResponse();
    }
    protected function registerRouter()
    {
        $this->royalcms['router'] = $this->royalcms->share(function ($royalcms) {
            return new Router($royalcms['events'], $royalcms);
        });
    }
    protected function registerUrlGenerator()
    {
        $this->royalcms['url'] = $this->royalcms->share(function ($royalcms) {
            $routes = $royalcms['router']->getRoutes();
            $royalcms->instance('routes', $routes);
            $url = new UrlGenerator($routes, $royalcms->rebinding('request', $this->requestRebinder()));
            $url->setSessionResolver(function () {
                return $this->royalcms['session'];
            });
            $royalcms->rebinding('routes', function ($royalcms, $routes) {
                $royalcms['url']->setRoutes($routes);
            });
            return $url;
        });
    }
    protected function requestRebinder()
    {
        return function ($royalcms, $request) {
            $royalcms['url']->setRequest($request);
        };
    }
    protected function registerRedirector()
    {
        $this->royalcms['redirect'] = $this->royalcms->share(function ($royalcms) {
            $redirector = new Redirector($royalcms['url']);
            return $redirector;
        });
    }
    protected function registerPsrRequest()
    {
        $this->royalcms->bind('Psr\\Http\\Message\\ServerRequestInterface', function ($royalcms) {
            return (new DiactorosFactory())->createRequest($royalcms->make('request'));
        });
    }
    protected function registerPsrResponse()
    {
        $this->royalcms->bind('Psr\\Http\\Message\\ResponseInterface', function ($royalcms) {
            return new PsrResponse();
        });
    }
    protected function registerResponseFactory()
    {
        $this->royalcms->singleton('Royalcms\\Component\\Contracts\\Routing\\ResponseFactory', function ($royalcms) {
            return new ResponseFactory($royalcms['Royalcms\\Component\\Contracts\\View\\Factory'], $royalcms['redirect']);
        });
    }
    protected function registerResponse()
    {
        $this->royalcms['response'] = $this->royalcms->share(function ($royalcms) {
            return new \Royalcms\Component\Http\Response();
        });
    }
}
}

namespace Royalcms\Component\Routing {
use Royalcms\Component\Support\ServiceProvider;
class ControllerServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->singleton('royalcms.route.dispatcher', function ($royalcms) {
            return new ControllerDispatcher($royalcms['router'], $royalcms);
        });
    }
}
}

namespace Royalcms\Component\Routing {
use ReflectionClass;
use ReflectionMethod;
use ReflectionParameter;
use Royalcms\Component\Support\Arr;
use ReflectionFunctionAbstract;
use Royalcms\Component\Database\Eloquent\Model;
trait RouteDependencyResolverTrait
{
    protected function callWithDependencies($instance, $method)
    {
        return call_user_func_array([$instance, $method], $this->resolveClassMethodDependencies([], $instance, $method));
    }
    protected function resolveClassMethodDependencies(array $parameters, $instance, $method)
    {
        if (!method_exists($instance, $method)) {
            return $parameters;
        }
        return $this->resolveMethodDependencies($parameters, new ReflectionMethod($instance, $method));
    }
    public function resolveMethodDependencies(array $parameters, ReflectionFunctionAbstract $reflector)
    {
        $originalParameters = $parameters;
        foreach ($reflector->getParameters() as $key => $parameter) {
            $instance = $this->transformDependency($parameter, $parameters, $originalParameters);
            if (!is_null($instance)) {
                $this->spliceIntoParameters($parameters, $key, $instance);
            }
        }
        return $parameters;
    }
    protected function transformDependency(ReflectionParameter $parameter, $parameters, $originalParameters)
    {
        $class = $parameter->getClass();
        if ($class && !$this->alreadyInParameters($class->name, $parameters)) {
            return $this->container->make($class->name);
        }
    }
    protected function vacantEloquentParameter(ReflectionClass $class, array $parameters)
    {
        return $class->isSubclassOf(Model::class) && !$this->alreadyInParameters($class->name, $parameters);
    }
    protected function extractModelIdentifier(ReflectionParameter $parameter, array $originalParameters)
    {
        return Arr::first($originalParameters, function ($parameterValue, $parameterKey) use($parameter) {
            return $parameterKey === $parameter->name;
        });
    }
    protected function alreadyInParameters($class, array $parameters)
    {
        return !is_null(Arr::first($parameters, function ($value, $key) use($class) {
            return $value instanceof $class;
        }));
    }
    protected function spliceIntoParameters(array &$parameters, $key, $instance)
    {
        array_splice($parameters, $key, 0, [$instance]);
    }
}
}

namespace Royalcms\Component\Routing {
use Closure;
use LogicException;
use ReflectionFunction;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Http\Request;
use UnexpectedValueException;
use Royalcms\Component\Container\Container;
use Royalcms\Component\Routing\Matching\UriValidator;
use Royalcms\Component\Routing\Matching\HostValidator;
use Royalcms\Component\Routing\Matching\MethodValidator;
use Royalcms\Component\Routing\Matching\SchemeValidator;
use Symfony\Component\Routing\Route as SymfonyRoute;
use Royalcms\Component\Http\Exception\HttpResponseException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
class Route
{
    use RouteDependencyResolverTrait;
    protected $uri;
    protected $methods;
    protected $action;
    protected $defaults = [];
    protected $wheres = [];
    protected $parameters;
    protected $parameterNames;
    protected $compiled;
    protected $container;
    public static $validators;
    public function __construct($methods, $uri, $action)
    {
        $this->uri = $uri;
        $this->methods = (array) $methods;
        $this->action = $this->parseAction($action);
        if (in_array('GET', $this->methods) && !in_array('HEAD', $this->methods)) {
            $this->methods[] = 'HEAD';
        }
        if (isset($this->action['prefix'])) {
            $this->prefix($this->action['prefix']);
        }
    }
    public function run(Request $request)
    {
        $this->container = $this->container ?: new Container();
        try {
            if (!is_string($this->action['uses'])) {
                return $this->runCallable($request);
            }
            if ($this->customDispatcherIsBound()) {
                return $this->runWithCustomDispatcher($request);
            }
            return $this->runController($request);
        } catch (HttpResponseException $e) {
            return $e->getResponse();
        }
    }
    protected function runCallable(Request $request)
    {
        $parameters = $this->resolveMethodDependencies($this->parametersWithoutNulls(), new ReflectionFunction($this->action['uses']));
        return call_user_func_array($this->action['uses'], $parameters);
    }
    protected function runController(Request $request)
    {
        list($class, $method) = explode('@', $this->action['uses']);
        $parameters = $this->resolveClassMethodDependencies($this->parametersWithoutNulls(), $class, $method);
        if (!method_exists($instance = $this->container->make($class), $method)) {
            throw new NotFoundHttpException();
        }
        return call_user_func_array([$instance, $method], $parameters);
    }
    protected function customDispatcherIsBound()
    {
        return $this->container->bound('royalcms.route.dispatcher');
    }
    protected function runWithCustomDispatcher(Request $request)
    {
        list($class, $method) = explode('@', $this->action['uses']);
        $dispatcher = $this->container->make('royalcms.route.dispatcher');
        return $dispatcher->dispatch($this, $request, $class, $method);
    }
    public function matches(Request $request, $includingMethod = true)
    {
        $this->compileRoute();
        foreach ($this->getValidators() as $validator) {
            if (!$includingMethod && $validator instanceof MethodValidator) {
                continue;
            }
            if (!$validator->matches($this, $request)) {
                return false;
            }
        }
        return true;
    }
    protected function compileRoute()
    {
        $optionals = $this->extractOptionalParameters();
        $uri = preg_replace('/\\{(\\w+?)\\?\\}/', '{$1}', $this->uri);
        $this->compiled = with(new SymfonyRoute($uri, $optionals, $this->wheres, [], $this->domain() ?: ''))->compile();
    }
    protected function extractOptionalParameters()
    {
        preg_match_all('/\\{(\\w+?)\\?\\}/', $this->uri, $matches);
        return isset($matches[1]) ? array_fill_keys($matches[1], null) : [];
    }
    public function middleware($middleware = null)
    {
        if (is_null($middleware)) {
            return (array) Arr::get($this->action, 'middleware', []);
        }
        if (is_string($middleware)) {
            $middleware = [$middleware];
        }
        $this->action['middleware'] = array_merge((array) Arr::get($this->action, 'middleware', []), $middleware);
        return $this;
    }
    public function beforeFilters()
    {
        if (!isset($this->action['before'])) {
            return [];
        }
        return $this->parseFilters($this->action['before']);
    }
    public function afterFilters()
    {
        if (!isset($this->action['after'])) {
            return [];
        }
        return $this->parseFilters($this->action['after']);
    }
    public static function parseFilters($filters)
    {
        return Arr::build(static::explodeFilters($filters), function ($key, $value) {
            return Route::parseFilter($value);
        });
    }
    protected static function explodeFilters($filters)
    {
        if (is_array($filters)) {
            return static::explodeArrayFilters($filters);
        }
        return array_map('trim', explode('|', $filters));
    }
    protected static function explodeArrayFilters(array $filters)
    {
        $results = [];
        foreach ($filters as $filter) {
            $results = array_merge($results, array_map('trim', explode('|', $filter)));
        }
        return $results;
    }
    public static function parseFilter($filter)
    {
        if (!Str::contains($filter, ':')) {
            return [$filter, []];
        }
        return static::parseParameterFilter($filter);
    }
    protected static function parseParameterFilter($filter)
    {
        list($name, $parameters) = explode(':', $filter, 2);
        return [$name, explode(',', $parameters)];
    }
    public function hasParameter($name)
    {
        return array_key_exists($name, $this->parameters());
    }
    public function getParameter($name, $default = null)
    {
        return $this->parameter($name, $default);
    }
    public function parameter($name, $default = null)
    {
        return Arr::get($this->parameters(), $name, $default);
    }
    public function setParameter($name, $value)
    {
        $this->parameters();
        $this->parameters[$name] = $value;
    }
    public function forgetParameter($name)
    {
        $this->parameters();
        unset($this->parameters[$name]);
    }
    public function parameters()
    {
        if (isset($this->parameters)) {
            return array_map(function ($value) {
                return is_string($value) ? rawurldecode($value) : $value;
            }, $this->parameters);
        }
        throw new LogicException('Route is not bound.');
    }
    public function parametersWithoutNulls()
    {
        return array_filter($this->parameters(), function ($p) {
            return !is_null($p);
        });
    }
    public function parameterNames()
    {
        if (isset($this->parameterNames)) {
            return $this->parameterNames;
        }
        return $this->parameterNames = $this->compileParameterNames();
    }
    protected function compileParameterNames()
    {
        preg_match_all('/\\{(.*?)\\}/', $this->domain() . $this->uri, $matches);
        return array_map(function ($m) {
            return trim($m, '?');
        }, $matches[1]);
    }
    public function bind(Request $request)
    {
        $this->compileRoute();
        $this->bindParameters($request);
        return $this;
    }
    public function bindParameters(Request $request)
    {
        $params = $this->matchToKeys(array_slice($this->bindPathParameters($request), 1));
        if (!is_null($this->compiled->getHostRegex())) {
            $params = $this->bindHostParameters($request, $params);
        }
        return $this->parameters = $this->replaceDefaults($params);
    }
    protected function bindPathParameters(Request $request)
    {
        preg_match($this->compiled->getRegex(), '/' . $request->decodedPath(), $matches);
        return $matches;
    }
    protected function bindHostParameters(Request $request, $parameters)
    {
        preg_match($this->compiled->getHostRegex(), $request->getHost(), $matches);
        return array_merge($this->matchToKeys(array_slice($matches, 1)), $parameters);
    }
    protected function matchToKeys(array $matches)
    {
        if (count($this->parameterNames()) == 0) {
            return [];
        }
        $parameters = array_intersect_key($matches, array_flip($this->parameterNames()));
        return array_filter($parameters, function ($value) {
            return is_string($value) && strlen($value) > 0;
        });
    }
    protected function replaceDefaults(array $parameters)
    {
        foreach ($parameters as $key => &$value) {
            $value = isset($value) ? $value : Arr::get($this->defaults, $key);
        }
        foreach ($this->defaults as $key => $value) {
            if (!isset($parameters[$key])) {
                $parameters[$key] = $value;
            }
        }
        return $parameters;
    }
    protected function parseAction($action)
    {
        if (is_callable($action)) {
            return ['uses' => $action];
        } elseif (!isset($action['uses'])) {
            $action['uses'] = $this->findCallable($action);
        }
        if (is_string($action['uses']) && !Str::contains($action['uses'], '@')) {
            throw new UnexpectedValueException(sprintf('Invalid route action: [%s]', $action['uses']));
        }
        return $action;
    }
    protected function findCallable(array $action)
    {
        return Arr::first($action, function ($value, $key) {
            return is_callable($value) && is_numeric($key);
        });
    }
    public static function getValidators()
    {
        if (isset(static::$validators)) {
            return static::$validators;
        }
        return static::$validators = [new MethodValidator(), new SchemeValidator(), new HostValidator(), new UriValidator()];
    }
    public function before($filters)
    {
        return $this->addFilters('before', $filters);
    }
    public function after($filters)
    {
        return $this->addFilters('after', $filters);
    }
    protected function addFilters($type, $filters)
    {
        $filters = static::explodeFilters($filters);
        if (isset($this->action[$type])) {
            $existing = static::explodeFilters($this->action[$type]);
            $this->action[$type] = array_merge($existing, $filters);
        } else {
            $this->action[$type] = $filters;
        }
        return $this;
    }
    public function defaults($key, $value)
    {
        $this->defaults[$key] = $value;
        return $this;
    }
    public function where($name, $expression = null)
    {
        foreach ($this->parseWhere($name, $expression) as $name => $expression) {
            $this->wheres[$name] = $expression;
        }
        return $this;
    }
    protected function parseWhere($name, $expression)
    {
        return is_array($name) ? $name : [$name => $expression];
    }
    protected function whereArray(array $wheres)
    {
        foreach ($wheres as $name => $expression) {
            $this->where($name, $expression);
        }
        return $this;
    }
    public function prefix($prefix)
    {
        $uri = rtrim($prefix, '/') . '/' . ltrim($this->uri, '/');
        $this->uri = trim($uri, '/');
        return $this;
    }
    public function getPath()
    {
        return $this->uri();
    }
    public function uri()
    {
        return $this->uri;
    }
    public function getMethods()
    {
        return $this->methods();
    }
    public function methods()
    {
        return $this->methods;
    }
    public function httpOnly()
    {
        return in_array('http', $this->action, true);
    }
    public function httpsOnly()
    {
        return $this->secure();
    }
    public function secure()
    {
        return in_array('https', $this->action, true);
    }
    public function domain()
    {
        return isset($this->action['domain']) ? $this->action['domain'] : null;
    }
    public function getUri()
    {
        return $this->uri;
    }
    public function setUri($uri)
    {
        $this->uri = $uri;
        return $this;
    }
    public function getPrefix()
    {
        return isset($this->action['prefix']) ? $this->action['prefix'] : null;
    }
    public function getName()
    {
        return isset($this->action['as']) ? $this->action['as'] : null;
    }
    public function name($name)
    {
        $this->action['as'] = isset($this->action['as']) ? $this->action['as'] . $name : $name;
        return $this;
    }
    public function getActionName()
    {
        return isset($this->action['controller']) ? $this->action['controller'] : 'Closure';
    }
    public function getAction()
    {
        return $this->action;
    }
    public function setAction(array $action)
    {
        $this->action = $action;
        return $this;
    }
    public function getCompiled()
    {
        return $this->compiled;
    }
    public function setContainer(Container $container)
    {
        $this->container = $container;
        return $this;
    }
    public function prepareForSerialization()
    {
        if ($this->action['uses'] instanceof Closure) {
            throw new LogicException("Unable to prepare route [{$this->uri}] for serialization. Uses Closure.");
        }
        unset($this->container, $this->compiled);
    }
    public function __get($key)
    {
        return $this->parameter($key);
    }
}
}

namespace Royalcms\Component\Routing {
use Closure;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Http\Request;
use Royalcms\Component\Http\Response;
use Royalcms\Component\Pipeline\Pipeline;
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Container\Container;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Psr\Http\Message\ResponseInterface as PsrResponseInterface;
use Symfony\Bridge\PsrHttpMessage\Factory\HttpFoundationFactory;
use Royalcms\Component\Contracts\Routing\Registrar as RegistrarContract;
use Symfony\Component\HttpFoundation\Response as SymfonyResponse;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
class Router implements RegistrarContract
{
    use Macroable;
    protected $events;
    protected $container;
    protected $routes;
    protected $current;
    protected $currentRequest;
    protected $middleware = [];
    protected $patternFilters = [];
    protected $regexFilters = [];
    protected $binders = [];
    protected $patterns = [];
    protected $groupStack = [];
    public static $verbs = ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'];
    public function __construct(Dispatcher $events, Container $container = null)
    {
        $this->events = $events;
        $this->routes = new RouteCollection();
        $this->container = $container ?: new Container();
        $this->bind('_missing', function ($v) {
            return explode('/', $v);
        });
    }
    public function get($uri, $action)
    {
        return $this->addRoute(['GET', 'HEAD'], $uri, $action);
    }
    public function post($uri, $action)
    {
        return $this->addRoute('POST', $uri, $action);
    }
    public function put($uri, $action)
    {
        return $this->addRoute('PUT', $uri, $action);
    }
    public function patch($uri, $action)
    {
        return $this->addRoute('PATCH', $uri, $action);
    }
    public function delete($uri, $action)
    {
        return $this->addRoute('DELETE', $uri, $action);
    }
    public function options($uri, $action)
    {
        return $this->addRoute('OPTIONS', $uri, $action);
    }
    public function any($uri, $action)
    {
        $verbs = ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE'];
        return $this->addRoute($verbs, $uri, $action);
    }
    public function match($methods, $uri, $action)
    {
        return $this->addRoute(array_map('strtoupper', (array) $methods), $uri, $action);
    }
    public function controllers(array $controllers)
    {
        foreach ($controllers as $uri => $controller) {
            $this->controller($uri, $controller);
        }
    }
    public function controller($uri, $controller, $names = [])
    {
        $prepended = $controller;
        if (!empty($this->groupStack)) {
            $prepended = $this->prependGroupUses($controller);
        }
        $routable = (new ControllerInspector())->getRoutable($prepended, $uri);
        foreach ($routable as $method => $routes) {
            foreach ($routes as $route) {
                $this->registerInspected($route, $controller, $method, $names);
            }
        }
        $this->addFallthroughRoute($controller, $uri);
    }
    protected function registerInspected($route, $controller, $method, &$names)
    {
        $action = ['uses' => $controller . '@' . $method];
        $action['as'] = Arr::get($names, $method);
        $this->{$route['verb']}($route['uri'], $action);
    }
    protected function addFallthroughRoute($controller, $uri)
    {
        $missing = $this->any($uri . '/{_missing}', $controller . '@missingMethod');
        $missing->where('_missing', '(.*)');
    }
    public function resources(array $resources)
    {
        foreach ($resources as $name => $controller) {
            $this->resource($name, $controller);
        }
    }
    public function resource($name, $controller, array $options = [])
    {
        if ($this->container && $this->container->bound('Royalcms\\Component\\Routing\\ResourceRegistrar')) {
            $registrar = $this->container->make('Royalcms\\Component\\Routing\\ResourceRegistrar');
        } else {
            $registrar = new ResourceRegistrar($this);
        }
        $registrar->register($name, $controller, $options);
    }
    public function group(array $attributes, Closure $callback)
    {
        $this->updateGroupStack($attributes);
        call_user_func($callback, $this);
        array_pop($this->groupStack);
    }
    protected function updateGroupStack(array $attributes)
    {
        if (!empty($this->groupStack)) {
            $attributes = $this->mergeGroup($attributes, end($this->groupStack));
        }
        $this->groupStack[] = $attributes;
    }
    public function mergeWithLastGroup($new)
    {
        return $this->mergeGroup($new, end($this->groupStack));
    }
    public static function mergeGroup($new, $old)
    {
        $new['namespace'] = static::formatUsesPrefix($new, $old);
        $new['prefix'] = static::formatGroupPrefix($new, $old);
        if (isset($new['domain'])) {
            unset($old['domain']);
        }
        $new['where'] = array_merge(isset($old['where']) ? $old['where'] : [], isset($new['where']) ? $new['where'] : []);
        if (isset($old['as'])) {
            $new['as'] = $old['as'] . (isset($new['as']) ? $new['as'] : '');
        }
        return array_merge_recursive(Arr::except($old, ['namespace', 'prefix', 'where', 'as']), $new);
    }
    protected static function formatUsesPrefix($new, $old)
    {
        if (isset($new['namespace'])) {
            return isset($old['namespace']) ? trim($old['namespace'], '\\') . '\\' . trim($new['namespace'], '\\') : trim($new['namespace'], '\\');
        }
        return isset($old['namespace']) ? $old['namespace'] : null;
    }
    protected static function formatGroupPrefix($new, $old)
    {
        $oldPrefix = isset($old['prefix']) ? $old['prefix'] : null;
        if (isset($new['prefix'])) {
            return trim($oldPrefix, '/') . '/' . trim($new['prefix'], '/');
        }
        return $oldPrefix;
    }
    public function getLastGroupPrefix()
    {
        if (!empty($this->groupStack)) {
            $last = end($this->groupStack);
            return isset($last['prefix']) ? $last['prefix'] : '';
        }
        return '';
    }
    protected function addRoute($methods, $uri, $action)
    {
        return $this->routes->add($this->createRoute($methods, $uri, $action));
    }
    protected function createRoute($methods, $uri, $action)
    {
        if ($this->actionReferencesController($action)) {
            $action = $this->convertToControllerAction($action);
        }
        $route = $this->newRoute($methods, $this->prefix($uri), $action);
        if ($this->hasGroupStack()) {
            $this->mergeGroupAttributesIntoRoute($route);
        }
        $this->addWhereClausesToRoute($route);
        return $route;
    }
    protected function newRoute($methods, $uri, $action)
    {
        return (new Route($methods, $uri, $action))->setContainer($this->container);
    }
    protected function prefix($uri)
    {
        return trim(trim($this->getLastGroupPrefix(), '/') . '/' . trim($uri, '/'), '/') ?: '/';
    }
    protected function addWhereClausesToRoute($route)
    {
        $where = isset($route->getAction()['where']) ? $route->getAction()['where'] : [];
        $route->where(array_merge($this->patterns, $where));
        return $route;
    }
    protected function mergeGroupAttributesIntoRoute($route)
    {
        $action = $this->mergeWithLastGroup($route->getAction());
        $route->setAction($action);
    }
    protected function actionReferencesController($action)
    {
        if ($action instanceof Closure) {
            return false;
        }
        return is_string($action) || is_string(isset($action['uses']) ? $action['uses'] : null);
    }
    protected function convertToControllerAction($action)
    {
        if (is_string($action)) {
            $action = ['uses' => $action];
        }
        if (!empty($this->groupStack)) {
            $action['uses'] = $this->prependGroupUses($action['uses']);
        }
        $action['controller'] = $action['uses'];
        return $action;
    }
    protected function prependGroupUses($uses)
    {
        $group = end($this->groupStack);
        return isset($group['namespace']) && strpos($uses, '\\') !== 0 ? $group['namespace'] . '\\' . $uses : $uses;
    }
    public function dispatch(Request $request)
    {
        $this->currentRequest = $request;
        $response = $this->callFilter('before', $request);
        if (is_null($response)) {
            $response = $this->dispatchToRoute($request);
        }
        $response = $this->prepareResponse($request, $response);
        $this->callFilter('after', $request, $response);
        return $response;
    }
    public function dispatchToRoute(Request $request)
    {
        $route = $this->findRoute($request);
        $request->setRouteResolver(function () use($route) {
            return $route;
        });
        $this->events->fire('router.matched', [$route, $request]);
        $response = $this->callRouteBefore($route, $request);
        if (is_null($response)) {
            $response = $this->runRouteWithinStack($route, $request);
        }
        $response = $this->prepareResponse($request, $response);
        $this->callRouteAfter($route, $request, $response);
        return $response;
    }
    protected function runRouteWithinStack(Route $route, Request $request)
    {
        $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true;
        $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddlewares($route);
        return (new Pipeline($this->container))->send($request)->through($middleware)->then(function ($request) use($route) {
            return $this->prepareResponse($request, $route->run($request));
        });
    }
    public function gatherRouteMiddlewares(Route $route)
    {
        return Collection::make($route->middleware())->map(function ($name) {
            return Collection::make($this->resolveMiddlewareClassName($name));
        })->collapse()->all();
    }
    public function resolveMiddlewareClassName($name)
    {
        $map = $this->middleware;
        list($name, $parameters) = array_pad(explode(':', $name, 2), 2, null);
        return (isset($map[$name]) ? $map[$name] : $name) . ($parameters !== null ? ':' . $parameters : '');
    }
    protected function findRoute($request)
    {
        $this->current = $route = $this->routes->match($request);
        $this->container->instance('Royalcms\\Component\\Routing\\Route', $route);
        return $this->substituteBindings($route);
    }
    protected function substituteBindings($route)
    {
        foreach ($route->parameters() as $key => $value) {
            if (isset($this->binders[$key])) {
                $route->setParameter($key, $this->performBinding($key, $value, $route));
            }
        }
        return $route;
    }
    protected function performBinding($key, $value, $route)
    {
        return call_user_func($this->binders[$key], $value, $route);
    }
    public function matched($callback)
    {
        $this->events->listen('router.matched', $callback);
    }
    public function before($callback)
    {
        $this->addGlobalFilter('before', $callback);
    }
    public function after($callback)
    {
        $this->addGlobalFilter('after', $callback);
    }
    protected function addGlobalFilter($filter, $callback)
    {
        $this->events->listen('router.' . $filter, $this->parseFilter($callback));
    }
    public function getMiddleware()
    {
        return $this->middleware;
    }
    public function middleware($name, $class)
    {
        $this->middleware[$name] = $class;
        return $this;
    }
    public function filter($name, $callback)
    {
        $this->events->listen('router.filter: ' . $name, $this->parseFilter($callback));
    }
    protected function parseFilter($callback)
    {
        if (is_string($callback) && !Str::contains($callback, '@')) {
            return $callback . '@filter';
        }
        return $callback;
    }
    public function when($pattern, $name, $methods = null)
    {
        if (!is_null($methods)) {
            $methods = array_map('strtoupper', (array) $methods);
        }
        $this->patternFilters[$pattern][] = compact('name', 'methods');
    }
    public function whenRegex($pattern, $name, $methods = null)
    {
        if (!is_null($methods)) {
            $methods = array_map('strtoupper', (array) $methods);
        }
        $this->regexFilters[$pattern][] = compact('name', 'methods');
    }
    public function model($key, $class, Closure $callback = null)
    {
        $this->bind($key, function ($value) use($class, $callback) {
            if (is_null($value)) {
                return;
            }
            $instance = $this->container->make($class);
            if ($model = $instance->where($instance->getRouteKeyName(), $value)->first()) {
                return $model;
            }
            if ($callback instanceof Closure) {
                return call_user_func($callback, $value);
            }
            throw new NotFoundHttpException();
        });
    }
    public function bind($key, $binder)
    {
        if (is_string($binder)) {
            $binder = $this->createClassBinding($binder);
        }
        $this->binders[str_replace('-', '_', $key)] = $binder;
    }
    public function createClassBinding($binding)
    {
        return function ($value, $route) use($binding) {
            $segments = explode('@', $binding);
            $method = count($segments) == 2 ? $segments[1] : 'bind';
            $callable = [$this->container->make($segments[0]), $method];
            return call_user_func($callable, $value, $route);
        };
    }
    public function pattern($key, $pattern)
    {
        $this->patterns[$key] = $pattern;
    }
    public function patterns($patterns)
    {
        foreach ($patterns as $key => $pattern) {
            $this->pattern($key, $pattern);
        }
    }
    protected function callFilter($filter, $request, $response = null)
    {
        return $this->events->until('router.' . $filter, [$request, $response]);
    }
    public function callRouteBefore($route, $request)
    {
        $response = $this->callPatternFilters($route, $request);
        return $response ?: $this->callAttachedBefores($route, $request);
    }
    protected function callPatternFilters($route, $request)
    {
        foreach ($this->findPatternFilters($request) as $filter => $parameters) {
            $response = $this->callRouteFilter($filter, $parameters, $route, $request);
            if (!is_null($response)) {
                return $response;
            }
        }
    }
    public function findPatternFilters($request)
    {
        $results = [];
        list($path, $method) = [$request->path(), $request->getMethod()];
        foreach ($this->patternFilters as $pattern => $filters) {
            if (Str::is($pattern, $path)) {
                $merge = $this->patternsByMethod($method, $filters);
                $results = array_merge($results, $merge);
            }
        }
        foreach ($this->regexFilters as $pattern => $filters) {
            if (preg_match($pattern, $path)) {
                $merge = $this->patternsByMethod($method, $filters);
                $results = array_merge($results, $merge);
            }
        }
        return $results;
    }
    protected function patternsByMethod($method, $filters)
    {
        $results = [];
        foreach ($filters as $filter) {
            if ($this->filterSupportsMethod($filter, $method)) {
                $parsed = Route::parseFilters($filter['name']);
                $results = array_merge($results, $parsed);
            }
        }
        return $results;
    }
    protected function filterSupportsMethod($filter, $method)
    {
        $methods = $filter['methods'];
        return is_null($methods) || in_array($method, $methods);
    }
    protected function callAttachedBefores($route, $request)
    {
        foreach ($route->beforeFilters() as $filter => $parameters) {
            $response = $this->callRouteFilter($filter, $parameters, $route, $request);
            if (!is_null($response)) {
                return $response;
            }
        }
    }
    public function callRouteAfter($route, $request, $response)
    {
        foreach ($route->afterFilters() as $filter => $parameters) {
            $this->callRouteFilter($filter, $parameters, $route, $request, $response);
        }
    }
    public function callRouteFilter($filter, $parameters, $route, $request, $response = null)
    {
        $data = array_merge([$route, $request, $response], $parameters);
        return $this->events->until('router.filter: ' . $filter, $this->cleanFilterParameters($data));
    }
    protected function cleanFilterParameters(array $parameters)
    {
        return array_filter($parameters, function ($p) {
            return !is_null($p) && $p !== '';
        });
    }
    public function prepareResponse($request, $response)
    {
        if ($response instanceof PsrResponseInterface) {
            $response = (new HttpFoundationFactory())->createResponse($response);
        } elseif (!$response instanceof SymfonyResponse) {
            $response = new Response($response);
        }
        return $response->prepare($request);
    }
    public function hasGroupStack()
    {
        return !empty($this->groupStack);
    }
    public function getGroupStack()
    {
        return $this->groupStack;
    }
    public function input($key, $default = null)
    {
        return $this->current()->parameter($key, $default);
    }
    public function getCurrentRoute()
    {
        return $this->current();
    }
    public function current()
    {
        return $this->current;
    }
    public function has($name)
    {
        return $this->routes->hasNamedRoute($name);
    }
    public function currentRouteName()
    {
        return $this->current() ? $this->current()->getName() : null;
    }
    public function is()
    {
        foreach (func_get_args() as $pattern) {
            if (Str::is($pattern, $this->currentRouteName())) {
                return true;
            }
        }
        return false;
    }
    public function currentRouteNamed($name)
    {
        return $this->current() ? $this->current()->getName() == $name : false;
    }
    public function currentRouteAction()
    {
        if (!$this->current()) {
            return;
        }
        $action = $this->current()->getAction();
        return isset($action['controller']) ? $action['controller'] : null;
    }
    public function uses()
    {
        foreach (func_get_args() as $pattern) {
            if (Str::is($pattern, $this->currentRouteAction())) {
                return true;
            }
        }
        return false;
    }
    public function currentRouteUses($action)
    {
        return $this->currentRouteAction() == $action;
    }
    public function getCurrentRequest()
    {
        return $this->currentRequest;
    }
    public function getRoutes()
    {
        return $this->routes;
    }
    public function setRoutes(RouteCollection $routes)
    {
        foreach ($routes as $route) {
            $route->setContainer($this->container);
        }
        $this->routes = $routes;
        $this->container->instance('routes', $this->routes);
    }
    public function getPatterns()
    {
        return $this->patterns;
    }
}
}

namespace Royalcms\Component\Routing {
use Royalcms\Component\Http\RedirectResponse;
use Royalcms\Component\Session\StoreInterface as SessionStore;
class Redirector
{
    protected $generator;
    protected $session;
    public function __construct(UrlGenerator $generator)
    {
        $this->generator = $generator;
    }
    public function home($status = 302)
    {
        return $this->to($this->generator->route('home'), $status);
    }
    public function back($status = 302, $headers = [])
    {
        $back = $this->generator->previous();
        return $this->createRedirect($back, $status, $headers);
    }
    public function refresh($status = 302, $headers = [])
    {
        return $this->to($this->generator->getRequest()->path(), $status, $headers);
    }
    public function guest($path, $status = 302, $headers = [], $secure = null)
    {
        $this->session->put('url.intended', $this->generator->full());
        return $this->to($path, $status, $headers, $secure);
    }
    public function intended($default = '/', $status = 302, $headers = [], $secure = null)
    {
        $path = $this->session->pull('url.intended', $default);
        return $this->to($path, $status, $headers, $secure);
    }
    public function to($path, $status = 302, $headers = [], $secure = null)
    {
        $path = $this->generator->to($path, [], $secure);
        return $this->createRedirect($path, $status, $headers);
    }
    public function away($path, $status = 302, $headers = [])
    {
        return $this->createRedirect($path, $status, $headers);
    }
    public function secure($path, $status = 302, $headers = [])
    {
        return $this->to($path, $status, $headers, true);
    }
    public function route($route, $parameters = [], $status = 302, $headers = [])
    {
        $path = $this->generator->route($route, $parameters);
        return $this->to($path, $status, $headers);
    }
    public function action($action, $parameters = [], $status = 302, $headers = [])
    {
        $path = $this->generator->action($action, $parameters);
        return $this->to($path, $status, $headers);
    }
    protected function createRedirect($path, $status, $headers)
    {
        $redirect = new RedirectResponse($path, $status, $headers);
        if (isset($this->session)) {
            $redirect->setSession($this->session);
        }
        $redirect->setRequest($this->generator->getRequest());
        return $redirect;
    }
    public function getUrlGenerator()
    {
        return $this->generator;
    }
    public function setSession(SessionStore $session)
    {
        $this->session = $session;
    }
}
}

namespace Royalcms\Component\Routing {
use JsonSerializable;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Http\Response;
use Royalcms\Component\Http\JsonResponse;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Contracts\View\Factory as ViewFactory;
use Symfony\Component\HttpFoundation\StreamedResponse;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Royalcms\Component\Contracts\Routing\ResponseFactory as FactoryContract;
class ResponseFactory implements FactoryContract
{
    use Macroable {
        Macroable::__callStatic as private __callStaticResponse;
        Macroable::__call as private __callResponse;
    }
    protected $view;
    protected $redirector;
    public function __construct(ViewFactory $view, Redirector $redirector)
    {
        $this->view = $view;
        $this->redirector = $redirector;
    }
    public function make($content = '', $status = 200, array $headers = [])
    {
        return new Response($content, $status, $headers);
    }
    public function view($view, $data = [], $status = 200, array $headers = [])
    {
        return static::make($this->view->make($view, $data), $status, $headers);
    }
    public function json($data = [], $status = 200, array $headers = [], $options = 0)
    {
        if ($data instanceof Arrayable && !$data instanceof JsonSerializable) {
            $data = $data->toArray();
        }
        return new JsonResponse($data, $status, $headers, $options);
    }
    public function jsonp($callback, $data = [], $status = 200, array $headers = [], $options = 0)
    {
        return $this->json($data, $status, $headers, $options)->setCallback($callback);
    }
    public function stream($callback, $status = 200, array $headers = [])
    {
        return new StreamedResponse($callback, $status, $headers);
    }
    public function download($file, $name = null, array $headers = [], $disposition = 'attachment')
    {
        $response = new BinaryFileResponse($file, 200, $headers, true, $disposition);
        if (!is_null($name)) {
            return $response->setContentDisposition($disposition, $name, str_replace('%', '', Str::ascii($name)));
        }
        return $response;
    }
    public function redirectTo($path, $status = 302, $headers = [], $secure = null)
    {
        return $this->redirector->to($path, $status, $headers, $secure);
    }
    public function redirectToRoute($route, $parameters = [], $status = 302, $headers = [])
    {
        return $this->redirector->route($route, $parameters, $status, $headers);
    }
    public function redirectToAction($action, $parameters = [], $status = 302, $headers = [])
    {
        return $this->redirector->action($action, $parameters, $status, $headers);
    }
    public function redirectGuest($path, $status = 302, $headers = [], $secure = null)
    {
        return $this->redirector->guest($path, $status, $headers, $secure);
    }
    public function redirectToIntended($default = '/', $status = 302, $headers = [], $secure = null)
    {
        return $this->redirector->intended($default, $status, $headers, $secure);
    }
    public function __call($method, $parameters)
    {
        try {
            return $this->__callResponse($method, $parameters);
        } catch (\BadMethodCallException $e) {
            return call_user_func_array([royalcms('response'), $method], $parameters);
        }
    }
    public static function __callStatic($method, $parameters)
    {
        try {
            return static::__callStaticResponse($method, $parameters);
        } catch (\BadMethodCallException $e) {
            return call_user_func_array([royalcms('response'), $method], $parameters);
        }
    }
}
}

namespace Royalcms\Component\Routing {
use Countable;
use ArrayIterator;
use IteratorAggregate;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Http\Request;
use Royalcms\Component\Http\Response;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
class RouteCollection implements Countable, IteratorAggregate
{
    protected $routes = [];
    protected $allRoutes = [];
    protected $nameList = [];
    protected $actionList = [];
    public function add(Route $route)
    {
        $this->addToCollections($route);
        $this->addLookups($route);
        return $route;
    }
    protected function addToCollections($route)
    {
        $domainAndUri = $route->domain() . $route->getUri();
        foreach ($route->methods() as $method) {
            $this->routes[$method][$domainAndUri] = $route;
        }
        $this->allRoutes[$method . $domainAndUri] = $route;
    }
    protected function addLookups($route)
    {
        $action = $route->getAction();
        if (isset($action['as'])) {
            $this->nameList[$action['as']] = $route;
        }
        if (isset($action['controller'])) {
            $this->addToActionList($action, $route);
        }
    }
    public function refreshNameLookups()
    {
        $this->nameList = [];
        foreach ($this->allRoutes as $route) {
            if ($route->getName()) {
                $this->nameList[$route->getName()] = $route;
            }
        }
    }
    protected function addToActionList($action, $route)
    {
        $this->actionList[trim($action['controller'], '\\')] = $route;
    }
    public function match(Request $request)
    {
        $routes = $this->get($request->getMethod());
        $route = $this->check($routes, $request);
        if (!is_null($route)) {
            return $route->bind($request);
        }
        $others = $this->checkForAlternateVerbs($request);
        if (count($others) > 0) {
            return $this->getRouteForMethods($request, $others);
        }
        throw new NotFoundHttpException();
    }
    protected function checkForAlternateVerbs($request)
    {
        $methods = array_diff(Router::$verbs, [$request->getMethod()]);
        $others = [];
        foreach ($methods as $method) {
            if (!is_null($this->check($this->get($method), $request, false))) {
                $others[] = $method;
            }
        }
        return $others;
    }
    protected function getRouteForMethods($request, array $methods)
    {
        if ($request->method() == 'OPTIONS') {
            return (new Route('OPTIONS', $request->path(), function () use($methods) {
                return new Response('', 200, ['Allow' => implode(',', $methods)]);
            }))->bind($request);
        }
        $this->methodNotAllowed($methods);
    }
    protected function methodNotAllowed(array $others)
    {
        throw new MethodNotAllowedHttpException($others);
    }
    protected function check(array $routes, $request, $includingMethod = true)
    {
        return Arr::first($routes, function ($value, $key) use($request, $includingMethod) {
            return $value->matches($request, $includingMethod);
        });
    }
    protected function get($method = null)
    {
        if (is_null($method)) {
            return $this->getRoutes();
        }
        return Arr::get($this->routes, $method, []);
    }
    public function hasNamedRoute($name)
    {
        return !is_null($this->getByName($name));
    }
    public function getByName($name)
    {
        return isset($this->nameList[$name]) ? $this->nameList[$name] : null;
    }
    public function getByAction($action)
    {
        return isset($this->actionList[$action]) ? $this->actionList[$action] : null;
    }
    public function getRoutes()
    {
        return array_values($this->allRoutes);
    }
    public function getIterator()
    {
        return new ArrayIterator($this->getRoutes());
    }
    public function count()
    {
        return count($this->getRoutes());
    }
}
}

namespace Royalcms\Component\Routing {
use Closure;
use BadMethodCallException;
use Royalcms\Component\Support\Str;
use InvalidArgumentException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
abstract class Controller
{
    protected $middleware = [];
    protected $beforeFilters = [];
    protected $afterFilters = [];
    protected static $router;
    public function middleware($middleware, array $options = [])
    {
        $this->middleware[$middleware] = $options;
    }
    public function beforeFilter($filter, array $options = [])
    {
        $this->beforeFilters[] = $this->parseFilter($filter, $options);
    }
    public function afterFilter($filter, array $options = [])
    {
        $this->afterFilters[] = $this->parseFilter($filter, $options);
    }
    protected function parseFilter($filter, array $options)
    {
        $parameters = [];
        $original = $filter;
        if ($filter instanceof Closure) {
            $filter = $this->registerClosureFilter($filter);
        } elseif ($this->isInstanceFilter($filter)) {
            $filter = $this->registerInstanceFilter($filter);
        } else {
            list($filter, $parameters) = Route::parseFilter($filter);
        }
        return compact('original', 'filter', 'parameters', 'options');
    }
    protected function registerClosureFilter(Closure $filter)
    {
        $this->getRouter()->filter($name = spl_object_hash($filter), $filter);
        return $name;
    }
    protected function registerInstanceFilter($filter)
    {
        $this->getRouter()->filter($filter, [$this, substr($filter, 1)]);
        return $filter;
    }
    protected function isInstanceFilter($filter)
    {
        if (is_string($filter) && Str::startsWith($filter, '@')) {
            if (method_exists($this, substr($filter, 1))) {
                return true;
            }
            throw new InvalidArgumentException("Filter method [{$filter}] does not exist.");
        }
        return false;
    }
    public function forgetBeforeFilter($filter)
    {
        $this->beforeFilters = $this->removeFilter($filter, $this->getBeforeFilters());
    }
    public function forgetAfterFilter($filter)
    {
        $this->afterFilters = $this->removeFilter($filter, $this->getAfterFilters());
    }
    protected function removeFilter($removing, $current)
    {
        return array_filter($current, function ($filter) use($removing) {
            return $filter['original'] != $removing;
        });
    }
    public function getMiddleware()
    {
        return $this->middleware;
    }
    public function getBeforeFilters()
    {
        return $this->beforeFilters;
    }
    public function getAfterFilters()
    {
        return $this->afterFilters;
    }
    public static function getRouter()
    {
        return static::$router;
    }
    public static function setRouter(Router $router)
    {
        static::$router = $router;
    }
    public function callAction($method, $parameters)
    {
        return call_user_func_array([$this, $method], $parameters);
    }
    public function missingMethod($parameters = [])
    {
        throw new NotFoundHttpException('Controller method not found.');
    }
    public function __call($method, $parameters)
    {
        throw new BadMethodCallException("Method [{$method}] does not exist.");
    }
}
}

namespace Royalcms\Component\Routing {
use Closure;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Http\Request;
use Royalcms\Component\Pipeline\Pipeline;
use Royalcms\Component\Container\Container;
class ControllerDispatcher
{
    use RouteDependencyResolverTrait;
    protected $router;
    protected $container;
    public function __construct(Router $router, Container $container = null)
    {
        $this->router = $router;
        $this->container = $container;
    }
    public function dispatch(Route $route, Request $request, $controller, $method)
    {
        $instance = $this->makeController($controller);
        $this->assignAfter($instance, $route, $request, $method);
        $response = $this->before($instance, $route, $request, $method);
        if (is_null($response)) {
            $response = $this->callWithinStack($instance, $route, $request, $method);
        }
        return $response;
    }
    protected function makeController($controller)
    {
        Controller::setRouter($this->router);
        return $this->container->make($controller);
    }
    protected function callWithinStack($instance, $route, $request, $method)
    {
        $shouldSkipMiddleware = $this->container->bound('middleware.disable') && $this->container->make('middleware.disable') === true;
        $middleware = $shouldSkipMiddleware ? [] : $this->getMiddleware($instance, $method);
        return (new Pipeline($this->container))->send($request)->through($middleware)->then(function ($request) use($instance, $route, $method) {
            return $this->router->prepareResponse($request, $this->call($instance, $route, $method));
        });
    }
    protected function getMiddleware($instance, $method)
    {
        $results = [];
        foreach ($instance->getMiddleware() as $name => $options) {
            if (!$this->methodExcludedByOptions($method, $options)) {
                $results[] = $this->router->resolveMiddlewareClassName($name);
            }
        }
        return $results;
    }
    public function methodExcludedByOptions($method, array $options)
    {
        return isset($options['only']) && !in_array($method, (array) $options['only']) || !empty($options['except']) && in_array($method, (array) $options['except']);
    }
    protected function call($instance, $route, $method)
    {
        $parameters = $this->resolveClassMethodDependencies($route->parametersWithoutNulls(), $instance, $method);
        return $instance->callAction($method, $parameters);
    }
    protected function before($instance, $route, $request, $method)
    {
        foreach ($instance->getBeforeFilters() as $filter) {
            if ($this->filterApplies($filter, $request, $method)) {
                $response = $this->callFilter($filter, $route, $request);
                if (!is_null($response)) {
                    return $response;
                }
            }
        }
    }
    protected function assignAfter($instance, $route, $request, $method)
    {
        foreach ($instance->getAfterFilters() as $filter) {
            if ($this->filterApplies($filter, $request, $method)) {
                $route->after($this->getAssignableAfter($filter));
            }
        }
    }
    protected function getAssignableAfter($filter)
    {
        if ($filter['original'] instanceof Closure) {
            return $filter['filter'];
        }
        return $filter['original'];
    }
    protected function filterApplies($filter, $request, $method)
    {
        foreach (['Method', 'On'] as $type) {
            if ($this->{"filterFails{$type}"}($filter, $request, $method)) {
                return false;
            }
        }
        return true;
    }
    protected function filterFailsMethod($filter, $request, $method)
    {
        return $this->methodExcludedByOptions($method, $filter['options']);
    }
    protected function filterFailsOn($filter, $request, $method)
    {
        $on = Arr::get($filter, 'options.on');
        if (is_null($on)) {
            return false;
        }
        if (is_string($on)) {
            $on = explode('|', $on);
        }
        return !in_array(strtolower($request->getMethod()), $on);
    }
    protected function callFilter($filter, $route, $request)
    {
        return $this->router->callRouteFilter($filter['filter'], $filter['parameters'], $route, $request);
    }
}
}

namespace Royalcms\Component\Routing {
use ReflectionClass;
use ReflectionMethod;
use Royalcms\Component\Support\Str;
class ControllerInspector
{
    protected $verbs = ['any', 'get', 'post', 'put', 'patch', 'delete', 'head', 'options'];
    public function getRoutable($controller, $prefix)
    {
        $routable = [];
        $reflection = new ReflectionClass($controller);
        $methods = $reflection->getMethods(ReflectionMethod::IS_PUBLIC);
        foreach ($methods as $method) {
            if ($this->isRoutable($method)) {
                $data = $this->getMethodData($method, $prefix);
                $routable[$method->name][] = $data;
                if ($data['plain'] == $prefix . '/index') {
                    $routable[$method->name][] = $this->getIndexData($data, $prefix);
                }
            }
        }
        return $routable;
    }
    public function isRoutable(ReflectionMethod $method)
    {
        if ($method->class == 'Royalcms\\Component\\Routing\\Controller') {
            return false;
        }
        return Str::startsWith($method->name, $this->verbs);
    }
    public function getMethodData(ReflectionMethod $method, $prefix)
    {
        $verb = $this->getVerb($name = $method->name);
        $uri = $this->addUriWildcards($plain = $this->getPlainUri($name, $prefix));
        return compact('verb', 'plain', 'uri');
    }
    protected function getIndexData($data, $prefix)
    {
        return ['verb' => $data['verb'], 'plain' => $prefix, 'uri' => $prefix];
    }
    public function getVerb($name)
    {
        return head(explode('_', Str::snake($name)));
    }
    public function getPlainUri($name, $prefix)
    {
        return $prefix . '/' . implode('-', array_slice(explode('_', Str::snake($name)), 1));
    }
    public function addUriWildcards($uri)
    {
        return $uri . '/{one?}/{two?}/{three?}/{four?}/{five?}';
    }
}
}

namespace Royalcms\Component\Routing {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Http\Request;
use InvalidArgumentException;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Routing\UrlRoutable;
use Royalcms\Component\Contracts\Routing\UrlGenerator as UrlGeneratorContract;
class UrlGenerator implements UrlGeneratorContract
{
    use Macroable;
    protected $routes;
    protected $request;
    protected $forcedRoot;
    protected $forceSchema;
    protected $cachedRoot;
    protected $cachedSchema;
    protected $rootNamespace;
    protected $sessionResolver;
    protected $dontEncode = ['%2F' => '/', '%40' => '@', '%3A' => ':', '%3B' => ';', '%2C' => ',', '%3D' => '=', '%2B' => '+', '%21' => '!', '%2A' => '*', '%7C' => '|', '%3F' => '?', '%26' => '&', '%23' => '#', '%25' => '%'];
    public function __construct(RouteCollection $routes, Request $request)
    {
        $this->routes = $routes;
        $this->setRequest($request);
    }
    public function full()
    {
        return $this->request->fullUrl();
    }
    public function current()
    {
        return $this->to($this->request->getPathInfo());
    }
    public function previous()
    {
        $referrer = $this->request->headers->get('referer');
        $url = $referrer ? $this->to($referrer) : $this->getPreviousUrlFromSession();
        return $url ?: $this->to('/');
    }
    public function to($path, $extra = [], $secure = null)
    {
        if ($this->isValidUrl($path)) {
            return $path;
        }
        $scheme = $this->getScheme($secure);
        $extra = $this->formatParameters($extra);
        $tail = implode('/', array_map('rawurlencode', (array) $extra));
        $root = $this->getRootUrl($scheme);
        if (($queryPosition = strpos($path, '?')) !== false) {
            $query = mb_substr($path, $queryPosition);
            $path = mb_substr($path, 0, $queryPosition);
        } else {
            $query = '';
        }
        return $this->trimUrl($root, $path, $tail) . $query;
    }
    public function secure($path, $parameters = [])
    {
        return $this->to($path, $parameters, true);
    }
    public function asset($path, $secure = null)
    {
        if ($this->isValidUrl($path)) {
            return $path;
        }
        $root = $this->getRootUrl($this->getScheme($secure));
        return $this->removeIndex($root) . '/' . trim($path, '/');
    }
    public function assetFrom($root, $path, $secure = null)
    {
        $root = $this->getRootUrl($this->getScheme($secure), $root);
        return $this->removeIndex($root) . '/' . trim($path, '/');
    }
    protected function removeIndex($root)
    {
        $i = 'index.php';
        return Str::contains($root, $i) ? str_replace('/' . $i, '', $root) : $root;
    }
    public function secureAsset($path)
    {
        return $this->asset($path, true);
    }
    protected function getScheme($secure)
    {
        if (is_null($secure)) {
            if (is_null($this->cachedSchema)) {
                $this->cachedSchema = $this->forceSchema ?: $this->request->getScheme() . '://';
            }
            return $this->cachedSchema;
        }
        return $secure ? 'https://' : 'http://';
    }
    public function forceSchema($schema)
    {
        $this->cachedSchema = null;
        $this->forceSchema = $schema . '://';
    }
    public function route($name, $parameters = [], $absolute = true)
    {
        if (!is_null($route = $this->routes->getByName($name))) {
            return $this->toRoute($route, $parameters, $absolute);
        }
        throw new InvalidArgumentException("Route [{$name}] not defined.");
    }
    protected function toRoute($route, $parameters, $absolute)
    {
        $parameters = $this->formatParameters($parameters);
        $domain = $this->getRouteDomain($route, $parameters);
        $uri = strtr(rawurlencode($this->addQueryString($this->trimUrl($root = $this->replaceRoot($route, $domain, $parameters), $this->replaceRouteParameters($route->uri(), $parameters)), $parameters)), $this->dontEncode);
        return $absolute ? $uri : '/' . ltrim(str_replace($root, '', $uri), '/');
    }
    protected function replaceRoot($route, $domain, &$parameters)
    {
        return $this->replaceRouteParameters($this->getRouteRoot($route, $domain), $parameters);
    }
    protected function replaceRouteParameters($path, array &$parameters)
    {
        if (count($parameters)) {
            $path = preg_replace_sub('/\\{.*?\\}/', $parameters, $this->replaceNamedParameters($path, $parameters));
        }
        return trim(preg_replace('/\\{.*?\\?\\}/', '', $path), '/');
    }
    protected function replaceNamedParameters($path, &$parameters)
    {
        return preg_replace_callback('/\\{(.*?)\\??\\}/', function ($m) use(&$parameters) {
            return isset($parameters[$m[1]]) ? Arr::pull($parameters, $m[1]) : $m[0];
        }, $path);
    }
    protected function addQueryString($uri, array $parameters)
    {
        if (!is_null($fragment = parse_url($uri, PHP_URL_FRAGMENT))) {
            $uri = preg_replace('/#.*/', '', $uri);
        }
        $uri .= $this->getRouteQueryString($parameters);
        return is_null($fragment) ? $uri : $uri . "#{$fragment}";
    }
    protected function formatParameters($parameters)
    {
        return $this->replaceRoutableParameters($parameters);
    }
    protected function replaceRoutableParameters($parameters = [])
    {
        $parameters = is_array($parameters) ? $parameters : [$parameters];
        foreach ($parameters as $key => $parameter) {
            if ($parameter instanceof UrlRoutable) {
                $parameters[$key] = $parameter->getRouteKey();
            }
        }
        return $parameters;
    }
    protected function getRouteQueryString(array $parameters)
    {
        if (count($parameters) == 0) {
            return '';
        }
        $query = http_build_query($keyed = $this->getStringParameters($parameters));
        if (count($keyed) < count($parameters)) {
            $query .= '&' . implode('&', $this->getNumericParameters($parameters));
        }
        return '?' . trim($query, '&');
    }
    protected function getStringParameters(array $parameters)
    {
        return Arr::where($parameters, function ($k) {
            return is_string($k);
        });
    }
    protected function getNumericParameters(array $parameters)
    {
        return Arr::where($parameters, function ($k) {
            return is_numeric($k);
        });
    }
    protected function getRouteDomain($route, &$parameters)
    {
        return $route->domain() ? $this->formatDomain($route, $parameters) : null;
    }
    protected function formatDomain($route, &$parameters)
    {
        return $this->addPortToDomain($this->getDomainAndScheme($route));
    }
    protected function getDomainAndScheme($route)
    {
        return $this->getRouteScheme($route) . $route->domain();
    }
    protected function addPortToDomain($domain)
    {
        $secure = $this->request->isSecure();
        $port = (int) $this->request->getPort();
        if ($secure && $port === 443 || !$secure && $port === 80) {
            return $domain;
        }
        return $domain . ':' . $port;
    }
    protected function getRouteRoot($route, $domain)
    {
        return $this->getRootUrl($this->getRouteScheme($route), $domain);
    }
    protected function getRouteScheme($route)
    {
        if ($route->httpOnly()) {
            return $this->getScheme(false);
        } elseif ($route->httpsOnly()) {
            return $this->getScheme(true);
        }
        return $this->getScheme(null);
    }
    public function action($action, $parameters = [], $absolute = true)
    {
        if ($this->rootNamespace && !(strpos($action, '\\') === 0)) {
            $action = $this->rootNamespace . '\\' . $action;
        } else {
            $action = trim($action, '\\');
        }
        if (!is_null($route = $this->routes->getByAction($action))) {
            return $this->toRoute($route, $parameters, $absolute);
        }
        throw new InvalidArgumentException("Action {$action} not defined.");
    }
    protected function getRootUrl($scheme, $root = null)
    {
        if (is_null($root)) {
            if (is_null($this->cachedRoot)) {
                $this->cachedRoot = $this->forcedRoot ?: $this->request->root();
            }
            $root = $this->cachedRoot;
        }
        $start = Str::startsWith($root, 'http://') ? 'http://' : 'https://';
        return preg_replace('~' . $start . '~', $scheme, $root, 1);
    }
    public function forceRootUrl($root)
    {
        $this->forcedRoot = rtrim($root, '/');
        $this->cachedRoot = null;
    }
    public function isValidUrl($path)
    {
        if (Str::startsWith($path, ['#', '//', 'mailto:', 'tel:', 'http://', 'https://'])) {
            return true;
        }
        return filter_var($path, FILTER_VALIDATE_URL) !== false;
    }
    protected function trimUrl($root, $path, $tail = '')
    {
        return trim($root . '/' . trim($path . '/' . $tail, '/'), '/');
    }
    public function getRequest()
    {
        return $this->request;
    }
    public function setRequest(Request $request)
    {
        $this->request = $request;
        $this->cachedRoot = null;
        $this->cachedSchema = null;
    }
    public function setRoutes(RouteCollection $routes)
    {
        $this->routes = $routes;
        return $this;
    }
    protected function getPreviousUrlFromSession()
    {
        $session = $this->getSession();
        return $session ? $session->previousUrl() : null;
    }
    protected function getSession()
    {
        if ($this->sessionResolver) {
            return call_user_func($this->sessionResolver);
        }
    }
    public function setSessionResolver(callable $sessionResolver)
    {
        $this->sessionResolver = $sessionResolver;
        return $this;
    }
    public function setRootControllerNamespace($rootNamespace)
    {
        $this->rootNamespace = $rootNamespace;
        return $this;
    }
}
}

namespace Royalcms\Component\Routing\Matching {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Routing\Route;
interface ValidatorInterface
{
    public function matches(Route $route, Request $request);
}
}

namespace Royalcms\Component\Routing\Matching {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Routing\Route;
class HostValidator implements ValidatorInterface
{
    public function matches(Route $route, Request $request)
    {
        if (is_null($route->getCompiled()->getHostRegex())) {
            return true;
        }
        return preg_match($route->getCompiled()->getHostRegex(), $request->getHost());
    }
}
}

namespace Royalcms\Component\Routing\Matching {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Routing\Route;
class MethodValidator implements ValidatorInterface
{
    public function matches(Route $route, Request $request)
    {
        return in_array($request->getMethod(), $route->methods());
    }
}
}

namespace Royalcms\Component\Routing\Matching {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Routing\Route;
class SchemeValidator implements ValidatorInterface
{
    public function matches(Route $route, Request $request)
    {
        if ($route->httpOnly()) {
            return !$request->secure();
        } elseif ($route->secure()) {
            return $request->secure();
        }
        return true;
    }
}
}

namespace Royalcms\Component\Routing\Matching {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Routing\Route;
class UriValidator implements ValidatorInterface
{
    public function matches(Route $route, Request $request)
    {
        $path = $request->path() == '/' ? '/' : '/' . $request->path();
        return preg_match($route->getCompiled()->getRegex(), rawurldecode($path));
    }
}
}

namespace Royalcms\Component\Database\Query {
use Closure;
use BadMethodCallException;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use InvalidArgumentException;
use Royalcms\Component\Pagination\Paginator;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Database\ConnectionInterface;
use Royalcms\Component\Database\Query\Grammars\Grammar;
use Royalcms\Component\Pagination\LengthAwarePaginator;
use Royalcms\Component\Database\Query\Processors\Processor;
class Builder
{
    use Macroable {
        __call as macroCall;
    }
    protected $connection;
    protected $grammar;
    protected $processor;
    protected $bindings = ['select' => [], 'join' => [], 'where' => [], 'having' => [], 'order' => [], 'union' => []];
    public $aggregate;
    public $columns;
    public $distinct = false;
    public $from;
    public $joins;
    public $wheres;
    public $groups;
    public $havings;
    public $orders;
    public $limit;
    public $offset;
    public $unions;
    public $unionLimit;
    public $unionOffset;
    public $unionOrders;
    public $lock;
    protected $backups = [];
    protected $bindingBackups = [];
    protected $operators = ['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'like binary', 'not like', 'between', 'ilike', '&', '|', '^', '<<', '>>', 'rlike', 'regexp', 'not regexp', '~', '~*', '!~', '!~*', 'similar to', 'not similar to'];
    protected $useWritePdo = false;
    public function __construct(ConnectionInterface $connection, Grammar $grammar, Processor $processor)
    {
        $this->grammar = $grammar;
        $this->processor = $processor;
        $this->connection = $connection;
    }
    public function select($columns = ['*'])
    {
        $this->columns = is_array($columns) ? $columns : func_get_args();
        return $this;
    }
    public function selectRaw($expression, array $bindings = [])
    {
        $this->addSelect(new Expression($expression));
        if ($bindings) {
            $this->addBinding($bindings, 'select');
        }
        return $this;
    }
    public function selectSub($query, $as)
    {
        if ($query instanceof Closure) {
            $callback = $query;
            $callback($query = $this->newQuery());
        }
        if ($query instanceof self) {
            $bindings = $query->getBindings();
            $query = $query->toSql();
        } elseif (is_string($query)) {
            $bindings = [];
        } else {
            throw new InvalidArgumentException();
        }
        return $this->selectRaw('(' . $query . ') as ' . $this->grammar->wrap($as), $bindings);
    }
    public function addSelect($column)
    {
        $column = is_array($column) ? $column : func_get_args();
        $this->columns = array_merge((array) $this->columns, $column);
        return $this;
    }
    public function distinct()
    {
        $this->distinct = true;
        return $this;
    }
    public function from($table)
    {
        $this->from = $table;
        return $this;
    }
    public function join($table, $one, $operator = null, $two = null, $type = 'inner', $where = false)
    {
        if ($one instanceof Closure) {
            $join = new JoinClause($type, $table);
            call_user_func($one, $join);
            $this->joins[] = $join;
            $this->addBinding($join->bindings, 'join');
        } else {
            $join = new JoinClause($type, $table);
            $this->joins[] = $join->on($one, $operator, $two, 'and', $where);
            $this->addBinding($join->bindings, 'join');
        }
        return $this;
    }
    public function joinWhere($table, $one, $operator, $two, $type = 'inner')
    {
        return $this->join($table, $one, $operator, $two, $type, true);
    }
    public function leftJoin($table, $first, $operator = null, $second = null)
    {
        return $this->join($table, $first, $operator, $second, 'left');
    }
    public function leftJoinWhere($table, $one, $operator, $two)
    {
        return $this->joinWhere($table, $one, $operator, $two, 'left');
    }
    public function rightJoin($table, $first, $operator = null, $second = null)
    {
        return $this->join($table, $first, $operator, $second, 'right');
    }
    public function rightJoinWhere($table, $one, $operator, $two)
    {
        return $this->joinWhere($table, $one, $operator, $two, 'right');
    }
    public function where($column, $operator = null, $value = null, $boolean = 'and')
    {
        if (is_array($column)) {
            return $this->whereNested(function ($query) use($column) {
                foreach ($column as $key => $value) {
                    $query->where($key, '=', $value);
                }
            }, $boolean);
        }
        if (func_num_args() == 2) {
            list($value, $operator) = [$operator, '='];
        } elseif ($this->invalidOperatorAndValue($operator, $value)) {
            throw new InvalidArgumentException('Illegal operator and value combination.');
        }
        if ($column instanceof Closure) {
            return $this->whereNested($column, $boolean);
        }
        if (!in_array(strtolower($operator), $this->operators, true)) {
            list($value, $operator) = [$operator, '='];
        }
        if ($value instanceof Closure) {
            return $this->whereSub($column, $operator, $value, $boolean);
        }
        if (is_null($value)) {
            return $this->whereNull($column, $boolean, $operator != '=');
        }
        $type = 'Basic';
        $this->wheres[] = compact('type', 'column', 'operator', 'value', 'boolean');
        if (!$value instanceof Expression) {
            $this->addBinding($value, 'where');
        }
        return $this;
    }
    public function orWhere($column, $operator = null, $value = null)
    {
        return $this->where($column, $operator, $value, 'or');
    }
    protected function invalidOperatorAndValue($operator, $value)
    {
        $isOperator = in_array($operator, $this->operators);
        return $isOperator && $operator != '=' && is_null($value);
    }
    public function whereRaw($sql, array $bindings = [], $boolean = 'and')
    {
        $type = 'raw';
        $this->wheres[] = compact('type', 'sql', 'boolean');
        $this->addBinding($bindings, 'where');
        return $this;
    }
    public function orWhereRaw($sql, array $bindings = [])
    {
        return $this->whereRaw($sql, $bindings, 'or');
    }
    public function whereBetween($column, array $values, $boolean = 'and', $not = false)
    {
        $type = 'between';
        $this->wheres[] = compact('column', 'type', 'boolean', 'not');
        $this->addBinding($values, 'where');
        return $this;
    }
    public function orWhereBetween($column, array $values)
    {
        return $this->whereBetween($column, $values, 'or');
    }
    public function whereNotBetween($column, array $values, $boolean = 'and')
    {
        return $this->whereBetween($column, $values, $boolean, true);
    }
    public function orWhereNotBetween($column, array $values)
    {
        return $this->whereNotBetween($column, $values, 'or');
    }
    public function whereNested(Closure $callback, $boolean = 'and')
    {
        $query = $this->newQuery();
        $query->from($this->from);
        call_user_func($callback, $query);
        return $this->addNestedWhereQuery($query, $boolean);
    }
    public function addNestedWhereQuery($query, $boolean = 'and')
    {
        if (count($query->wheres)) {
            $type = 'Nested';
            $this->wheres[] = compact('type', 'query', 'boolean');
            $this->addBinding($query->getBindings(), 'where');
        }
        return $this;
    }
    protected function whereSub($column, $operator, Closure $callback, $boolean)
    {
        $type = 'Sub';
        $query = $this->newQuery();
        call_user_func($callback, $query);
        $this->wheres[] = compact('type', 'column', 'operator', 'query', 'boolean');
        $this->addBinding($query->getBindings(), 'where');
        return $this;
    }
    public function whereExists(Closure $callback, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotExists' : 'Exists';
        $query = $this->newQuery();
        call_user_func($callback, $query);
        $this->wheres[] = compact('type', 'operator', 'query', 'boolean');
        $this->addBinding($query->getBindings(), 'where');
        return $this;
    }
    public function orWhereExists(Closure $callback, $not = false)
    {
        return $this->whereExists($callback, 'or', $not);
    }
    public function whereNotExists(Closure $callback, $boolean = 'and')
    {
        return $this->whereExists($callback, $boolean, true);
    }
    public function orWhereNotExists(Closure $callback)
    {
        return $this->orWhereExists($callback, true);
    }
    public function whereIn($column, $values, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotIn' : 'In';
        if ($values instanceof static) {
            return $this->whereInExistingQuery($column, $values, $boolean, $not);
        }
        if ($values instanceof Closure) {
            return $this->whereInSub($column, $values, $boolean, $not);
        }
        if ($values instanceof Arrayable) {
            $values = $values->toArray();
        }
        $this->wheres[] = compact('type', 'column', 'values', 'boolean');
        $this->addBinding($values, 'where');
        return $this;
    }
    public function orWhereIn($column, $values)
    {
        return $this->whereIn($column, $values, 'or');
    }
    public function whereNotIn($column, $values, $boolean = 'and')
    {
        return $this->whereIn($column, $values, $boolean, true);
    }
    public function orWhereNotIn($column, $values)
    {
        return $this->whereNotIn($column, $values, 'or');
    }
    protected function whereInSub($column, Closure $callback, $boolean, $not)
    {
        $type = $not ? 'NotInSub' : 'InSub';
        call_user_func($callback, $query = $this->newQuery());
        $this->wheres[] = compact('type', 'column', 'query', 'boolean');
        $this->addBinding($query->getBindings(), 'where');
        return $this;
    }
    protected function whereInExistingQuery($column, $query, $boolean, $not)
    {
        $type = $not ? 'NotInSub' : 'InSub';
        $this->wheres[] = compact('type', 'column', 'query', 'boolean');
        $this->addBinding($query->getBindings(), 'where');
        return $this;
    }
    public function whereNull($column, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotNull' : 'Null';
        $this->wheres[] = compact('type', 'column', 'boolean');
        return $this;
    }
    public function orWhereNull($column)
    {
        return $this->whereNull($column, 'or');
    }
    public function whereNotNull($column, $boolean = 'and')
    {
        return $this->whereNull($column, $boolean, true);
    }
    public function orWhereNotNull($column)
    {
        return $this->whereNotNull($column, 'or');
    }
    public function whereDate($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Date', $column, $operator, $value, $boolean);
    }
    public function whereDay($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Day', $column, $operator, $value, $boolean);
    }
    public function whereMonth($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Month', $column, $operator, $value, $boolean);
    }
    public function whereYear($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Year', $column, $operator, $value, $boolean);
    }
    protected function addDateBasedWhere($type, $column, $operator, $value, $boolean = 'and')
    {
        $this->wheres[] = compact('column', 'type', 'boolean', 'operator', 'value');
        $this->addBinding($value, 'where');
        return $this;
    }
    public function dynamicWhere($method, $parameters)
    {
        $finder = substr($method, 5);
        $segments = preg_split('/(And|Or)(?=[A-Z])/', $finder, -1, PREG_SPLIT_DELIM_CAPTURE);
        $connector = 'and';
        $index = 0;
        foreach ($segments as $segment) {
            if ($segment != 'And' && $segment != 'Or') {
                $this->addDynamic($segment, $connector, $parameters, $index);
                $index++;
            } else {
                $connector = $segment;
            }
        }
        return $this;
    }
    protected function addDynamic($segment, $connector, $parameters, $index)
    {
        $bool = strtolower($connector);
        $this->where(Str::snake($segment), '=', $parameters[$index], $bool);
    }
    public function groupBy()
    {
        foreach (func_get_args() as $arg) {
            $this->groups = array_merge((array) $this->groups, is_array($arg) ? $arg : [$arg]);
        }
        return $this;
    }
    public function having($column, $operator = null, $value = null, $boolean = 'and')
    {
        $type = 'basic';
        $this->havings[] = compact('type', 'column', 'operator', 'value', 'boolean');
        if (!$value instanceof Expression) {
            $this->addBinding($value, 'having');
        }
        return $this;
    }
    public function orHaving($column, $operator = null, $value = null)
    {
        return $this->having($column, $operator, $value, 'or');
    }
    public function havingRaw($sql, array $bindings = [], $boolean = 'and')
    {
        $type = 'raw';
        $this->havings[] = compact('type', 'sql', 'boolean');
        $this->addBinding($bindings, 'having');
        return $this;
    }
    public function orHavingRaw($sql, array $bindings = [])
    {
        return $this->havingRaw($sql, $bindings, 'or');
    }
    public function orderBy($column, $direction = 'asc')
    {
        $property = $this->unions ? 'unionOrders' : 'orders';
        $direction = strtolower($direction) == 'asc' ? 'asc' : 'desc';
        $this->{$property}[] = compact('column', 'direction');
        return $this;
    }
    public function latest($column = 'created_at')
    {
        return $this->orderBy($column, 'desc');
    }
    public function oldest($column = 'created_at')
    {
        return $this->orderBy($column, 'asc');
    }
    public function orderByRaw($sql, $bindings = [])
    {
        $property = $this->unions ? 'unionOrders' : 'orders';
        $type = 'raw';
        $this->{$property}[] = compact('type', 'sql');
        $this->addBinding($bindings, 'order');
        return $this;
    }
    public function offset($value)
    {
        $property = $this->unions ? 'unionOffset' : 'offset';
        $this->{$property} = max(0, $value);
        return $this;
    }
    public function skip($value)
    {
        return $this->offset($value);
    }
    public function limit($value)
    {
        $property = $this->unions ? 'unionLimit' : 'limit';
        if ($value >= 0) {
            $this->{$property} = $value;
        }
        return $this;
    }
    public function take($value)
    {
        return $this->limit($value);
    }
    public function forPage($page, $perPage = 15)
    {
        return $this->skip(($page - 1) * $perPage)->take($perPage);
    }
    public function union($query, $all = false)
    {
        if ($query instanceof Closure) {
            call_user_func($query, $query = $this->newQuery());
        }
        $this->unions[] = compact('query', 'all');
        $this->addBinding($query->getBindings(), 'union');
        return $this;
    }
    public function unionAll($query)
    {
        return $this->union($query, true);
    }
    public function lock($value = true)
    {
        $this->lock = $value;
        if ($this->lock) {
            $this->useWritePdo();
        }
        return $this;
    }
    public function lockForUpdate()
    {
        return $this->lock(true);
    }
    public function sharedLock()
    {
        return $this->lock(false);
    }
    public function toSql()
    {
        return $this->grammar->compileSelect($this);
    }
    public function find($id, $columns = ['*'])
    {
        return $this->where('id', '=', $id)->first($columns);
    }
    public function value($column)
    {
        $result = (array) $this->first([$column]);
        return count($result) > 0 ? reset($result) : null;
    }
    public function pluck($column)
    {
        return $this->value($column);
    }
    public function first($columns = ['*'])
    {
        $results = $this->take(1)->get($columns);
        return count($results) > 0 ? reset($results) : null;
    }
    public function get($columns = ['*'])
    {
        if (is_null($this->columns)) {
            $this->columns = $columns;
        }
        return $this->processor->processSelect($this, $this->runSelect());
    }
    public function getFresh($columns = ['*'])
    {
        return $this->get($columns);
    }
    protected function runSelect()
    {
        return $this->connection->select($this->toSql(), $this->getBindings(), !$this->useWritePdo);
    }
    public function paginate($perPage = 15, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $page = $page ?: Paginator::resolveCurrentPage($pageName);
        $total = $this->getCountForPagination($columns);
        $results = $this->forPage($page, $perPage)->get($columns);
        return new LengthAwarePaginator($results, $total, $perPage, $page, ['path' => Paginator::resolveCurrentPath(), 'pageName' => $pageName]);
    }
    public function simplePaginate($perPage = 15, $columns = ['*'], $pageName = 'page')
    {
        $page = Paginator::resolveCurrentPage($pageName);
        $this->skip(($page - 1) * $perPage)->take($perPage + 1);
        return new Paginator($this->get($columns), $perPage, $page, ['path' => Paginator::resolveCurrentPath(), 'pageName' => $pageName]);
    }
    public function getCountForPagination($columns = ['*'])
    {
        $this->backupFieldsForCount();
        $this->aggregate = ['function' => 'count', 'columns' => $this->clearSelectAliases($columns)];
        $results = $this->get();
        $this->aggregate = null;
        $this->restoreFieldsForCount();
        if (isset($this->groups)) {
            return count($results);
        }
        return isset($results[0]) ? (int) array_change_key_case((array) $results[0])['aggregate'] : 0;
    }
    protected function backupFieldsForCount()
    {
        foreach (['orders', 'limit', 'offset', 'columns'] as $field) {
            $this->backups[$field] = $this->{$field};
            $this->{$field} = null;
        }
        foreach (['order', 'select'] as $key) {
            $this->bindingBackups[$key] = $this->bindings[$key];
            $this->bindings[$key] = [];
        }
    }
    protected function clearSelectAliases(array $columns)
    {
        return array_map(function ($column) {
            return is_string($column) && ($aliasPosition = strpos(strtolower($column), ' as ')) !== false ? substr($column, 0, $aliasPosition) : $column;
        }, $columns);
    }
    protected function restoreFieldsForCount()
    {
        foreach (['orders', 'limit', 'offset', 'columns'] as $field) {
            $this->{$field} = $this->backups[$field];
        }
        foreach (['order', 'select'] as $key) {
            $this->bindings[$key] = $this->bindingBackups[$key];
        }
        $this->backups = [];
        $this->bindingBackups = [];
    }
    public function chunk($count, callable $callback)
    {
        $results = $this->forPage($page = 1, $count)->get();
        while (count($results) > 0) {
            if (call_user_func($callback, $results) === false) {
                return false;
            }
            $page++;
            $results = $this->forPage($page, $count)->get();
        }
        return true;
    }
    public function lists($column, $key = null)
    {
        $results = $this->get(is_null($key) ? [$column] : [$column, $key]);
        return Arr::pluck($results, $this->stripTableForPluck($column), $this->stripTableForPluck($key));
    }
    protected function stripTableForPluck($column)
    {
        return is_null($column) ? $column : last(preg_split('~\\.| ~', $column));
    }
    public function implode($column, $glue = '')
    {
        return implode($glue, $this->lists($column));
    }
    public function exists()
    {
        $sql = $this->grammar->compileExists($this);
        $results = $this->connection->select($sql, $this->getBindings(), !$this->useWritePdo);
        if (isset($results[0])) {
            $results = (array) $results[0];
            return (bool) $results['exists'];
        }
        return false;
    }
    public function count($columns = '*')
    {
        if (!is_array($columns)) {
            $columns = [$columns];
        }
        return (int) $this->aggregate(__FUNCTION__, $columns);
    }
    public function min($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }
    public function max($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }
    public function sum($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }
    public function avg($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }
    public function average($column)
    {
        return $this->avg($column);
    }
    public function aggregate($function, $columns = ['*'])
    {
        $this->aggregate = compact('function', 'columns');
        $previousColumns = $this->columns;
        $previousSelectBindings = $this->bindings['select'];
        $this->bindings['select'] = [];
        $results = $this->get($columns);
        $this->aggregate = null;
        $this->columns = $previousColumns;
        $this->bindings['select'] = $previousSelectBindings;
        if (isset($results[0])) {
            return array_change_key_case((array) $results[0])['aggregate'];
        }
    }
    public function numericAggregate($function, $columns = ['*'])
    {
        $result = $this->aggregate($function, $columns);
        if (!$result) {
            return 0;
        }
        if (is_int($result) || is_float($result)) {
            return $result;
        }
        if (strpos((string) $result, '.') === false) {
            return (int) $result;
        }
        return (double) $result;
    }
    public function insert(array $values)
    {
        if (empty($values)) {
            return true;
        }
        if (!is_array(reset($values))) {
            $values = [$values];
        } else {
            foreach ($values as $key => $value) {
                ksort($value);
                $values[$key] = $value;
            }
        }
        $bindings = [];
        foreach ($values as $record) {
            foreach ($record as $value) {
                $bindings[] = $value;
            }
        }
        $sql = $this->grammar->compileInsert($this, $values);
        $bindings = $this->cleanBindings($bindings);
        return $this->connection->insert($sql, $bindings);
    }
    public function insertGetId(array $values, $sequence = null)
    {
        $sql = $this->grammar->compileInsertGetId($this, $values, $sequence);
        $values = $this->cleanBindings($values);
        return $this->processor->processInsertGetId($this, $sql, $values, $sequence);
    }
    public function update(array $values)
    {
        $bindings = array_values(array_merge($values, $this->getBindings()));
        $sql = $this->grammar->compileUpdate($this, $values);
        return $this->connection->update($sql, $this->cleanBindings($bindings));
    }
    public function increment($column, $amount = 1, array $extra = [])
    {
        if (!is_numeric($amount)) {
            throw new InvalidArgumentException('Non-numeric value passed to increment method.');
        }
        $wrapped = $this->grammar->wrap($column);
        $columns = array_merge([$column => $this->raw("{$wrapped} + {$amount}")], $extra);
        return $this->update($columns);
    }
    public function decrement($column, $amount = 1, array $extra = [])
    {
        if (!is_numeric($amount)) {
            throw new InvalidArgumentException('Non-numeric value passed to decrement method.');
        }
        $wrapped = $this->grammar->wrap($column);
        $columns = array_merge([$column => $this->raw("{$wrapped} - {$amount}")], $extra);
        return $this->update($columns);
    }
    public function delete($id = null)
    {
        if (!is_null($id)) {
            $this->where('id', '=', $id);
        }
        $sql = $this->grammar->compileDelete($this);
        return $this->connection->delete($sql, $this->getBindings());
    }
    public function truncate()
    {
        foreach ($this->grammar->compileTruncate($this) as $sql => $bindings) {
            $this->connection->statement($sql, $bindings);
        }
    }
    public function newQuery()
    {
        return new static($this->connection, $this->grammar, $this->processor);
    }
    public function mergeWheres($wheres, $bindings)
    {
        $this->wheres = array_merge((array) $this->wheres, (array) $wheres);
        $this->bindings['where'] = array_values(array_merge($this->bindings['where'], (array) $bindings));
    }
    protected function cleanBindings(array $bindings)
    {
        return array_values(array_filter($bindings, function ($binding) {
            return !$binding instanceof Expression;
        }));
    }
    public function raw($value)
    {
        return $this->connection->raw($value);
    }
    public function getBindings()
    {
        return Arr::flatten($this->bindings);
    }
    public function getRawBindings()
    {
        return $this->bindings;
    }
    public function setBindings(array $bindings, $type = 'where')
    {
        if (!array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }
        $this->bindings[$type] = $bindings;
        return $this;
    }
    public function addBinding($value, $type = 'where')
    {
        if (!array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }
        if (is_array($value)) {
            $this->bindings[$type] = array_values(array_merge($this->bindings[$type], $value));
        } else {
            $this->bindings[$type][] = $value;
        }
        return $this;
    }
    public function mergeBindings(Builder $query)
    {
        $this->bindings = array_merge_recursive($this->bindings, $query->bindings);
        return $this;
    }
    public function getConnection()
    {
        return $this->connection;
    }
    public function getProcessor()
    {
        return $this->processor;
    }
    public function getGrammar()
    {
        return $this->grammar;
    }
    public function useWritePdo()
    {
        $this->useWritePdo = true;
        return $this;
    }
    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }
        if (Str::startsWith($method, 'where')) {
            return $this->dynamicWhere($method, $parameters);
        }
        $className = get_class($this);
        throw new BadMethodCallException("Call to undefined method {$className}::{$method}()");
    }
}
}

namespace Royalcms\Component\Database\Eloquent {
use Closure;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Pagination\Paginator;
use Royalcms\Component\Database\Query\Expression;
use Royalcms\Component\Pagination\LengthAwarePaginator;
use Royalcms\Component\Database\Eloquent\Relations\Relation;
use Royalcms\Component\Database\Query\Builder as QueryBuilder;
class Builder
{
    protected $query;
    protected $model;
    protected $eagerLoad = [];
    protected $macros = [];
    protected $onDelete;
    protected $passthru = ['insert', 'insertGetId', 'getBindings', 'toSql', 'exists', 'count', 'min', 'max', 'avg', 'sum'];
    public function __construct(QueryBuilder $query)
    {
        $this->query = $query;
    }
    public function find($id, $columns = ['*'])
    {
        if (is_array($id)) {
            return $this->findMany($id, $columns);
        }
        $this->query->where($this->model->getQualifiedKeyName(), '=', $id);
        return $this->first($columns);
    }
    public function findMany($ids, $columns = ['*'])
    {
        if (empty($ids)) {
            return $this->model->newCollection();
        }
        $this->query->whereIn($this->model->getQualifiedKeyName(), $ids);
        return $this->get($columns);
    }
    public function findOrFail($id, $columns = ['*'])
    {
        $result = $this->find($id, $columns);
        if (is_array($id)) {
            if (count($result) == count(array_unique($id))) {
                return $result;
            }
        } elseif (!is_null($result)) {
            return $result;
        }
        throw (new ModelNotFoundException())->setModel(get_class($this->model));
    }
    public function findOrNew($id, $columns = ['*'])
    {
        if (!is_null($model = $this->find($id, $columns))) {
            return $model;
        }
        return $this->model->newInstance();
    }
    public function firstOrNew(array $attributes)
    {
        if (!is_null($instance = $this->where($attributes)->first())) {
            return $instance;
        }
        return $this->model->newInstance($attributes);
    }
    public function firstOrCreate(array $attributes)
    {
        if (!is_null($instance = $this->where($attributes)->first())) {
            return $instance;
        }
        $instance = $this->model->newInstance($attributes);
        $instance->save();
        return $instance;
    }
    public function updateOrCreate(array $attributes, array $values = [])
    {
        $instance = $this->firstOrNew($attributes);
        $instance->fill($values)->save();
        return $instance;
    }
    public function first($columns = ['*'])
    {
        return $this->take(1)->get($columns)->first();
    }
    public function firstOrFail($columns = ['*'])
    {
        if (!is_null($model = $this->first($columns))) {
            return $model;
        }
        throw (new ModelNotFoundException())->setModel(get_class($this->model));
    }
    public function get($columns = ['*'])
    {
        $models = $this->getModels($columns);
        if (count($models) > 0) {
            $models = $this->eagerLoadRelations($models);
        }
        return $this->model->newCollection($models);
    }
    public function value($column)
    {
        $result = $this->first([$column]);
        if ($result) {
            return $result->{$column};
        }
    }
    public function pluck($column)
    {
        return $this->value($column);
    }
    public function chunk($count, callable $callback)
    {
        $results = $this->forPage($page = 1, $count)->get();
        while (count($results) > 0) {
            if (call_user_func($callback, $results) === false) {
                return false;
            }
            $page++;
            $results = $this->forPage($page, $count)->get();
        }
        return true;
    }
    public function lists($column, $key = null)
    {
        $results = $this->query->lists($column, $key);
        if ($this->model->hasGetMutator($column)) {
            foreach ($results as $key => &$value) {
                $fill = [$column => $value];
                $value = $this->model->newFromBuilder($fill)->{$column};
            }
        }
        return collect($results);
    }
    public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)
    {
        $total = $this->query->getCountForPagination();
        $this->query->forPage($page = $page ?: Paginator::resolveCurrentPage($pageName), $perPage = $perPage ?: $this->model->getPerPage());
        return new LengthAwarePaginator($this->get($columns), $total, $perPage, $page, ['path' => Paginator::resolveCurrentPath(), 'pageName' => $pageName]);
    }
    public function simplePaginate($perPage = null, $columns = ['*'], $pageName = 'page')
    {
        $page = Paginator::resolveCurrentPage($pageName);
        $perPage = $perPage ?: $this->model->getPerPage();
        $this->skip(($page - 1) * $perPage)->take($perPage + 1);
        return new Paginator($this->get($columns), $perPage, $page, ['path' => Paginator::resolveCurrentPath(), 'pageName' => $pageName]);
    }
    public function update(array $values)
    {
        return $this->query->update($this->addUpdatedAtColumn($values));
    }
    public function increment($column, $amount = 1, array $extra = [])
    {
        $extra = $this->addUpdatedAtColumn($extra);
        return $this->query->increment($column, $amount, $extra);
    }
    public function decrement($column, $amount = 1, array $extra = [])
    {
        $extra = $this->addUpdatedAtColumn($extra);
        return $this->query->decrement($column, $amount, $extra);
    }
    protected function addUpdatedAtColumn(array $values)
    {
        if (!$this->model->usesTimestamps()) {
            return $values;
        }
        $column = $this->model->getUpdatedAtColumn();
        return Arr::add($values, $column, $this->model->freshTimestampString());
    }
    public function delete()
    {
        if (isset($this->onDelete)) {
            return call_user_func($this->onDelete, $this);
        }
        return $this->query->delete();
    }
    public function forceDelete()
    {
        return $this->query->delete();
    }
    public function onDelete(Closure $callback)
    {
        $this->onDelete = $callback;
    }
    public function getModels($columns = ['*'])
    {
        $results = $this->query->get($columns);
        $connection = $this->model->getConnectionName();
        return $this->model->hydrate($results, $connection)->all();
    }
    public function eagerLoadRelations(array $models)
    {
        foreach ($this->eagerLoad as $name => $constraints) {
            if (strpos($name, '.') === false) {
                $models = $this->loadRelation($models, $name, $constraints);
            }
        }
        return $models;
    }
    protected function loadRelation(array $models, $name, Closure $constraints)
    {
        $relation = $this->getRelation($name);
        $relation->addEagerConstraints($models);
        call_user_func($constraints, $relation);
        $models = $relation->initRelation($models, $name);
        $results = $relation->getEager();
        return $relation->match($models, $results, $name);
    }
    public function getRelation($name)
    {
        $relation = Relation::noConstraints(function () use($name) {
            return $this->getModel()->{$name}();
        });
        $nested = $this->nestedRelations($name);
        if (count($nested) > 0) {
            $relation->getQuery()->with($nested);
        }
        return $relation;
    }
    protected function nestedRelations($relation)
    {
        $nested = [];
        foreach ($this->eagerLoad as $name => $constraints) {
            if ($this->isNested($name, $relation)) {
                $nested[substr($name, strlen($relation . '.'))] = $constraints;
            }
        }
        return $nested;
    }
    protected function isNested($name, $relation)
    {
        $dots = Str::contains($name, '.');
        return $dots && Str::startsWith($name, $relation . '.');
    }
    public function where($column, $operator = null, $value = null, $boolean = 'and')
    {
        if ($column instanceof Closure) {
            $query = $this->model->newQueryWithoutScopes();
            call_user_func($column, $query);
            $this->query->addNestedWhereQuery($query->getQuery(), $boolean);
        } else {
            call_user_func_array([$this->query, 'where'], func_get_args());
        }
        return $this;
    }
    public function orWhere($column, $operator = null, $value = null)
    {
        return $this->where($column, $operator, $value, 'or');
    }
    public function has($relation, $operator = '>=', $count = 1, $boolean = 'and', Closure $callback = null)
    {
        if (strpos($relation, '.') !== false) {
            return $this->hasNested($relation, $operator, $count, $boolean, $callback);
        }
        $relation = $this->getHasRelationQuery($relation);
        $query = $relation->getRelationCountQuery($relation->getRelated()->newQuery(), $this);
        if ($callback) {
            call_user_func($callback, $query);
        }
        return $this->addHasWhere($query, $relation, $operator, $count, $boolean);
    }
    protected function hasNested($relations, $operator = '>=', $count = 1, $boolean = 'and', $callback = null)
    {
        $relations = explode('.', $relations);
        $closure = function ($q) use(&$closure, &$relations, $operator, $count, $boolean, $callback) {
            if (count($relations) > 1) {
                $q->whereHas(array_shift($relations), $closure);
            } else {
                $q->has(array_shift($relations), $operator, $count, 'and', $callback);
            }
        };
        return $this->has(array_shift($relations), '>=', 1, $boolean, $closure);
    }
    public function doesntHave($relation, $boolean = 'and', Closure $callback = null)
    {
        return $this->has($relation, '<', 1, $boolean, $callback);
    }
    public function whereHas($relation, Closure $callback, $operator = '>=', $count = 1)
    {
        return $this->has($relation, $operator, $count, 'and', $callback);
    }
    public function whereDoesntHave($relation, Closure $callback = null)
    {
        return $this->doesntHave($relation, 'and', $callback);
    }
    public function orHas($relation, $operator = '>=', $count = 1)
    {
        return $this->has($relation, $operator, $count, 'or');
    }
    public function orWhereHas($relation, Closure $callback, $operator = '>=', $count = 1)
    {
        return $this->has($relation, $operator, $count, 'or', $callback);
    }
    protected function addHasWhere(Builder $hasQuery, Relation $relation, $operator, $count, $boolean)
    {
        $this->mergeWheresToHas($hasQuery, $relation);
        if (is_numeric($count)) {
            $count = new Expression($count);
        }
        return $this->where(new Expression('(' . $hasQuery->toSql() . ')'), $operator, $count, $boolean);
    }
    protected function mergeWheresToHas(Builder $hasQuery, Relation $relation)
    {
        $relationQuery = $relation->getBaseQuery();
        $hasQuery = $hasQuery->getModel()->removeGlobalScopes($hasQuery);
        $hasQuery->mergeWheres($relationQuery->wheres, $relationQuery->getBindings());
        $this->query->addBinding($hasQuery->getQuery()->getBindings(), 'where');
    }
    protected function getHasRelationQuery($relation)
    {
        return Relation::noConstraints(function () use($relation) {
            return $this->getModel()->{$relation}();
        });
    }
    public function with($relations)
    {
        if (is_string($relations)) {
            $relations = func_get_args();
        }
        $eagers = $this->parseRelations($relations);
        $this->eagerLoad = array_merge($this->eagerLoad, $eagers);
        return $this;
    }
    protected function parseRelations(array $relations)
    {
        $results = [];
        foreach ($relations as $name => $constraints) {
            if (is_numeric($name)) {
                $f = function () {
                };
                list($name, $constraints) = [$constraints, $f];
            }
            $results = $this->parseNested($name, $results);
            $results[$name] = $constraints;
        }
        return $results;
    }
    protected function parseNested($name, $results)
    {
        $progress = [];
        foreach (explode('.', $name) as $segment) {
            $progress[] = $segment;
            if (!isset($results[$last = implode('.', $progress)])) {
                $results[$last] = function () {
                };
            }
        }
        return $results;
    }
    protected function callScope($scope, $parameters)
    {
        array_unshift($parameters, $this);
        return call_user_func_array([$this->model, $scope], $parameters) ?: $this;
    }
    public function getQuery()
    {
        return $this->query;
    }
    public function setQuery($query)
    {
        $this->query = $query;
        return $this;
    }
    public function getEagerLoads()
    {
        return $this->eagerLoad;
    }
    public function setEagerLoads(array $eagerLoad)
    {
        $this->eagerLoad = $eagerLoad;
        return $this;
    }
    public function getModel()
    {
        return $this->model;
    }
    public function setModel(Model $model)
    {
        $this->model = $model;
        $this->query->from($model->getTable());
        return $this;
    }
    public function macro($name, Closure $callback)
    {
        $this->macros[$name] = $callback;
    }
    public function getMacro($name)
    {
        return Arr::get($this->macros, $name);
    }
    public function __call($method, $parameters)
    {
        if (isset($this->macros[$method])) {
            array_unshift($parameters, $this);
            return call_user_func_array($this->macros[$method], $parameters);
        } elseif (method_exists($this->model, $scope = 'scope' . ucfirst($method))) {
            return $this->callScope($scope, $parameters);
        }
        $result = call_user_func_array([$this->query, $method], $parameters);
        return in_array($method, $this->passthru) ? $result : $this;
    }
    public function __clone()
    {
        $this->query = clone $this->query;
    }
}
}

namespace Royalcms\Component\Database\Eloquent {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Collection as BaseCollection;
class Collection extends BaseCollection
{
    public function find($key, $default = null)
    {
        if ($key instanceof Model) {
            $key = $key->getKey();
        }
        return Arr::first($this->items, function ($itemKey, $model) use($key) {
            return $model->getKey() == $key;
        }, $default);
    }
    public function load($relations)
    {
        if (count($this->items) > 0) {
            if (is_string($relations)) {
                $relations = func_get_args();
            }
            $query = $this->first()->newQuery()->with($relations);
            $this->items = $query->eagerLoadRelations($this->items);
        }
        return $this;
    }
    public function add($item)
    {
        $this->items[] = $item;
        return $this;
    }
    public function contains($key, $operator = null, $value = null)
    {
        if (func_num_args() == 2) {
            return parent::contains($key, $value);
        }
        if ($this->useAsCallable($key)) {
            return parent::contains($key);
        }
        $key = $key instanceof Model ? $key->getKey() : $key;
        return parent::contains(function ($model) use($key) {
            return $model->getKey() == $key;
        });
    }
    public function fetch($key)
    {
        return new static(Arr::fetch($this->toArray(), $key));
    }
    public function modelKeys()
    {
        return array_map(function ($model) {
            return $model->getKey();
        }, $this->items);
    }
    public function merge($items)
    {
        $dictionary = $this->getDictionary();
        foreach ($items as $item) {
            $dictionary[$item->getKey()] = $item;
        }
        return new static(array_values($dictionary));
    }
    public function diff($items)
    {
        $diff = new static();
        $dictionary = $this->getDictionary($items);
        foreach ($this->items as $item) {
            if (!isset($dictionary[$item->getKey()])) {
                $diff->add($item);
            }
        }
        return $diff;
    }
    public function intersect($items)
    {
        $intersect = new static();
        $dictionary = $this->getDictionary($items);
        foreach ($this->items as $item) {
            if (isset($dictionary[$item->getKey()])) {
                $intersect->add($item);
            }
        }
        return $intersect;
    }
    public function unique($key = null, $strict = false)
    {
        if (!is_null($key)) {
            return parent::unique($key);
        }
        return new static(array_values($this->getDictionary()));
    }
    public function only($keys)
    {
        $dictionary = Arr::only($this->getDictionary(), $keys);
        return new static(array_values($dictionary));
    }
    public function except($keys)
    {
        $dictionary = Arr::except($this->getDictionary(), $keys);
        return new static(array_values($dictionary));
    }
    public function withHidden($attributes)
    {
        $this->each(function ($model) use($attributes) {
            $model->withHidden($attributes);
        });
        return $this;
    }
    public function getDictionary($items = null)
    {
        $items = is_null($items) ? $this->items : $items;
        $dictionary = [];
        foreach ($items as $value) {
            $dictionary[$value->getKey()] = $value;
        }
        return $dictionary;
    }
    public function toBase()
    {
        return new BaseCollection($this->items);
    }
}
}

namespace Royalcms\Component\Bus {
use Royalcms\Component\Support\ServiceProvider;
class BusServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->singleton('Royalcms\\Component\\Bus\\Dispatcher', function ($royalcms) {
            return new Dispatcher($royalcms, function () use($royalcms) {
                return $royalcms['Royalcms\\Component\\Contracts\\Queue\\Queue'];
            });
        });
        $this->royalcms->alias('Royalcms\\Component\\Bus\\Dispatcher', 'Royalcms\\Component\\Contracts\\Bus\\Dispatcher');
        $this->royalcms->alias('Royalcms\\Component\\Bus\\Dispatcher', 'Royalcms\\Component\\Contracts\\Bus\\QueueingDispatcher');
    }
    public function provides()
    {
        return ['Royalcms\\Component\\Bus\\Dispatcher', 'Royalcms\\Component\\Contracts\\Bus\\Dispatcher', 'Royalcms\\Component\\Contracts\\Bus\\QueueingDispatcher'];
    }
}
}

namespace Royalcms\Component\Bus {
use Closure;
use ArrayAccess;
use ReflectionClass;
use RuntimeException;
use ReflectionParameter;
use InvalidArgumentException;
use Royalcms\Component\Pipeline\Pipeline;
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Contracts\Queue\Queue;
use Royalcms\Component\Contracts\Bus\SelfHandling;
use Royalcms\Component\Contracts\Queue\ShouldQueue;
use Royalcms\Component\Contracts\Container\Container;
use Royalcms\Component\Contracts\Bus\HandlerResolver;
use Royalcms\Component\Contracts\Bus\QueueingDispatcher;
use Royalcms\Component\Contracts\Bus\Dispatcher as DispatcherContract;
class Dispatcher implements DispatcherContract, QueueingDispatcher, HandlerResolver
{
    protected $container;
    protected $pipeline;
    protected $pipes = [];
    protected $queueResolver;
    protected $mappings = [];
    protected $mapper;
    public function __construct(Container $container, Closure $queueResolver = null)
    {
        $this->container = $container;
        $this->queueResolver = $queueResolver;
        $this->pipeline = new Pipeline($container);
    }
    public function dispatchFromArray($command, array $array)
    {
        return $this->dispatch($this->marshalFromArray($command, $array));
    }
    public function dispatchFrom($command, ArrayAccess $source, array $extras = [])
    {
        return $this->dispatch($this->marshal($command, $source, $extras));
    }
    protected function marshalFromArray($command, array $array)
    {
        return $this->marshal($command, new Collection(), $array);
    }
    protected function marshal($command, ArrayAccess $source, array $extras = [])
    {
        $injected = [];
        $reflection = new ReflectionClass($command);
        if ($constructor = $reflection->getConstructor()) {
            $injected = array_map(function ($parameter) use($command, $source, $extras) {
                return $this->getParameterValueForCommand($command, $source, $parameter, $extras);
            }, $constructor->getParameters());
        }
        return $reflection->newInstanceArgs($injected);
    }
    protected function getParameterValueForCommand($command, ArrayAccess $source, ReflectionParameter $parameter, array $extras = [])
    {
        if (array_key_exists($parameter->name, $extras)) {
            return $extras[$parameter->name];
        }
        if (isset($source[$parameter->name])) {
            return $source[$parameter->name];
        }
        if ($parameter->isDefaultValueAvailable()) {
            return $parameter->getDefaultValue();
        }
        MarshalException::whileMapping($command, $parameter);
    }
    public function dispatch($command, Closure $afterResolving = null)
    {
        if ($this->queueResolver && $this->commandShouldBeQueued($command)) {
            return $this->dispatchToQueue($command);
        } else {
            return $this->dispatchNow($command, $afterResolving);
        }
    }
    public function dispatchNow($command, Closure $afterResolving = null)
    {
        return $this->pipeline->send($command)->through($this->pipes)->then(function ($command) use($afterResolving) {
            if ($command instanceof SelfHandling) {
                return $this->container->call([$command, 'handle']);
            }
            $handler = $this->resolveHandler($command);
            if ($afterResolving) {
                call_user_func($afterResolving, $handler);
            }
            return call_user_func([$handler, $this->getHandlerMethod($command)], $command);
        });
    }
    protected function commandShouldBeQueued($command)
    {
        if ($command instanceof ShouldQueue) {
            return true;
        }
        return (new ReflectionClass($this->getHandlerClass($command)))->implementsInterface('Royalcms\\Component\\Contracts\\Queue\\ShouldQueue');
    }
    public function dispatchToQueue($command)
    {
        $queue = call_user_func($this->queueResolver);
        if (!$queue instanceof Queue) {
            throw new RuntimeException('Queue resolver did not return a Queue implementation.');
        }
        if (method_exists($command, 'queue')) {
            return $command->queue($queue, $command);
        } else {
            return $this->pushCommandToQueue($queue, $command);
        }
    }
    protected function pushCommandToQueue($queue, $command)
    {
        if (isset($command->queue, $command->delay)) {
            return $queue->laterOn($command->queue, $command->delay, $command);
        }
        if (isset($command->queue)) {
            return $queue->pushOn($command->queue, $command);
        }
        if (isset($command->delay)) {
            return $queue->later($command->delay, $command);
        }
        return $queue->push($command);
    }
    public function resolveHandler($command)
    {
        if ($command instanceof SelfHandling) {
            return $command;
        }
        return $this->container->make($this->getHandlerClass($command));
    }
    public function getHandlerClass($command)
    {
        if ($command instanceof SelfHandling) {
            return get_class($command);
        }
        return $this->inflectSegment($command, 0);
    }
    public function getHandlerMethod($command)
    {
        if ($command instanceof SelfHandling) {
            return 'handle';
        }
        return $this->inflectSegment($command, 1);
    }
    protected function inflectSegment($command, $segment)
    {
        $className = get_class($command);
        if (isset($this->mappings[$className])) {
            return $this->getMappingSegment($className, $segment);
        } elseif ($this->mapper) {
            return $this->getMapperSegment($command, $segment);
        }
        throw new InvalidArgumentException("No handler registered for command [{$className}]");
    }
    protected function getMappingSegment($className, $segment)
    {
        return explode('@', $this->mappings[$className])[$segment];
    }
    protected function getMapperSegment($command, $segment)
    {
        return explode('@', call_user_func($this->mapper, $command))[$segment];
    }
    public function maps(array $commands)
    {
        $this->mappings = array_merge($this->mappings, $commands);
    }
    public function mapUsing(Closure $mapper)
    {
        $this->mapper = $mapper;
    }
    public static function simpleMapping($command, $commandNamespace, $handlerNamespace)
    {
        $command = str_replace($commandNamespace, '', get_class($command));
        return $handlerNamespace . '\\' . trim($command, '\\') . 'Handler@handle';
    }
    public function pipeThrough(array $pipes)
    {
        $this->pipes = $pipes;
        return $this;
    }
}
}

namespace Royalcms\Component\Pipeline {
use Closure;
use Royalcms\Component\Contracts\Container\Container;
use Royalcms\Component\Contracts\Pipeline\Pipeline as PipelineContract;
class Pipeline implements PipelineContract
{
    protected $container;
    protected $passable;
    protected $pipes = [];
    protected $method = 'handle';
    public function __construct(Container $container)
    {
        $this->container = $container;
    }
    public function send($passable)
    {
        $this->passable = $passable;
        return $this;
    }
    public function through($pipes)
    {
        $this->pipes = is_array($pipes) ? $pipes : func_get_args();
        return $this;
    }
    public function via($method)
    {
        $this->method = $method;
        return $this;
    }
    public function then(Closure $destination)
    {
        $firstSlice = $this->getInitialSlice($destination);
        $pipes = array_reverse($this->pipes);
        return call_user_func(array_reduce($pipes, $this->getSlice(), $firstSlice), $this->passable);
    }
    protected function getSlice()
    {
        return function ($stack, $pipe) {
            return function ($passable) use($stack, $pipe) {
                if ($pipe instanceof Closure) {
                    return call_user_func($pipe, $passable, $stack);
                } else {
                    list($name, $parameters) = $this->parsePipeString($pipe);
                    return call_user_func_array([$this->container->make($name), $this->method], array_merge([$passable, $stack], $parameters));
                }
            };
        };
    }
    protected function getInitialSlice(Closure $destination)
    {
        return function ($passable) use($destination) {
            return call_user_func($destination, $passable);
        };
    }
    protected function parsePipeString($pipe)
    {
        list($name, $parameters) = array_pad(explode(':', $pipe, 2), 2, []);
        if (is_string($parameters)) {
            $parameters = explode(',', $parameters);
        }
        return [$name, $parameters];
    }
}
}

namespace Royalcms\Component\Events {
use Exception;
use ReflectionClass;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Container\Container;
use Royalcms\Component\Contracts\Broadcasting\ShouldBroadcast;
use Royalcms\Component\Contracts\Broadcasting\ShouldBroadcastNow;
use Royalcms\Component\Contracts\Events\Dispatcher as DispatcherContract;
use Royalcms\Component\Contracts\Container\Container as ContainerContract;
class Dispatcher implements DispatcherContract
{
    protected $container;
    protected $listeners = [];
    protected $wildcards = [];
    protected $sorted = [];
    protected $firing = [];
    protected $queueResolver;
    public function __construct(ContainerContract $container = null)
    {
        $this->container = $container ?: new Container();
    }
    public function listen($events, $listener, $priority = 0)
    {
        foreach ((array) $events as $event) {
            if (Str::contains($event, '*')) {
                $this->setupWildcardListen($event, $listener);
            } else {
                $this->listeners[$event][$priority][] = $this->makeListener($listener);
                unset($this->sorted[$event]);
            }
        }
    }
    protected function setupWildcardListen($event, $listener)
    {
        $this->wildcards[$event][] = $this->makeListener($listener);
    }
    public function hasListeners($eventName)
    {
        return isset($this->listeners[$eventName]) || isset($this->wildcards[$eventName]);
    }
    public function push($event, $payload = [])
    {
        $this->listen($event . '_pushed', function () use($event, $payload) {
            $this->fire($event, $payload);
        });
    }
    public function subscribe($subscriber)
    {
        $subscriber = $this->resolveSubscriber($subscriber);
        $subscriber->subscribe($this);
    }
    protected function resolveSubscriber($subscriber)
    {
        if (is_string($subscriber)) {
            return $this->container->make($subscriber);
        }
        return $subscriber;
    }
    public function until($event, $payload = [])
    {
        return $this->fire($event, $payload, true);
    }
    public function flush($event)
    {
        $this->fire($event . '_pushed');
    }
    public function firing()
    {
        return last($this->firing);
    }
    public function fire($event, $payload = [], $halt = false)
    {
        return $this->dispatch($event, $payload, $halt);
    }
    public function dispatch($event, $payload = [], $halt = false)
    {
        if (is_object($event)) {
            list($payload, $event) = [[$event], get_class($event)];
        }
        $responses = [];
        if (!is_array($payload)) {
            $payload = [$payload];
        }
        $this->firing[] = $event;
        if (isset($payload[0]) && $payload[0] instanceof ShouldBroadcast) {
            $this->broadcastEvent($payload[0]);
        }
        foreach ($this->getListeners($event) as $listener) {
            $response = call_user_func_array($listener, $payload);
            if (!is_null($response) && $halt) {
                array_pop($this->firing);
                return $response;
            }
            if ($response === false) {
                break;
            }
            $responses[] = $response;
        }
        array_pop($this->firing);
        return $halt ? null : $responses;
    }
    protected function broadcastEvent($event)
    {
        if ($this->queueResolver) {
            $connection = $event instanceof ShouldBroadcastNow ? 'sync' : null;
            $queue = method_exists($event, 'onQueue') ? $event->onQueue() : null;
            $this->resolveQueue()->connection($connection)->pushOn($queue, 'Royalcms\\Component\\Broadcasting\\BroadcastEvent', ['event' => serialize(clone $event)]);
        }
    }
    public function getListeners($eventName)
    {
        $wildcards = $this->getWildcardListeners($eventName);
        if (!isset($this->sorted[$eventName])) {
            $this->sortListeners($eventName);
        }
        return array_merge($this->sorted[$eventName], $wildcards);
    }
    protected function getWildcardListeners($eventName)
    {
        $wildcards = [];
        foreach ($this->wildcards as $key => $listeners) {
            if (Str::is($key, $eventName)) {
                $wildcards = array_merge($wildcards, $listeners);
            }
        }
        return $wildcards;
    }
    protected function sortListeners($eventName)
    {
        $this->sorted[$eventName] = [];
        if (isset($this->listeners[$eventName])) {
            krsort($this->listeners[$eventName]);
            $this->sorted[$eventName] = call_user_func_array('array_merge', $this->listeners[$eventName]);
        }
    }
    public function makeListener($listener)
    {
        return is_string($listener) ? $this->createClassListener($listener) : $listener;
    }
    public function createClassListener($listener)
    {
        $container = $this->container;
        return function () use($listener, $container) {
            return call_user_func_array($this->createClassCallable($listener, $container), func_get_args());
        };
    }
    protected function createClassCallable($listener, $container)
    {
        list($class, $method) = $this->parseClassCallable($listener);
        if ($this->handlerShouldBeQueued($class)) {
            return $this->createQueuedHandlerCallable($class, $method);
        } else {
            return [$container->make($class), $method];
        }
    }
    protected function parseClassCallable($listener)
    {
        $segments = explode('@', $listener);
        return [$segments[0], count($segments) == 2 ? $segments[1] : 'handle'];
    }
    protected function handlerShouldBeQueued($class)
    {
        try {
            return (new ReflectionClass($class))->implementsInterface('Royalcms\\Component\\Contracts\\Queue\\ShouldQueue');
        } catch (Exception $e) {
            return false;
        }
    }
    protected function createQueuedHandlerCallable($class, $method)
    {
        return function () use($class, $method) {
            $arguments = $this->cloneArgumentsForQueueing(func_get_args());
            if (method_exists($class, 'queue')) {
                $this->callQueueMethodOnHandler($class, $method, $arguments);
            } else {
                $this->resolveQueue()->push('Royalcms\\Component\\Events\\CallQueuedHandler@call', ['class' => $class, 'method' => $method, 'data' => serialize($arguments)]);
            }
        };
    }
    protected function cloneArgumentsForQueueing(array $arguments)
    {
        return array_map(function ($a) {
            return is_object($a) ? clone $a : $a;
        }, $arguments);
    }
    protected function callQueueMethodOnHandler($class, $method, $arguments)
    {
        $handler = (new ReflectionClass($class))->newInstanceWithoutConstructor();
        $handler->queue($this->resolveQueue(), 'Royalcms\\Component\\Events\\CallQueuedHandler@call', ['class' => $class, 'method' => $method, 'data' => serialize($arguments)]);
    }
    public function forget($event)
    {
        if (Str::contains($event, '*')) {
            unset($this->wildcards[$event]);
        } else {
            unset($this->listeners[$event], $this->sorted[$event]);
        }
    }
    public function forgetPushed()
    {
        foreach ($this->listeners as $key => $value) {
            if (Str::endsWith($key, '_pushed')) {
                $this->forget($key);
            }
        }
    }
    protected function resolveQueue()
    {
        return call_user_func($this->queueResolver);
    }
    public function setQueueResolver(callable $resolver)
    {
        $this->queueResolver = $resolver;
        return $this;
    }
}
}

namespace Royalcms\Component\Events {
use Royalcms\Component\Support\ServiceProvider;
class EventServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->singleton('events', function ($royalcms) {
            return (new Dispatcher($royalcms))->setQueueResolver(function () use($royalcms) {
                return $royalcms->make('Royalcms\\Component\\Contracts\\Queue\\Factory');
            });
        });
    }
}
}

namespace Royalcms\Component\Session {
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Session\SessionInterface as BaseSessionInterface;
interface SessionInterface extends BaseSessionInterface
{
    public function getHandler();
    public function handlerNeedsRequest();
    public function setRequestOnHandler(Request $request);
}
}

namespace Royalcms\Component\Session {
interface StoreInterface
{
    public function start();
    public function isStarted();
    public function getId();
    public function setId($id);
    public function getName();
    public function setName($name);
    public function set($name, $value);
    public function get($name, $default = null);
    public function all();
    public function replace(array $attributes);
    public function has($name);
    public function remove($name);
    public function clear();
    public function getHandler();
}
}

namespace Royalcms\Component\Session\Middleware {
use Closure;
use Royalcms\Component\DateTime\Carbon;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Http\Request;
use Royalcms\Component\Session\SessionManager;
use Royalcms\Component\Session\SessionInterface;
use Symfony\Component\HttpFoundation\Cookie;
use Royalcms\Component\Session\CookieSessionHandler;
use Symfony\Component\HttpFoundation\Response;
class StartSession
{
    protected $manager;
    protected $sessionHandled = false;
    public function __construct(SessionManager $manager)
    {
        $this->manager = $manager;
    }
    public function handle($request, Closure $next)
    {
        $this->sessionHandled = true;
        if ($this->sessionConfigured()) {
            $session = $this->startSession($request);
            $request->setSession($session);
        }
        $response = $next($request);
        if ($this->sessionConfigured()) {
            $this->storeCurrentUrl($request, $session);
            $this->collectGarbage($session);
            $this->addCookieToResponse($response, $session);
        }
        return $response;
    }
    public function terminate($request, $response)
    {
        if ($this->sessionHandled && $this->sessionConfigured() && !$this->usingCookieSessions()) {
            $this->manager->driver()->save();
        }
    }
    protected function startSession(Request $request)
    {
        with($session = $this->getSession($request))->setRequestOnHandler($request);
        $session->start();
        return $session;
    }
    public function getSession(Request $request)
    {
        $session = $this->manager->driver();
        $session->setId($request->cookies->get($session->getName()));
        return $session;
    }
    protected function storeCurrentUrl(Request $request, $session)
    {
        if ($request->method() === 'GET' && $request->route() && !$request->ajax()) {
            $session->setPreviousUrl($request->fullUrl());
        }
    }
    protected function collectGarbage(SessionInterface $session)
    {
        $config = $this->manager->getSessionConfig();
        if ($this->configHitsLottery($config)) {
            $session->getHandler()->gc($this->getSessionLifetimeInSeconds());
        }
    }
    protected function configHitsLottery(array $config)
    {
        return mt_rand(1, $config['lottery'][1]) <= $config['lottery'][0];
    }
    protected function addCookieToResponse(Response $response, SessionInterface $session)
    {
        if ($this->usingCookieSessions()) {
            $this->manager->driver()->save();
        }
        if ($this->sessionIsPersistent($config = $this->manager->getSessionConfig())) {
            $response->headers->setCookie(new Cookie($session->getName(), $session->getId(), $this->getCookieExpirationDate(), $config['path'], $config['domain'], Arr::get($config, 'secure', false)));
        }
    }
    protected function getSessionLifetimeInSeconds()
    {
        return Arr::get($this->manager->getSessionConfig(), 'lifetime') * 60;
    }
    protected function getCookieExpirationDate()
    {
        $config = $this->manager->getSessionConfig();
        return $config['expire_on_close'] ? 0 : Carbon::now()->addMinutes($config['lifetime']);
    }
    protected function sessionConfigured()
    {
        return !is_null(Arr::get($this->manager->getSessionConfig(), 'driver'));
    }
    protected function sessionIsPersistent(array $config = null)
    {
        $config = $config ?: $this->manager->getSessionConfig();
        return !in_array($config['driver'], [null, 'array']);
    }
    protected function usingCookieSessions()
    {
        if (!$this->sessionConfigured()) {
            return false;
        }
        return $this->manager->driver()->getHandler() instanceof CookieSessionHandler;
    }
}
}

namespace Royalcms\Component\Session {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use SessionHandlerInterface;
use InvalidArgumentException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
class Store implements SessionInterface, StoreInterface
{
    protected $id;
    protected $name;
    protected $attributes = [];
    protected $bags = [];
    protected $metaBag;
    protected $bagData = [];
    protected $handler;
    protected $started = false;
    public function __construct($name, SessionHandlerInterface $handler, $id = null)
    {
        $this->setId($id);
        $this->name = $name;
        $this->handler = $handler;
        $this->metaBag = new MetadataBag();
    }
    public function start()
    {
        $this->loadSession();
        if (!$this->has('_token')) {
            $this->regenerateToken();
        }
        return $this->started = true;
    }
    protected function loadSession()
    {
        $this->attributes = array_merge($this->attributes, $this->readFromHandler());
        foreach (array_merge($this->bags, [$this->metaBag]) as $bag) {
            $this->initializeLocalBag($bag);
            $bag->initialize($this->bagData[$bag->getStorageKey()]);
        }
    }
    protected function readFromHandler()
    {
        $data = $this->handler->read($this->getId());
        if ($data) {
            $data = @unserialize($this->prepareForUnserialize($data));
            if ($data !== false && $data !== null && is_array($data)) {
                return $data;
            }
        }
        return [];
    }
    protected function prepareForUnserialize($data)
    {
        return $data;
    }
    protected function initializeLocalBag($bag)
    {
        $this->bagData[$bag->getStorageKey()] = $this->pull($bag->getStorageKey(), []);
    }
    public function getId()
    {
        return $this->id;
    }
    public function setId($id)
    {
        if (!$this->isValidId($id)) {
            $id = $this->generateSessionId();
        }
        $this->id = $id;
    }
    public function isValidId($id)
    {
        return is_string($id) && preg_match('/^[a-f0-9]{40}$/', $id);
    }
    protected function generateSessionId()
    {
        return sha1(uniqid('', true) . Str::random(25) . microtime(true));
    }
    public function getName()
    {
        return $this->name;
    }
    public function setName($name)
    {
        $this->name = $name;
    }
    public function invalidate($lifetime = null)
    {
        $this->clear();
        return $this->migrate(true, $lifetime);
    }
    public function migrate($destroy = false, $lifetime = null)
    {
        if ($destroy) {
            $this->handler->destroy($this->getId());
        }
        $this->setExists(false);
        $this->id = $this->generateSessionId();
        return true;
    }
    public function regenerate($destroy = false)
    {
        return $this->migrate($destroy);
    }
    public function save()
    {
        $this->addBagDataToSession();
        $this->ageFlashData();
        $this->handler->write($this->getId(), $this->prepareForStorage(serialize($this->attributes)));
        $this->started = false;
    }
    protected function prepareForStorage($data)
    {
        return $data;
    }
    protected function addBagDataToSession()
    {
        foreach (array_merge($this->bags, [$this->metaBag]) as $bag) {
            $key = $bag->getStorageKey();
            if (isset($this->bagData[$key])) {
                $this->put($key, $this->bagData[$key]);
            }
        }
    }
    public function ageFlashData()
    {
        $this->forget($this->get('flash.old', []));
        $this->put('flash.old', $this->get('flash.new', []));
        $this->put('flash.new', []);
    }
    public function has($name)
    {
        return !is_null($this->get($name));
    }
    public function get($name, $default = null)
    {
        return Arr::get($this->attributes, $name, $default);
    }
    public function pull($key, $default = null)
    {
        return Arr::pull($this->attributes, $key, $default);
    }
    public function hasOldInput($key = null)
    {
        $old = $this->getOldInput($key);
        return is_null($key) ? count($old) > 0 : !is_null($old);
    }
    public function getOldInput($key = null, $default = null)
    {
        $input = $this->get('_old_input', []);
        return Arr::get($input, $key, $default);
    }
    public function set($name, $value)
    {
        Arr::set($this->attributes, $name, $value);
    }
    public function put($key, $value = null)
    {
        if (!is_array($key)) {
            $key = [$key => $value];
        }
        foreach ($key as $arrayKey => $arrayValue) {
            $this->set($arrayKey, $arrayValue);
        }
    }
    public function push($key, $value)
    {
        $array = $this->get($key, []);
        $array[] = $value;
        $this->put($key, $array);
    }
    public function flash($key, $value)
    {
        $this->put($key, $value);
        $this->push('flash.new', $key);
        $this->removeFromOldFlashData([$key]);
    }
    public function now($key, $value)
    {
        $this->put($key, $value);
        $this->push('flash.old', $key);
    }
    public function flashInput(array $value)
    {
        $this->flash('_old_input', $value);
    }
    public function reflash()
    {
        $this->mergeNewFlashes($this->get('flash.old', []));
        $this->put('flash.old', []);
    }
    public function keep($keys = null)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        $this->mergeNewFlashes($keys);
        $this->removeFromOldFlashData($keys);
    }
    protected function mergeNewFlashes(array $keys)
    {
        $values = array_unique(array_merge($this->get('flash.new', []), $keys));
        $this->put('flash.new', $values);
    }
    protected function removeFromOldFlashData(array $keys)
    {
        $this->put('flash.old', array_diff($this->get('flash.old', []), $keys));
    }
    public function all()
    {
        return $this->attributes;
    }
    public function replace(array $attributes)
    {
        $this->put($attributes);
    }
    public function remove($name)
    {
        return Arr::pull($this->attributes, $name);
    }
    public function forget($keys)
    {
        Arr::forget($this->attributes, $keys);
    }
    public function clear()
    {
        $this->attributes = [];
        foreach ($this->bags as $bag) {
            $bag->clear();
        }
    }
    public function flush()
    {
        $this->clear();
    }
    public function isStarted()
    {
        return $this->started;
    }
    public function registerBag(SessionBagInterface $bag)
    {
        $this->bags[$bag->getStorageKey()] = $bag;
    }
    public function getBag($name)
    {
        return Arr::get($this->bags, $name, function () {
            throw new InvalidArgumentException('Bag not registered.');
        });
    }
    public function getMetadataBag()
    {
        return $this->metaBag;
    }
    public function getBagData($name)
    {
        return Arr::get($this->bagData, $name, []);
    }
    public function token()
    {
        return $this->get('_token');
    }
    public function getToken()
    {
        return $this->token();
    }
    public function regenerateToken()
    {
        $this->put('_token', Str::random(40));
    }
    public function previousUrl()
    {
        return $this->get('_previous.url');
    }
    public function setPreviousUrl($url)
    {
        $this->put('_previous.url', $url);
    }
    public function setExists($value)
    {
        if ($this->handler instanceof ExistenceAwareInterface) {
            $this->handler->setExists($value);
        }
    }
    public function getHandler()
    {
        return $this->handler;
    }
    public function handlerNeedsRequest()
    {
        return $this->handler instanceof CookieSessionHandler;
    }
    public function setRequestOnHandler(Request $request)
    {
        if ($this->handlerNeedsRequest()) {
            $this->handler->setRequest($request);
        }
    }
}
}

namespace Royalcms\Component\Session {
use Royalcms\Component\Support\Manager;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NullSessionHandler;
class SessionManager extends Manager
{
    protected function callCustomCreator($driver)
    {
        return $this->buildSession(parent::callCustomCreator($driver));
    }
    protected function createArrayDriver()
    {
        return $this->buildSession(new NullSessionHandler());
    }
    protected function createCookieDriver()
    {
        $lifetime = $this->royalcms['config']['session.lifetime'];
        return $this->buildSession(new CookieSessionHandler($this->royalcms['cookie'], $lifetime));
    }
    protected function createFileDriver()
    {
        return $this->createNativeDriver();
    }
    protected function createNativeDriver()
    {
        $path = $this->royalcms['config']['session.files'];
        $lifetime = $this->royalcms['config']['session.lifetime'];
        return $this->buildSession(new FileSessionHandler($this->royalcms['files'], $path, $lifetime));
    }
    protected function createDatabaseDriver()
    {
        $connection = $this->getDatabaseConnection();
        $table = $this->royalcms['config']['session.table'];
        $lifetime = $this->royalcms['config']['session.lifetime'];
        return $this->buildSession(new DatabaseSessionHandler($connection, $table, $lifetime));
    }
    protected function getDatabaseConnection()
    {
        $connection = $this->royalcms['config']['session.connection'];
        return $this->royalcms['db']->connection($connection);
    }
    protected function createApcDriver()
    {
        return $this->createCacheBased('apc');
    }
    protected function createMemcachedDriver()
    {
        return $this->createCacheBased('memcached');
    }
    protected function createWincacheDriver()
    {
        return $this->createCacheBased('wincache');
    }
    protected function createRedisDriver()
    {
        $handler = $this->createCacheHandler('redis');
        $handler->getCache()->getStore()->setConnection($this->royalcms['config']['session.connection']);
        return $this->buildSession($handler);
    }
    protected function createCacheBased($driver)
    {
        return $this->buildSession($this->createCacheHandler($driver));
    }
    protected function createCacheHandler($driver)
    {
        $minutes = $this->royalcms['config']['session.lifetime'];
        return new CacheBasedSessionHandler(clone $this->royalcms['cache']->driver($driver), $minutes);
    }
    protected function buildSession($handler)
    {
        if ($this->royalcms['config']['session.encrypt']) {
            return new EncryptedStore($this->royalcms['config']['session.cookie'], $handler, $this->royalcms['encrypter']);
        } else {
            return new Store($this->royalcms['config']['session.cookie'], $handler);
        }
    }
    public function getSessionConfig()
    {
        return $this->royalcms['config']['session'];
    }
    public function getDefaultDriver()
    {
        return $this->royalcms['config']['session.driver'];
    }
    public function setDefaultDriver($name)
    {
        $this->royalcms['config']['session.driver'] = $name;
    }
}
}

namespace Royalcms\Component\Session {
use Royalcms\Component\Support\ServiceProvider;
class SessionServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->setupDefaultDriver();
        $this->registerSessionManager();
        $this->registerSessionDriver();
        $this->royalcms->singleton('Royalcms\\Component\\Session\\Middleware\\StartSession');
    }
    protected function setupDefaultDriver()
    {
        if ($this->royalcms->runningInConsole()) {
            $this->royalcms['config']['session.driver'] = 'array';
        }
    }
    protected function registerSessionManager()
    {
        $this->royalcms->singleton('session', function ($royalcms) {
            return new SessionManager($royalcms);
        });
    }
    protected function registerSessionDriver()
    {
        $this->royalcms->singleton('session.store', function ($royalcms) {
            $manager = $royalcms['session'];
            return $manager->driver();
        });
    }
}
}

namespace Royalcms\Component\Cookie {
use Royalcms\Component\Support\Arr;
use Symfony\Component\HttpFoundation\Cookie;
use Royalcms\Component\Contracts\Cookie\QueueingFactory as JarContract;
class CookieJar implements JarContract
{
    protected $path = '/';
    protected $domain = null;
    protected $secure = false;
    protected $queued = [];
    public function make($name, $value, $minutes = 0, $path = null, $domain = null, $secure = false, $httpOnly = true)
    {
        list($path, $domain, $secure) = $this->getPathAndDomain($path, $domain, $secure);
        $time = $minutes == 0 ? 0 : time() + $minutes * 60;
        $name = config('cookie.prefix') . $name;
        return new Cookie($name, $value, $time, $path, $domain, $secure, $httpOnly);
    }
    public function forever($name, $value, $path = null, $domain = null, $secure = false, $httpOnly = true)
    {
        return $this->make($name, $value, 2628000, $path, $domain, $secure, $httpOnly);
    }
    public function forget($name, $path = null, $domain = null)
    {
        return $this->make($name, null, -2628000, $path, $domain);
    }
    public function hasQueued($key)
    {
        return !is_null($this->queued($key));
    }
    public function queued($key, $default = null)
    {
        return Arr::get($this->queued, $key, $default);
    }
    public function queue()
    {
        if (head(func_get_args()) instanceof Cookie) {
            $cookie = head(func_get_args());
        } else {
            $cookie = call_user_func_array([$this, 'make'], func_get_args());
        }
        $this->queued[$cookie->getName()] = $cookie;
    }
    public function unqueue($name)
    {
        $name = config('cookie.prefix') . $name;
        unset($this->queued[$name]);
    }
    protected function getPathAndDomain($path, $domain, $secure = false)
    {
        return [$path ?: $this->path, $domain ?: $this->domain, $secure ?: $this->secure];
    }
    public function setDefaultPathAndDomain($path, $domain, $secure = false)
    {
        list($this->path, $this->domain, $this->secure) = [$path, $domain, $secure];
        return $this;
    }
    public function getQueuedCookies()
    {
        return $this->queued;
    }
}
}

namespace Royalcms\Component\Cookie\Middleware {
use Closure;
use Symfony\Component\HttpFoundation\Cookie;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Royalcms\Component\Contracts\Encryption\DecryptException;
use Royalcms\Component\Contracts\Encryption\Encrypter as EncrypterContract;
class EncryptCookies
{
    protected $encrypter;
    protected $except = [];
    public function __construct(EncrypterContract $encrypter)
    {
        $this->encrypter = $encrypter;
    }
    public function disableFor($cookieName)
    {
        $this->except = array_merge($this->except, (array) $cookieName);
    }
    public function handle($request, Closure $next)
    {
        return $this->encrypt($next($this->decrypt($request)));
    }
    protected function decrypt(Request $request)
    {
        foreach ($request->cookies as $key => $c) {
            if ($this->isDisabled($key)) {
                continue;
            }
            try {
                $request->cookies->set($key, $this->decryptCookie($c));
            } catch (DecryptException $e) {
                $request->cookies->set($key, null);
            }
        }
        return $request;
    }
    protected function decryptCookie($cookie)
    {
        return is_array($cookie) ? $this->decryptArray($cookie) : $this->encrypter->decrypt($cookie);
    }
    protected function decryptArray(array $cookie)
    {
        $decrypted = [];
        foreach ($cookie as $key => $value) {
            if (is_string($value)) {
                $decrypted[$key] = $this->encrypter->decrypt($value);
            }
        }
        return $decrypted;
    }
    protected function encrypt(Response $response)
    {
        foreach ($response->headers->getCookies() as $cookie) {
            if ($this->isDisabled($cookie->getName())) {
                continue;
            }
            $response->headers->setCookie($this->duplicate($cookie, $this->encrypter->encrypt($cookie->getValue())));
        }
        return $response;
    }
    protected function duplicate(Cookie $c, $value)
    {
        return new Cookie($c->getName(), $value, $c->getExpiresTime(), $c->getPath(), $c->getDomain(), $c->isSecure(), $c->isHttpOnly());
    }
    public function isDisabled($name)
    {
        return in_array($name, $this->except);
    }
}
}

namespace Royalcms\Component\Cookie\Middleware {
use Closure;
use Royalcms\Component\Contracts\Cookie\QueueingFactory as CookieJar;
class AddQueuedCookiesToResponse
{
    protected $cookies;
    public function __construct(CookieJar $cookies)
    {
        $this->cookies = $cookies;
    }
    public function handle($request, Closure $next)
    {
        $response = $next($request);
        foreach ($this->cookies->getQueuedCookies() as $cookie) {
            $response->headers->setCookie($cookie);
        }
        return $response;
    }
}
}

namespace Royalcms\Component\Cookie {
use Royalcms\Component\Support\ServiceProvider;
class CookieServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->singleton('cookie', function ($royalcms) {
            $config = $royalcms['config']['cookie'];
            return with(new CookieJar())->setDefaultPathAndDomain($config['path'], $config['domain'], $config['secure']);
        });
    }
}
}

namespace Royalcms\Component\Cache {
use Closure;
use Royalcms\Component\Support\Arr;
use InvalidArgumentException;
use Royalcms\Component\Contracts\Cache\Store;
use Royalcms\Component\Contracts\Cache\Factory as FactoryContract;
class CacheManager implements FactoryContract
{
    protected $royalcms;
    protected $stores = [];
    protected $customCreators = [];
    public function __construct($royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public function store($name = null)
    {
        $name = $name ?: $this->getDefaultDriver();
        return $this->stores[$name] = $this->get($name);
    }
    public function driver($driver = null)
    {
        return $this->store($driver);
    }
    protected function get($name)
    {
        return isset($this->stores[$name]) ? $this->stores[$name] : $this->resolve($name);
    }
    protected function resolve($name)
    {
        $config = $this->getConfig($name);
        if (is_null($config)) {
            throw new InvalidArgumentException("Cache store [{$name}] is not defined.");
        }
        if (isset($this->customCreators[$config['driver']])) {
            return $this->callCustomCreator($config);
        } else {
            $driverMethod = 'create' . ucfirst($config['driver']) . 'Driver';
            if (method_exists($this, $driverMethod)) {
                return $this->{$driverMethod}($config);
            } else {
                throw new InvalidArgumentException("Driver [{$config['driver']}] not supported.");
            }
        }
    }
    protected function callCustomCreator(array $config)
    {
        return $this->customCreators[$config['driver']]($this->royalcms, $config);
    }
    protected function createApcDriver(array $config)
    {
        $prefix = $this->getPrefix($config);
        return $this->repository(new ApcStore(new ApcWrapper(), $prefix));
    }
    protected function createArrayDriver()
    {
        return $this->repository(new ArrayStore());
    }
    protected function createFileDriver(array $config)
    {
        return $this->repository(new FileStore($this->royalcms['files'], $config['path']));
    }
    protected function createMemcachedDriver(array $config)
    {
        $prefix = $this->getPrefix($config);
        $memcached = $this->royalcms['memcached.connector']->connect($config['servers']);
        return $this->repository(new MemcachedStore($memcached, $prefix));
    }
    protected function createNullDriver()
    {
        return $this->repository(new NullStore());
    }
    protected function createWincacheDriver(array $config)
    {
        return $this->repository(new WinCacheStore($this->getPrefix($config)));
    }
    protected function createXcacheDriver(array $config)
    {
        return $this->repository(new XCacheStore($this->getPrefix($config)));
    }
    protected function createRedisDriver(array $config)
    {
        $redis = $this->royalcms['redis'];
        $connection = Arr::get($config, 'connection', 'default');
        return $this->repository(new RedisStore($redis, $this->getPrefix($config), $connection));
    }
    protected function createDatabaseDriver(array $config)
    {
        $connection = $this->royalcms['db']->connection(Arr::get($config, 'connection'));
        return $this->repository(new DatabaseStore($connection, $this->royalcms['encrypter'], $config['table'], $this->getPrefix($config)));
    }
    public function repository(Store $store)
    {
        $repository = new Repository($store);
        if ($this->royalcms->bound('Royalcms\\Component\\Contracts\\Events\\Dispatcher')) {
            $repository->setEventDispatcher($this->royalcms['Royalcms\\Component\\Contracts\\Events\\Dispatcher']);
        }
        return $repository;
    }
    protected function getPrefix(array $config)
    {
        return Arr::get($config, 'prefix') ?: $this->royalcms['config']['cache.prefix'];
    }
    public function setPrefix($name)
    {
        $this->royalcms['config']['cache.prefix'] = $name;
    }
    protected function getConfig($name)
    {
        return $this->royalcms['config']["cache.stores.{$name}"];
    }
    public function getDefaultDriver()
    {
        return $this->royalcms['config']['cache.default'];
    }
    public function setDefaultDriver($name)
    {
        $this->royalcms['config']['cache.default'] = $name;
    }
    public function extend($driver, Closure $callback)
    {
        $this->customCreators[$driver] = $callback;
        return $this;
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->store(), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Cache {
use Exception;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Filesystem\Filesystem;
use Royalcms\Component\Contracts\Cache\Store;
class FileStore implements Store
{
    protected $files;
    protected $directory;
    public function __construct(Filesystem $files, $directory)
    {
        $this->files = $files;
        $this->directory = $directory;
    }
    public function get($key)
    {
        return Arr::get($this->getPayload($key), 'data');
    }
    protected function getPayload($key)
    {
        $path = $this->path($key);
        try {
            $expire = substr($contents = $this->files->get($path), 0, 10);
        } catch (Exception $e) {
            return ['data' => null, 'time' => null];
        }
        if (time() >= $expire) {
            $this->forget($key);
            return ['data' => null, 'time' => null];
        }
        $data = unserialize(substr($contents, 10));
        $time = ceil(($expire - time()) / 60);
        return compact('data', 'time');
    }
    public function put($key, $value, $minutes)
    {
        $value = $this->expiration($minutes) . serialize($value);
        $this->createCacheDirectory($path = $this->path($key));
        $this->files->put($path, $value);
    }
    protected function createCacheDirectory($path)
    {
        if (!$this->files->exists(dirname($path))) {
            $this->files->makeDirectory(dirname($path), 0777, true, true);
        }
    }
    public function increment($key, $value = 1)
    {
        $raw = $this->getPayload($key);
        $int = (int) $raw['data'] + $value;
        $this->put($key, $int, (int) $raw['time']);
        return $int;
    }
    public function decrement($key, $value = 1)
    {
        return $this->increment($key, $value * -1);
    }
    public function forever($key, $value)
    {
        $this->put($key, $value, 0);
    }
    public function forget($key)
    {
        $file = $this->path($key);
        if ($this->files->exists($file)) {
            return $this->files->delete($file);
        }
        return false;
    }
    public function flush()
    {
        if ($this->files->isDirectory($this->directory)) {
            foreach ($this->files->directories($this->directory) as $directory) {
                $this->files->deleteDirectory($directory);
            }
        }
    }
    protected function path($key)
    {
        $parts = array_slice(str_split($hash = md5($key), 2), 0, 2);
        return $this->directory . '/' . implode('/', $parts) . '/' . $hash;
    }
    protected function expiration($minutes)
    {
        $time = time() + $minutes * 60;
        if ($minutes === 0 || $time > 9999999999) {
            return 9999999999;
        }
        return $time;
    }
    public function getFilesystem()
    {
        return $this->files;
    }
    public function getDirectory()
    {
        return $this->directory;
    }
    public function getPrefix()
    {
        return '';
    }
}
}

namespace Royalcms\Component\Cache {
use Closure;
use DateTime;
use ArrayAccess;
use Royalcms\Component\DateTime\Carbon;
use BadMethodCallException;
use Royalcms\Component\Contracts\Cache\Store;
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Royalcms\Component\Contracts\Cache\Repository as CacheContract;
class Repository implements CacheContract, ArrayAccess
{
    use Macroable {
        __call as macroCall;
    }
    protected $store;
    protected $events;
    protected $default = 60;
    public function __construct(Store $store)
    {
        $this->store = $store;
    }
    public function setEventDispatcher(Dispatcher $events)
    {
        $this->events = $events;
    }
    protected function fireCacheEvent($event, $payload)
    {
        if (isset($this->events)) {
            $this->events->fire('cache.' . $event, $payload);
        }
    }
    public function has($key)
    {
        return !is_null($this->get($key));
    }
    public function get($key, $default = null)
    {
        $value = $this->store->get($this->itemKey($key));
        if (is_null($value)) {
            $this->fireCacheEvent('missed', [$key]);
            $value = value($default);
        } else {
            $this->fireCacheEvent('hit', [$key, $value]);
        }
        return $value;
    }
    public function pull($key, $default = null)
    {
        $value = $this->get($key, $default);
        $this->forget($key);
        return $value;
    }
    public function put($key, $value, $minutes)
    {
        $minutes = $this->getMinutes($minutes);
        if (!is_null($minutes)) {
            $this->store->put($this->itemKey($key), $value, $minutes);
            $this->fireCacheEvent('write', [$key, $value, $minutes]);
        }
    }
    public function add($key, $value, $minutes)
    {
        $minutes = $this->getMinutes($minutes);
        if (is_null($minutes)) {
            return false;
        }
        if (method_exists($this->store, 'add')) {
            return $this->store->add($this->itemKey($key), $value, $minutes);
        }
        if (is_null($this->get($key))) {
            $this->put($key, $value, $minutes);
            return true;
        }
        return false;
    }
    public function forever($key, $value)
    {
        $this->store->forever($this->itemKey($key), $value);
        $this->fireCacheEvent('write', [$key, $value, 0]);
    }
    public function remember($key, $minutes, Closure $callback)
    {
        if (!is_null($value = $this->get($key))) {
            return $value;
        }
        $this->put($key, $value = $callback(), $minutes);
        return $value;
    }
    public function sear($key, Closure $callback)
    {
        return $this->rememberForever($key, $callback);
    }
    public function rememberForever($key, Closure $callback)
    {
        if (!is_null($value = $this->get($key))) {
            return $value;
        }
        $this->forever($key, $value = $callback());
        return $value;
    }
    public function forget($key)
    {
        $success = $this->store->forget($this->itemKey($key));
        $this->fireCacheEvent('delete', [$key]);
        return $success;
    }
    public function section($name)
    {
        return $this->tags($name);
    }
    public function tags($names)
    {
        if (method_exists($this->store, 'tags')) {
            $taggedCache = $this->store->tags($names);
            if (!is_null($this->events)) {
                $taggedCache->setEventDispatcher($this->events);
            }
            $taggedCache->setDefaultCacheTime($this->default);
            return $taggedCache;
        }
        throw new BadMethodCallException('This cache store does not support tagging.');
    }
    protected function itemKey($key)
    {
        return $key;
    }
    public function getDefaultCacheTime()
    {
        return $this->default;
    }
    public function setDefaultCacheTime($minutes)
    {
        $this->default = $minutes;
    }
    public function getStore()
    {
        return $this->store;
    }
    public function offsetExists($key)
    {
        return $this->has($key);
    }
    public function offsetGet($key)
    {
        return $this->get($key);
    }
    public function offsetSet($key, $value)
    {
        $this->put($key, $value, $this->default);
    }
    public function offsetUnset($key)
    {
        $this->forget($key);
    }
    protected function getMinutes($duration)
    {
        if ($duration instanceof DateTime) {
            $fromNow = Carbon::now()->diffInMinutes(Carbon::instance($duration), false);
            return $fromNow > 0 ? $fromNow : null;
        }
        return is_string($duration) ? (int) $duration : $duration;
    }
    public function __call($method, $parameters)
    {
        if (static::hasMacro($method)) {
            return $this->macroCall($method, $parameters);
        }
        return call_user_func_array([$this->store, $method], $parameters);
    }
    public function __clone()
    {
        $this->store = clone $this->store;
    }
}
}

namespace Royalcms\Component\Encryption {
use Royalcms\Component\Support\Str;
use Royalcms\Component\Contracts\Encryption\DecryptException;
abstract class BaseEncrypter
{
    protected $key;
    protected function hash($iv, $value)
    {
        return hash_hmac('sha256', $iv . $value, $this->key);
    }
    protected function getJsonPayload($payload)
    {
        $payload = json_decode(base64_decode($payload), true);
        if (!$payload || $this->invalidPayload($payload)) {
            throw new DecryptException('The payload is invalid.');
        }
        if (!$this->validMac($payload)) {
            throw new DecryptException('The MAC is invalid.');
        }
        return $payload;
    }
    protected function invalidPayload($data)
    {
        return !is_array($data) || !isset($data['iv']) || !isset($data['value']) || !isset($data['mac']);
    }
    protected function validMac(array $payload)
    {
        $bytes = Str::randomBytes(16);
        $calcMac = hash_hmac('sha256', $this->hash($payload['iv'], $payload['value']), $bytes, true);
        return Str::equals(hash_hmac('sha256', $payload['mac'], $bytes, true), $calcMac);
    }
}
}

namespace Royalcms\Component\Encryption {
use RuntimeException;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Contracts\Encryption\DecryptException;
use Royalcms\Component\Contracts\Encryption\EncryptException;
use Royalcms\Component\Contracts\Encryption\Encrypter as EncrypterContract;
class Encrypter extends BaseEncrypter implements EncrypterContract
{
    protected $cipher;
    public function __construct($key, $cipher = 'AES-128-CBC')
    {
        $key = (string) $key;
        if (static::supported($key, $cipher)) {
            $this->key = $key;
            $this->cipher = $cipher;
        } else {
            throw new RuntimeException('The only supported ciphers are AES-128-CBC and AES-256-CBC with the correct key lengths.');
        }
    }
    public static function supported($key, $cipher)
    {
        $length = mb_strlen($key, '8bit');
        return $cipher === 'AES-128-CBC' && $length === 16 || $cipher === 'AES-256-CBC' && $length === 32;
    }
    public function encrypt($value)
    {
        $iv = Str::randomBytes($this->getIvSize());
        $value = \openssl_encrypt(serialize($value), $this->cipher, $this->key, 0, $iv);
        if ($value === false) {
            throw new EncryptException('Could not encrypt the data.');
        }
        $mac = $this->hash($iv = base64_encode($iv), $value);
        $json = json_encode(compact('iv', 'value', 'mac'));
        if (!is_string($json)) {
            throw new EncryptException('Could not encrypt the data.');
        }
        return base64_encode($json);
    }
    public function decrypt($payload)
    {
        $payload = $this->getJsonPayload($payload);
        $iv = base64_decode($payload['iv']);
        $decrypted = \openssl_decrypt($payload['value'], $this->cipher, $this->key, 0, $iv);
        if ($decrypted === false) {
            throw new DecryptException('Could not decrypt the data.');
        }
        return unserialize($decrypted);
    }
    protected function getIvSize()
    {
        return 16;
    }
}
}

namespace Royalcms\Component\Encryption {
use RuntimeException;
use Royalcms\Component\Support\ServiceProvider;
class EncryptionServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->singleton('encrypter', function ($royalcms) {
            $config = $royalcms->make('config')->get('system');
            $key = $config['auth_key'];
            $cipher = $config['cipher'];
            if (Encrypter::supported($key, $cipher)) {
                return new Encrypter($key, $cipher);
            } elseif (McryptEncrypter::supported($key, $cipher)) {
                return new McryptEncrypter($key, $cipher);
            } else {
                throw new RuntimeException('No supported encrypter found. The cipher and / or key length are invalid.');
            }
        });
    }
}
}

namespace Royalcms\Component\Log {
use Closure;
use RuntimeException;
use InvalidArgumentException;
use Monolog\Handler\SyslogHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Logger as MonologLogger;
use Monolog\Formatter\LineFormatter;
use Monolog\Handler\ErrorLogHandler;
use Monolog\Handler\RotatingFileHandler;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Royalcms\Component\Contracts\Support\Arrayable;
use Psr\Log\LoggerInterface as PsrLoggerInterface;
use Royalcms\Component\Contracts\Logging\Log as LogContract;
class Writer implements LogContract, PsrLoggerInterface
{
    protected $monolog;
    protected $dispatcher;
    protected $levels = ['debug' => MonologLogger::DEBUG, 'info' => MonologLogger::INFO, 'notice' => MonologLogger::NOTICE, 'warning' => MonologLogger::WARNING, 'error' => MonologLogger::ERROR, 'critical' => MonologLogger::CRITICAL, 'alert' => MonologLogger::ALERT, 'emergency' => MonologLogger::EMERGENCY];
    public function __construct(MonologLogger $monolog, Dispatcher $dispatcher = null)
    {
        $this->monolog = $monolog;
        if (isset($dispatcher)) {
            $this->dispatcher = $dispatcher;
        }
    }
    public function emergency($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function alert($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function critical($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function error($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function warning($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function notice($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function info($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function debug($message, array $context = [])
    {
        return $this->writeLog(__FUNCTION__, $message, $context);
    }
    public function log($level, $message, array $context = [])
    {
        return $this->writeLog($level, $message, $context);
    }
    public function write($level, $message, array $context = [])
    {
        return $this->writeLog($level, $message, $context);
    }
    protected function writeLog($level, $message, $context)
    {
        $this->fireLogEvent($level, $message = $this->formatMessage($message), $context);
        $this->monolog->{$level}($message, $context);
    }
    public function useFiles($path, $level = 'debug')
    {
        $this->monolog->pushHandler($handler = new StreamHandler($path, $this->parseLevel($level)));
        $handler->setFormatter($this->getDefaultFormatter());
    }
    public function useDailyFiles($path, $days = 0, $level = 'debug')
    {
        $this->monolog->pushHandler($handler = new RotatingFileHandler($path, $days, $this->parseLevel($level)));
        $handler->setFormatter($this->getDefaultFormatter());
    }
    public function useSyslog($name = 'royalcms', $level = 'debug')
    {
        return $this->monolog->pushHandler(new SyslogHandler($name, LOG_USER, $level));
    }
    public function useErrorLog($level = 'debug', $messageType = ErrorLogHandler::OPERATING_SYSTEM)
    {
        $this->monolog->pushHandler($handler = new ErrorLogHandler($messageType, $this->parseLevel($level)));
        $handler->setFormatter($this->getDefaultFormatter());
    }
    public function listen(Closure $callback)
    {
        if (!isset($this->dispatcher)) {
            throw new RuntimeException('Events dispatcher has not been set.');
        }
        $this->dispatcher->listen('royalcms.log', $callback);
    }
    protected function fireLogEvent($level, $message, array $context = [])
    {
        if (isset($this->dispatcher)) {
            $this->dispatcher->fire('royalcms.log', compact('level', 'message', 'context'));
        }
    }
    protected function formatMessage($message)
    {
        if (is_array($message)) {
            return var_export($message, true);
        } elseif ($message instanceof Jsonable) {
            return $message->toJson();
        } elseif ($message instanceof Arrayable) {
            return var_export($message->toArray(), true);
        }
        return $message;
    }
    protected function parseLevel($level)
    {
        if (isset($this->levels[$level])) {
            return $this->levels[$level];
        }
        throw new InvalidArgumentException('Invalid log level.');
    }
    public function getMonolog()
    {
        return $this->monolog;
    }
    protected function getDefaultFormatter()
    {
        return new LineFormatter(null, null, true, true);
    }
    public function getEventDispatcher()
    {
        return $this->dispatcher;
    }
    public function setEventDispatcher(Dispatcher $dispatcher)
    {
        $this->dispatcher = $dispatcher;
    }
    protected function callMonolog($method, $parameters)
    {
        if (is_array($parameters[0])) {
            $parameters[0] = json_encode($parameters[0]);
        }
        return call_user_func_array(array($this->monolog, $method), $parameters);
    }
    public function __call($method, $parameters)
    {
        if (in_array($method, $this->levels)) {
            call_user_func_array(array($this, 'fireLogEvent'), array_merge(array($method), $parameters));
            $method = 'add' . ucfirst($method);
            return $this->callMonolog($method, $parameters);
        }
        throw new \BadMethodCallException("Method [{$method}] does not exist.");
    }
}
}

namespace Royalcms\Component\Log {
use Royalcms\Component\Support\ServiceProvider;
class LogServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->bind('log.store', function ($royalcms) {
            return new FileStore($royalcms['files'], storage_path() . '/logs/');
        });
        if (isset($this->royalcms['log.setup'])) {
            call_user_func($this->royalcms['log.setup'], $this->royalcms['log']);
        }
    }
    public function provides()
    {
        return array('log.store');
    }
}
}

namespace Royalcms\Component\Log {
use Royalcms\Component\Filesystem\Filesystem;
use Monolog\Logger as MonologLogger;
class FileStore
{
    protected $files;
    protected $directory;
    public function __construct(Filesystem $files, $directory)
    {
        $this->files = $files;
        $this->directory = $directory;
        if (!$this->files->isDirectory($this->directory)) {
            $this->createCacheDirectory($this->directory);
        }
    }
    protected function createCacheDirectory($path)
    {
        $bool = $this->files->makeDirectory($path, 0755, true, true);
        if ($bool === false) {
            $path = str_replace(SITE_ROOT, '/', storage_path());
            rc_die(sprintf(__("%s777"), $path));
        }
    }
    private $loggers = array();
    public function getLogger($type = 'royalcms', $day = 30)
    {
        if (empty($this->loggers[$type])) {
            $this->loggers[$type] = new Writer(new MonologLogger($type));
            $this->loggers[$type]->useDailyFiles($this->directory . $type . '.log', $day);
        }
        $log = $this->loggers[$type];
        return $log;
    }
}
}

namespace Royalcms\Component\View\Middleware {
use Closure;
use Royalcms\Component\Support\ViewErrorBag;
use Royalcms\Component\Contracts\View\Factory as ViewFactory;
class ShareErrorsFromSession
{
    protected $view;
    public function __construct(ViewFactory $view)
    {
        $this->view = $view;
    }
    public function handle($request, Closure $next)
    {
        $this->view->share('errors', $request->session()->get('errors') ?: new ViewErrorBag());
        return $next($request);
    }
}
}

namespace Royalcms\Component\View\Engines {
use Closure;
use InvalidArgumentException;
class EngineResolver
{
    protected $resolvers = [];
    protected $resolved = [];
    public function register($engine, Closure $resolver)
    {
        unset($this->resolved[$engine]);
        $this->resolvers[$engine] = $resolver;
    }
    public function resolve($engine)
    {
        if (isset($this->resolved[$engine])) {
            return $this->resolved[$engine];
        }
        if (isset($this->resolvers[$engine])) {
            return $this->resolved[$engine] = call_user_func($this->resolvers[$engine]);
        }
        throw new InvalidArgumentException("Engine [{$engine}] not found.");
    }
}
}

namespace Royalcms\Component\View\Engines {
abstract class Engine
{
    protected $lastRendered;
    public function getLastRendered()
    {
        return $this->lastRendered;
    }
}
}

namespace Royalcms\Component\View\Engines {
use Exception;
use Throwable;
use Royalcms\Component\Contracts\View\Engine as EngineContract;
use Symfony\Component\Debug\Exception\FatalThrowableError;
class PhpEngine implements EngineContract
{
    public function get($path, array $data = [])
    {
        return $this->evaluatePath($path, $data);
    }
    protected function evaluatePath($__path, $__data)
    {
        $obLevel = ob_get_level();
        ob_start();
        extract($__data, EXTR_SKIP);
        try {
            include $__path;
        } catch (Exception $e) {
            $this->handleViewException($e, $obLevel);
        } catch (Throwable $e) {
            $this->handleViewException(new FatalThrowableError($e), $obLevel);
        }
        return ltrim(ob_get_clean());
    }
    protected function handleViewException(Exception $e, $obLevel)
    {
        while (ob_get_level() > $obLevel) {
            ob_end_clean();
        }
        throw $e;
    }
}
}

namespace Royalcms\Component\View\Engines {
use Royalcms\Component\Contracts\View\Engine as EngineContract;
class FileEngine implements EngineContract
{
    public function get($path, array $data = [])
    {
        return file_get_contents($path);
    }
}
}

namespace Royalcms\Component\View\Engines {
use Exception;
use ErrorException;
use Royalcms\Component\View\Compilers\CompilerInterface;
class CompilerEngine extends PhpEngine
{
    protected $compiler;
    protected $lastCompiled = [];
    public function __construct(CompilerInterface $compiler)
    {
        $this->compiler = $compiler;
    }
    public function get($path, array $data = [])
    {
        $this->lastCompiled[] = $path;
        if ($this->compiler->isExpired($path)) {
            $this->compiler->compile($path);
        }
        $compiled = $this->compiler->getCompiledPath($path);
        $results = $this->evaluatePath($compiled, $data);
        array_pop($this->lastCompiled);
        return $results;
    }
    protected function handleViewException(Exception $e, $obLevel)
    {
        $e = new ErrorException($this->getMessage($e), 0, 1, $e->getFile(), $e->getLine(), $e);
        parent::handleViewException($e, $obLevel);
    }
    protected function getMessage(Exception $e)
    {
        return $e->getMessage() . ' (View: ' . realpath(last($this->lastCompiled)) . ')';
    }
    public function getCompiler()
    {
        return $this->compiler;
    }
}
}

namespace Royalcms\Component\View\Concerns {
use Royalcms\Component\Support\HtmlString;
trait ManagesComponents
{
    protected $componentStack = [];
    protected $componentData = [];
    protected $slots = [];
    protected $slotStack = [];
    public function startComponent($name, array $data = [])
    {
        if (ob_start()) {
            $this->componentStack[] = $name;
            $this->componentData[$this->currentComponent()] = $data;
            $this->slots[$this->currentComponent()] = [];
        }
    }
    public function renderComponent()
    {
        $name = array_pop($this->componentStack);
        return $this->make($name, $this->componentData($name))->render();
    }
    protected function componentData($name)
    {
        return array_merge($this->componentData[count($this->componentStack)], ['slot' => new HtmlString(trim(ob_get_clean()))], $this->slots[count($this->componentStack)]);
    }
    public function slot($name, $content = null)
    {
        if (count(func_get_args()) == 2) {
            $this->slots[$this->currentComponent()][$name] = $content;
        } else {
            if (ob_start()) {
                $this->slots[$this->currentComponent()][$name] = '';
                $this->slotStack[$this->currentComponent()][] = $name;
            }
        }
    }
    public function endSlot()
    {
        last($this->componentStack);
        $currentSlot = array_pop($this->slotStack[$this->currentComponent()]);
        $this->slots[$this->currentComponent()][$currentSlot] = new HtmlString(trim(ob_get_clean()));
    }
    protected function currentComponent()
    {
        return count($this->componentStack) - 1;
    }
}
}

namespace Royalcms\Component\View\Concerns {
use Closure;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Contracts\View\View as ViewContract;
trait ManagesEvents
{
    public function creator($views, $callback)
    {
        $creators = [];
        foreach ((array) $views as $view) {
            $creators[] = $this->addViewEvent($view, $callback, 'creating: ');
        }
        return $creators;
    }
    public function composers(array $composers)
    {
        $registered = [];
        foreach ($composers as $callback => $views) {
            $registered = array_merge($registered, $this->composer($views, $callback));
        }
        return $registered;
    }
    public function composer($views, $callback, $priority = null)
    {
        $composers = [];
        foreach ((array) $views as $view) {
            $composers[] = $this->addViewEvent($view, $callback, 'composing: ');
        }
        return $composers;
    }
    protected function addViewEvent($view, $callback, $prefix = 'composing: ')
    {
        $view = $this->normalizeName($view);
        if ($callback instanceof Closure) {
            $this->addEventListener($prefix . $view, $callback);
            return $callback;
        } elseif (is_string($callback)) {
            return $this->addClassEvent($view, $callback, $prefix);
        }
    }
    protected function addClassEvent($view, $class, $prefix)
    {
        $name = $prefix . $view;
        $callback = $this->buildClassEventCallback($class, $prefix);
        $this->addEventListener($name, $callback);
        return $callback;
    }
    protected function buildClassEventCallback($class, $prefix)
    {
        list($class, $method) = $this->parseClassEvent($class, $prefix);
        return function () use($class, $method) {
            return call_user_func_array([$this->container->make($class), $method], func_get_args());
        };
    }
    protected function parseClassEvent($class, $prefix)
    {
        return Str::parseCallback($class, $this->classEventMethodForPrefix($prefix));
    }
    protected function classEventMethodForPrefix($prefix)
    {
        return Str::contains($prefix, 'composing') ? 'compose' : 'create';
    }
    protected function addEventListener($name, $callback)
    {
        if (Str::contains($name, '*')) {
            $callback = function ($payload) use($callback) {
                return $callback($payload);
            };
        }
        $this->events->listen($name, $callback);
    }
    public function callComposer(ViewContract $view)
    {
        $this->events->dispatch('composing: ' . $view->name(), [$view]);
    }
    public function callCreator(ViewContract $view)
    {
        $this->events->dispatch('creating: ' . $view->name(), [$view]);
    }
}
}

namespace Royalcms\Component\View\Concerns {
use InvalidArgumentException;
use Royalcms\Component\Contracts\View\View;
trait ManagesLayouts
{
    protected $sections = [];
    protected $sectionStack = [];
    protected static $parentPlaceholder = [];
    public function startSection($section, $content = null)
    {
        if ($content === null) {
            if (ob_start()) {
                $this->sectionStack[] = $section;
            }
        } else {
            $this->extendSection($section, $content instanceof View ? $content : e($content));
        }
    }
    public function inject($section, $content)
    {
        $this->startSection($section, $content);
    }
    public function yieldSection()
    {
        if (empty($this->sectionStack)) {
            return '';
        }
        return $this->yieldContent($this->stopSection());
    }
    public function stopSection($overwrite = false)
    {
        if (empty($this->sectionStack)) {
            throw new InvalidArgumentException('Cannot end a section without first starting one.');
        }
        $last = array_pop($this->sectionStack);
        if ($overwrite) {
            $this->sections[$last] = ob_get_clean();
        } else {
            $this->extendSection($last, ob_get_clean());
        }
        return $last;
    }
    public function appendSection()
    {
        if (empty($this->sectionStack)) {
            throw new InvalidArgumentException('Cannot end a section without first starting one.');
        }
        $last = array_pop($this->sectionStack);
        if (isset($this->sections[$last])) {
            $this->sections[$last] .= ob_get_clean();
        } else {
            $this->sections[$last] = ob_get_clean();
        }
        return $last;
    }
    protected function extendSection($section, $content)
    {
        if (isset($this->sections[$section])) {
            $content = str_replace(static::parentPlaceholder($section), $content, $this->sections[$section]);
        }
        $this->sections[$section] = $content;
    }
    public function yieldContent($section, $default = '')
    {
        $sectionContent = $default instanceof View ? $default : e($default);
        if (isset($this->sections[$section])) {
            $sectionContent = $this->sections[$section];
        }
        $sectionContent = str_replace('@@parent', '--parent--holder--', $sectionContent);
        return str_replace('--parent--holder--', '@parent', str_replace(static::parentPlaceholder($section), '', $sectionContent));
    }
    public static function parentPlaceholder($section = '')
    {
        if (!isset(static::$parentPlaceholder[$section])) {
            static::$parentPlaceholder[$section] = '##parent-placeholder-' . sha1($section) . '##';
        }
        return static::$parentPlaceholder[$section];
    }
    public function hasSection($name)
    {
        return array_key_exists($name, $this->sections);
    }
    public function getSection($name, $default = null)
    {
        return $this->getSections()[$name] ? $this->getSections()[$name] : $default;
    }
    public function getSections()
    {
        return $this->sections;
    }
    public function flushSections()
    {
        $this->sections = [];
        $this->sectionStack = [];
    }
}
}

namespace Royalcms\Component\View\Concerns {
use Countable;
use Royalcms\Component\Support\Arr;
trait ManagesLoops
{
    protected $loopsStack = [];
    public function addLoop($data)
    {
        $length = is_array($data) || $data instanceof Countable ? count($data) : null;
        $parent = Arr::last($this->loopsStack);
        $this->loopsStack[] = ['iteration' => 0, 'index' => 0, 'remaining' => $length ? $length : null, 'count' => $length, 'first' => true, 'last' => isset($length) ? $length == 1 : null, 'depth' => count($this->loopsStack) + 1, 'parent' => $parent ? (object) $parent : null];
    }
    public function incrementLoopIndices()
    {
        $loop = $this->loopsStack[$index = count($this->loopsStack) - 1];
        $this->loopsStack[$index] = array_merge($this->loopsStack[$index], ['iteration' => $loop['iteration'] + 1, 'index' => $loop['iteration'], 'first' => $loop['iteration'] == 0, 'remaining' => isset($loop['count']) ? $loop['remaining'] - 1 : null, 'last' => isset($loop['count']) ? $loop['iteration'] == $loop['count'] - 1 : null]);
    }
    public function popLoop()
    {
        array_pop($this->loopsStack);
    }
    public function getLastLoop()
    {
        if ($last = Arr::last($this->loopsStack)) {
            return (object) $last;
        }
    }
    public function getLoopStack()
    {
        return $this->loopsStack;
    }
}
}

namespace Royalcms\Component\View\Concerns {
use InvalidArgumentException;
trait ManagesStacks
{
    protected $pushes = [];
    protected $prepends = [];
    protected $pushStack = [];
    public function startPush($section, $content = '')
    {
        if ($content === '') {
            if (ob_start()) {
                $this->pushStack[] = $section;
            }
        } else {
            $this->extendPush($section, $content);
        }
    }
    public function stopPush()
    {
        if (empty($this->pushStack)) {
            throw new InvalidArgumentException('Cannot end a push stack without first starting one.');
        }
        return tap(array_pop($this->pushStack), function ($last) {
            $this->extendPush($last, ob_get_clean());
        });
    }
    protected function extendPush($section, $content)
    {
        if (!isset($this->pushes[$section])) {
            $this->pushes[$section] = [];
        }
        if (!isset($this->pushes[$section][$this->renderCount])) {
            $this->pushes[$section][$this->renderCount] = $content;
        } else {
            $this->pushes[$section][$this->renderCount] .= $content;
        }
    }
    public function startPrepend($section, $content = '')
    {
        if ($content === '') {
            if (ob_start()) {
                $this->pushStack[] = $section;
            }
        } else {
            $this->extendPrepend($section, $content);
        }
    }
    public function stopPrepend()
    {
        if (empty($this->pushStack)) {
            throw new InvalidArgumentException('Cannot end a prepend operation without first starting one.');
        }
        return tap(array_pop($this->pushStack), function ($last) {
            $this->extendPrepend($last, ob_get_clean());
        });
    }
    protected function extendPrepend($section, $content)
    {
        if (!isset($this->prepends[$section])) {
            $this->prepends[$section] = [];
        }
        if (!isset($this->prepends[$section][$this->renderCount])) {
            $this->prepends[$section][$this->renderCount] = $content;
        } else {
            $this->prepends[$section][$this->renderCount] = $content . $this->prepends[$section][$this->renderCount];
        }
    }
    public function yieldPushContent($section, $default = '')
    {
        if (!isset($this->pushes[$section]) && !isset($this->prepends[$section])) {
            return $default;
        }
        $output = '';
        if (isset($this->prepends[$section])) {
            $output .= implode(array_reverse($this->prepends[$section]));
        }
        if (isset($this->pushes[$section])) {
            $output .= implode($this->pushes[$section]);
        }
        return $output;
    }
    public function flushStacks()
    {
        $this->pushes = [];
        $this->prepends = [];
        $this->pushStack = [];
    }
}
}

namespace Royalcms\Component\View\Concerns {
trait ManagesTranslations
{
    protected $translationReplacements = [];
    public function startTranslation($replacements = [])
    {
        ob_start();
        $this->translationReplacements = $replacements;
    }
    public function renderTranslation()
    {
        return $this->container->make('translator')->getFromJson(trim(ob_get_clean()), $this->translationReplacements);
    }
}
}

namespace Royalcms\Component\View\Compilers {
interface CompilerInterface
{
    public function getCompiledPath($path);
    public function isExpired($path);
    public function compile($path);
}
}

namespace Royalcms\Component\View\Compilers {
use InvalidArgumentException;
use Royalcms\Component\Filesystem\Filesystem;
abstract class Compiler
{
    protected $files;
    protected $cachePath;
    public function __construct(Filesystem $files, $cachePath)
    {
        if (!$cachePath) {
            throw new InvalidArgumentException('Please provide a valid cache path.');
        }
        $this->files = $files;
        $this->cachePath = $cachePath;
        if (!$this->files->isDirectory($this->cachePath)) {
            $this->files->makeDirectory($this->cachePath, 0755, true, true);
        }
    }
    public function getCompiledPath($path)
    {
        return $this->cachePath . '/' . sha1($path) . '.php';
    }
    public function isExpired($path)
    {
        $compiled = $this->getCompiledPath($path);
        if (!$this->files->exists($compiled)) {
            return true;
        }
        return $this->files->lastModified($path) >= $this->files->lastModified($compiled);
    }
}
}

namespace Royalcms\Component\View\Compilers {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
class BladeCompiler extends Compiler implements CompilerInterface
{
    use Concerns\CompilesAuthorizations, Concerns\CompilesComments, Concerns\CompilesComponents, Concerns\CompilesConditionals, Concerns\CompilesEchos, Concerns\CompilesHelpers, Concerns\CompilesIncludes, Concerns\CompilesInjections, Concerns\CompilesJson, Concerns\CompilesLayouts, Concerns\CompilesLoops, Concerns\CompilesRawPhp, Concerns\CompilesStacks, Concerns\CompilesTranslations;
    protected $extensions = [];
    protected $customDirectives = [];
    protected $conditions = [];
    protected $path;
    protected $compilers = ['Comments', 'Extensions', 'Statements', 'Echos'];
    protected $rawTags = ['{!!', '!!}'];
    protected $contentTags = ['{{', '}}'];
    protected $escapedTags = ['{{{', '}}}'];
    protected $echoFormat = 'e(%s)';
    protected $footer = [];
    protected $rawBlocks = [];
    public function compile($path = null)
    {
        if ($path) {
            $this->setPath($path);
        }
        if (!is_null($this->cachePath)) {
            $contents = $this->compileString($this->files->get($this->getPath()));
            $this->files->put($this->getCompiledPath($this->getPath()), $contents);
        }
    }
    public function getPath()
    {
        return $this->path;
    }
    public function setPath($path)
    {
        $this->path = $path;
    }
    public function compileString($value)
    {
        if (strpos($value, '@verbatim') !== false) {
            $value = $this->storeVerbatimBlocks($value);
        }
        $this->footer = [];
        if (strpos($value, '@php') !== false) {
            $value = $this->storePhpBlocks($value);
        }
        $result = '';
        foreach (token_get_all($value) as $token) {
            $result .= is_array($token) ? $this->parseToken($token) : $token;
        }
        if (!empty($this->rawBlocks)) {
            $result = $this->restoreRawContent($result);
        }
        if (count($this->footer) > 0) {
            $result = $this->addFooters($result);
        }
        return $result;
    }
    protected function storeVerbatimBlocks($value)
    {
        return preg_replace_callback('/(?<!@)@verbatim(.*?)@endverbatim/s', function ($matches) {
            return $this->storeRawBlock($matches[1]);
        }, $value);
    }
    protected function storePhpBlocks($value)
    {
        return preg_replace_callback('/(?<!@)@php(.*?)@endphp/s', function ($matches) {
            return $this->storeRawBlock("<?php{$matches[1]}?>");
        }, $value);
    }
    protected function storeRawBlock($value)
    {
        return $this->getRawPlaceholder(array_push($this->rawBlocks, $value) - 1);
    }
    protected function restoreRawContent($result)
    {
        $result = preg_replace_callback('/' . $this->getRawPlaceholder('(\\d+)') . '/', function ($matches) {
            return $this->rawBlocks[$matches[1]];
        }, $result);
        $this->rawBlocks = [];
        return $result;
    }
    protected function getRawPlaceholder($replace)
    {
        return str_replace('#', $replace, '@__raw_block_#__@');
    }
    protected function addFooters($result)
    {
        return ltrim($result, PHP_EOL) . PHP_EOL . implode(PHP_EOL, array_reverse($this->footer));
    }
    protected function parseToken($token)
    {
        list($id, $content) = $token;
        if ($id == T_INLINE_HTML) {
            foreach ($this->compilers as $type) {
                $content = $this->{"compile{$type}"}($content);
            }
        }
        return $content;
    }
    protected function compileExtensions($value)
    {
        foreach ($this->extensions as $compiler) {
            $value = call_user_func($compiler, $value, $this);
        }
        return $value;
    }
    protected function compileStatements($value)
    {
        return preg_replace_callback('/\\B@(@?\\w+(?:::\\w+)?)([ \\t]*)(\\( ( (?>[^()]+) | (?3) )* \\))?/x', function ($match) {
            return $this->compileStatement($match);
        }, $value);
    }
    protected function compileStatement($match)
    {
        if (Str::contains($match[1], '@')) {
            $match[0] = isset($match[3]) ? $match[1] . $match[3] : $match[1];
        } elseif (isset($this->customDirectives[$match[1]])) {
            $match[0] = $this->callCustomDirective($match[1], Arr::get($match, 3));
        } elseif (method_exists($this, $method = 'compile' . ucfirst($match[1]))) {
            $match[0] = $this->{$method}(Arr::get($match, 3));
        }
        return isset($match[3]) ? $match[0] : $match[0] . $match[2];
    }
    protected function callCustomDirective($name, $value)
    {
        if (Str::startsWith($value, '(') && Str::endsWith($value, ')')) {
            $value = Str::substr($value, 1, -1);
        }
        return call_user_func($this->customDirectives[$name], trim($value));
    }
    public function stripParentheses($expression)
    {
        if (Str::startsWith($expression, '(')) {
            $expression = substr($expression, 1, -1);
        }
        return $expression;
    }
    public function extend(callable $compiler)
    {
        $this->extensions[] = $compiler;
    }
    public function getExtensions()
    {
        return $this->extensions;
    }
    public function directiveIf($name, callable $callback)
    {
        $this->conditions[$name] = $callback;
        $this->directive($name, function ($expression) use($name) {
            return $expression ? "<?php if (\\Royalcms\\Component\\Support\\Facades\\Blade::check('{$name}', {$expression})): ?>" : "<?php if (\\Royalcms\\Component\\Support\\Facades\\Blade::check('{$name}')): ?>";
        });
        $this->directive('else' . $name, function ($expression) use($name) {
            return $expression ? "<?php elseif (\\Royalcms\\Component\\Support\\Facades\\Blade::check('{$name}', {$expression})): ?>" : "<?php elseif (\\Royalcms\\Component\\Support\\Facades\\Blade::check('{$name}')): ?>";
        });
        $this->directive('end' . $name, function () {
            return '<?php endif; ?>';
        });
    }
    public function check($name)
    {
        $parameters = func_get_args();
        array_shift($parameters);
        return call_user_func_array($this->conditions[$name], $parameters);
    }
    public function component($path, $alias = null)
    {
        $alias = $alias ?: array_last(explode('.', $path));
        $this->directive($alias, function ($expression) use($path) {
            return $expression ? "<?php \$__env->startComponent('{$path}', {$expression}); ?>" : "<?php \$__env->startComponent('{$path}'); ?>";
        });
        $this->directive('end' . $alias, function ($expression) {
            return '<?php echo $__env->renderComponent(); ?>';
        });
    }
    public function directiveInclude($path, $alias = null)
    {
        $alias = $alias ?: array_last(explode('.', $path));
        $this->directive($alias, function ($expression) use($path) {
            $expression = $this->stripParentheses($expression) ?: '[]';
            return "<?php echo \$__env->make('{$path}', {$expression}, array_except(get_defined_vars(), array('__data', '__path')))->render(); ?>";
        });
    }
    public function directive($name, callable $handler)
    {
        $this->customDirectives[$name] = $handler;
    }
    public function getCustomDirectives()
    {
        return $this->customDirectives;
    }
    public function setEchoFormat($format)
    {
        $this->echoFormat = $format;
    }
    public function withDoubleEncoding()
    {
        $this->setEchoFormat('e(%s, true)');
    }
    public function withoutDoubleEncoding()
    {
        $this->setEchoFormat('e(%s, false)');
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesAuthorizations
{
    protected function compileCan($expression)
    {
        return "<?php if (app(\\Royalcms\\Component\\Contracts\\Auth\\Access\\Gate::class)->check{$expression}): ?>";
    }
    protected function compileCannot($expression)
    {
        return "<?php if (app(\\Royalcms\\Component\\Contracts\\Auth\\Access\\Gate::class)->denies{$expression}): ?>";
    }
    protected function compileElsecan($expression)
    {
        return "<?php elseif (app(\\Royalcms\\Component\\Contracts\\Auth\\Access\\Gate::class)->check{$expression}): ?>";
    }
    protected function compileElsecannot($expression)
    {
        return "<?php elseif (app(\\Royalcms\\Component\\Contracts\\Auth\\Access\\Gate::class)->denies{$expression}): ?>";
    }
    protected function compileEndcan()
    {
        return '<?php endif; ?>';
    }
    protected function compileEndcannot()
    {
        return '<?php endif; ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesComments
{
    protected function compileComments($value)
    {
        $pattern = sprintf('/%s--(.*?)--%s/s', $this->contentTags[0], $this->contentTags[1]);
        return preg_replace($pattern, '', $value);
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesComponents
{
    protected function compileComponent($expression)
    {
        return "<?php \$__env->startComponent{$expression}; ?>";
    }
    protected function compileEndComponent()
    {
        return '<?php echo $__env->renderComponent(); ?>';
    }
    protected function compileSlot($expression)
    {
        return "<?php \$__env->slot{$expression}; ?>";
    }
    protected function compileEndSlot()
    {
        return '<?php $__env->endSlot(); ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesConditionals
{
    protected $firstCaseInSwitch = true;
    protected function compileAuth($guard = null)
    {
        $guard = is_null($guard) ? '()' : $guard;
        return "<?php if(auth()->guard{$guard}->check()): ?>";
    }
    protected function compileEndAuth()
    {
        return '<?php endif; ?>';
    }
    protected function compileGuest($guard = null)
    {
        $guard = is_null($guard) ? '()' : $guard;
        return "<?php if(auth()->guard{$guard}->guest()): ?>";
    }
    protected function compileEndGuest()
    {
        return '<?php endif; ?>';
    }
    protected function compileHasSection($expression)
    {
        return "<?php if (! empty(trim(\$__env->yieldContent{$expression}))): ?>";
    }
    protected function compileIf($expression)
    {
        return "<?php if{$expression}: ?>";
    }
    protected function compileUnless($expression)
    {
        return "<?php if (! {$expression}): ?>";
    }
    protected function compileElseif($expression)
    {
        return "<?php elseif{$expression}: ?>";
    }
    protected function compileElse()
    {
        return '<?php else: ?>';
    }
    protected function compileEndif()
    {
        return '<?php endif; ?>';
    }
    protected function compileEndunless()
    {
        return '<?php endif; ?>';
    }
    protected function compileIsset($expression)
    {
        return "<?php if(isset{$expression}): ?>";
    }
    protected function compileEndIsset()
    {
        return '<?php endif; ?>';
    }
    protected function compileSwitch($expression)
    {
        $this->firstCaseInSwitch = true;
        return "<?php switch{$expression}:";
    }
    protected function compileCase($expression)
    {
        if ($this->firstCaseInSwitch) {
            $this->firstCaseInSwitch = false;
            return "case {$expression}: ?>";
        }
        return "<?php case {$expression}: ?>";
    }
    protected function compileDefault()
    {
        return '<?php default: ?>';
    }
    protected function compileEndSwitch()
    {
        return '<?php endswitch; ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesEchos
{
    protected function compileEchos($value)
    {
        foreach ($this->getEchoMethods() as $method) {
            $value = $this->{$method}($value);
        }
        return $value;
    }
    protected function getEchoMethods()
    {
        return ['compileRawEchos', 'compileEscapedEchos', 'compileRegularEchos'];
    }
    protected function compileRawEchos($value)
    {
        $pattern = sprintf('/(@)?%s\\s*(.+?)\\s*%s(\\r?\\n)?/s', $this->rawTags[0], $this->rawTags[1]);
        $callback = function ($matches) {
            $whitespace = empty($matches[3]) ? '' : $matches[3] . $matches[3];
            return $matches[1] ? substr($matches[0], 1) : "<?php echo {$this->compileEchoDefaults($matches[2])}; ?>{$whitespace}";
        };
        return preg_replace_callback($pattern, $callback, $value);
    }
    protected function compileRegularEchos($value)
    {
        $pattern = sprintf('/(@)?%s\\s*(.+?)\\s*%s(\\r?\\n)?/s', $this->contentTags[0], $this->contentTags[1]);
        $callback = function ($matches) {
            $whitespace = empty($matches[3]) ? '' : $matches[3] . $matches[3];
            $wrapped = sprintf($this->echoFormat, $this->compileEchoDefaults($matches[2]));
            return $matches[1] ? substr($matches[0], 1) : "<?php echo {$wrapped}; ?>{$whitespace}";
        };
        return preg_replace_callback($pattern, $callback, $value);
    }
    protected function compileEscapedEchos($value)
    {
        $pattern = sprintf('/(@)?%s\\s*(.+?)\\s*%s(\\r?\\n)?/s', $this->escapedTags[0], $this->escapedTags[1]);
        $callback = function ($matches) {
            $whitespace = empty($matches[3]) ? '' : $matches[3] . $matches[3];
            return $matches[1] ? $matches[0] : "<?php echo e({$this->compileEchoDefaults($matches[2])}); ?>{$whitespace}";
        };
        return preg_replace_callback($pattern, $callback, $value);
    }
    public function compileEchoDefaults($value)
    {
        return preg_replace('/^(?=\\$)(.+?)(?:\\s+or\\s+)(.+?)$/si', 'isset($1) ? $1 : $2', $value);
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesHelpers
{
    protected function compileCsrf()
    {
        return '<?php echo csrf_field(); ?>';
    }
    protected function compileDd($arguments)
    {
        return "<?php dd{$arguments}; ?>";
    }
    protected function compileMethod($method)
    {
        return "<?php echo method_field{$method}; ?>";
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesIncludes
{
    protected function compileEach($expression)
    {
        return "<?php echo \$__env->renderEach{$expression}; ?>";
    }
    protected function compileInclude($expression)
    {
        $expression = $this->stripParentheses($expression);
        return "<?php echo \$__env->make({$expression}, array_except(get_defined_vars(), array('__data', '__path')))->render(); ?>";
    }
    protected function compileIncludeIf($expression)
    {
        $expression = $this->stripParentheses($expression);
        return "<?php if (\$__env->exists({$expression})) echo \$__env->make({$expression}, array_except(get_defined_vars(), array('__data', '__path')))->render(); ?>";
    }
    protected function compileIncludeWhen($expression)
    {
        $expression = $this->stripParentheses($expression);
        return "<?php echo \$__env->renderWhen({$expression}, array_except(get_defined_vars(), array('__data', '__path'))); ?>";
    }
    protected function compileIncludeFirst($expression)
    {
        $expression = $this->stripParentheses($expression);
        return "<?php echo \$__env->first({$expression}, array_except(get_defined_vars(), array('__data', '__path')))->render(); ?>";
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesInjections
{
    protected function compileInject($expression)
    {
        $segments = explode(',', preg_replace("/[\\(\\)\\\"\\']/", '', $expression));
        $variable = trim($segments[0]);
        $service = trim($segments[1]);
        return "<?php \${$variable} = app('{$service}'); ?>";
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesJson
{
    private $encodingOptions;
    protected function compileJson($expression)
    {
        if (is_null($this->encodingOptions)) {
            $this->encodingOptions = JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT;
        }
        $parts = explode(',', $this->stripParentheses($expression));
        $options = isset($parts[1]) ? trim($parts[1]) : $this->encodingOptions;
        $depth = isset($parts[2]) ? trim($parts[2]) : 512;
        return "<?php echo json_encode({$parts['0']}, {$options}, {$depth}) ?>";
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
use Royalcms\Component\View\Factory as ViewFactory;
trait CompilesLayouts
{
    protected $lastSection;
    protected function compileExtends($expression)
    {
        $expression = $this->stripParentheses($expression);
        $echo = "<?php echo \$__env->make({$expression}, array_except(get_defined_vars(), array('__data', '__path')))->render(); ?>";
        $this->footer[] = $echo;
        return '';
    }
    protected function compileSection($expression)
    {
        $this->lastSection = trim($expression, "()'\" ");
        return "<?php \$__env->startSection{$expression}; ?>";
    }
    protected function compileParent()
    {
        return ViewFactory::parentPlaceholder($this->lastSection ?: '');
    }
    protected function compileYield($expression)
    {
        return "<?php echo \$__env->yieldContent{$expression}; ?>";
    }
    protected function compileShow()
    {
        return '<?php echo $__env->yieldSection(); ?>';
    }
    protected function compileAppend()
    {
        return '<?php $__env->appendSection(); ?>';
    }
    protected function compileOverwrite()
    {
        return '<?php $__env->stopSection(true); ?>';
    }
    protected function compileStop()
    {
        return '<?php $__env->stopSection(); ?>';
    }
    protected function compileEndsection()
    {
        return '<?php $__env->stopSection(); ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesLoops
{
    protected $forElseCounter = 0;
    protected function compileForelse($expression)
    {
        $empty = '$__empty_' . ++$this->forElseCounter;
        preg_match('/\\( *(.*) +as *(.*)\\)$/is', $expression, $matches);
        $iteratee = trim($matches[1]);
        $iteration = trim($matches[2]);
        $initLoop = "\$__currentLoopData = {$iteratee}; \$__env->addLoop(\$__currentLoopData);";
        $iterateLoop = '$__env->incrementLoopIndices(); $loop = $__env->getLastLoop();';
        return "<?php {$empty} = true; {$initLoop} foreach(\$__currentLoopData as {$iteration}): {$iterateLoop} {$empty} = false; ?>";
    }
    protected function compileEmpty($expression)
    {
        if ($expression) {
            return "<?php if(empty{$expression}): ?>";
        }
        $empty = '$__empty_' . $this->forElseCounter--;
        return "<?php endforeach; \$__env->popLoop(); \$loop = \$__env->getLastLoop(); if ({$empty}): ?>";
    }
    protected function compileEndforelse()
    {
        return '<?php endif; ?>';
    }
    protected function compileEndEmpty()
    {
        return '<?php endif; ?>';
    }
    protected function compileFor($expression)
    {
        return "<?php for{$expression}: ?>";
    }
    protected function compileForeach($expression)
    {
        preg_match('/\\( *(.*) +as *(.*)\\)$/is', $expression, $matches);
        $iteratee = trim($matches[1]);
        $iteration = trim($matches[2]);
        $initLoop = "\$__currentLoopData = {$iteratee}; \$__env->addLoop(\$__currentLoopData);";
        $iterateLoop = '$__env->incrementLoopIndices(); $loop = $__env->getLastLoop();';
        return "<?php {$initLoop} foreach(\$__currentLoopData as {$iteration}): {$iterateLoop} ?>";
    }
    protected function compileBreak($expression)
    {
        if ($expression) {
            preg_match('/\\(\\s*(-?\\d+)\\s*\\)$/', $expression, $matches);
            return $matches ? '<?php break ' . max(1, $matches[1]) . '; ?>' : "<?php if{$expression} break; ?>";
        }
        return '<?php break; ?>';
    }
    protected function compileContinue($expression)
    {
        if ($expression) {
            preg_match('/\\(\\s*(-?\\d+)\\s*\\)$/', $expression, $matches);
            return $matches ? '<?php continue ' . max(1, $matches[1]) . '; ?>' : "<?php if{$expression} continue; ?>";
        }
        return '<?php continue; ?>';
    }
    protected function compileEndfor()
    {
        return '<?php endfor; ?>';
    }
    protected function compileEndforeach()
    {
        return '<?php endforeach; $__env->popLoop(); $loop = $__env->getLastLoop(); ?>';
    }
    protected function compileWhile($expression)
    {
        return "<?php while{$expression}: ?>";
    }
    protected function compileEndwhile()
    {
        return '<?php endwhile; ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesRawPhp
{
    protected function compilePhp($expression)
    {
        if ($expression) {
            return "<?php {$expression}; ?>";
        }
        return '@php';
    }
    protected function compileUnset($expression)
    {
        return "<?php unset{$expression}; ?>";
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesStacks
{
    protected function compileStack($expression)
    {
        return "<?php echo \$__env->yieldPushContent{$expression}; ?>";
    }
    protected function compilePush($expression)
    {
        return "<?php \$__env->startPush{$expression}; ?>";
    }
    protected function compileEndpush()
    {
        return '<?php $__env->stopPush(); ?>';
    }
    protected function compilePrepend($expression)
    {
        return "<?php \$__env->startPrepend{$expression}; ?>";
    }
    protected function compileEndprepend()
    {
        return '<?php $__env->stopPrepend(); ?>';
    }
}
}

namespace Royalcms\Component\View\Compilers\Concerns {
trait CompilesTranslations
{
    protected function compileLang($expression)
    {
        if (is_null($expression)) {
            return '<?php $__env->startTranslation(); ?>';
        } elseif ($expression[1] === '[') {
            return "<?php \$__env->startTranslation{$expression}; ?>";
        }
        return "<?php echo app('translator')->getFromJson{$expression}; ?>";
    }
    protected function compileEndlang()
    {
        return '<?php echo $__env->renderTranslation(); ?>';
    }
    protected function compileChoice($expression)
    {
        return "<?php echo app('translator')->choice{$expression}; ?>";
    }
}
}

namespace Royalcms\Component\View {
interface ViewFinderInterface
{
    const HINT_PATH_DELIMITER = '::';
    public function find($view);
    public function addLocation($location);
    public function addNamespace($namespace, $hints);
    public function prependNamespace($namespace, $hints);
    public function replaceNamespace($namespace, $hints);
    public function addExtension($extension);
    public function flush();
}
}

namespace Royalcms\Component\View {
use InvalidArgumentException;
use Royalcms\Component\Filesystem\Filesystem;
class FileViewFinder implements ViewFinderInterface
{
    protected $files;
    protected $paths;
    protected $views = [];
    protected $hints = [];
    protected $extensions = ['blade.php', 'php', 'css'];
    public function __construct(Filesystem $files, array $paths, array $extensions = null)
    {
        $this->files = $files;
        $this->paths = $paths;
        if (isset($extensions)) {
            $this->extensions = $extensions;
        }
    }
    public function find($name)
    {
        if (isset($this->views[$name])) {
            return $this->views[$name];
        }
        if ($this->hasHintInformation($name = trim($name))) {
            return $this->views[$name] = $this->findNamespacedView($name);
        }
        return $this->views[$name] = $this->findInPaths($name, $this->paths);
    }
    protected function findNamespacedView($name)
    {
        list($namespace, $view) = $this->parseNamespaceSegments($name);
        return $this->findInPaths($view, $this->hints[$namespace]);
    }
    protected function parseNamespaceSegments($name)
    {
        $segments = explode(static::HINT_PATH_DELIMITER, $name);
        if (count($segments) != 2) {
            throw new InvalidArgumentException("View [{$name}] has an invalid name.");
        }
        if (!isset($this->hints[$segments[0]])) {
            throw new InvalidArgumentException("No hint path defined for [{$segments[0]}].");
        }
        return $segments;
    }
    protected function findInPaths($name, $paths)
    {
        foreach ((array) $paths as $path) {
            foreach ($this->getPossibleViewFiles($name) as $file) {
                if ($this->files->exists($viewPath = $path . '/' . $file)) {
                    return $viewPath;
                }
            }
        }
        throw new InvalidArgumentException("View [{$name}] not found.");
    }
    protected function getPossibleViewFiles($name)
    {
        return array_map(function ($extension) use($name) {
            return str_replace('.', '/', $name) . '.' . $extension;
        }, $this->extensions);
    }
    public function addLocation($location)
    {
        $this->paths[] = $location;
    }
    public function prependLocation($location)
    {
        array_unshift($this->paths, $location);
    }
    public function addNamespace($namespace, $hints)
    {
        $hints = (array) $hints;
        if (isset($this->hints[$namespace])) {
            $hints = array_merge($this->hints[$namespace], $hints);
        }
        $this->hints[$namespace] = $hints;
    }
    public function prependNamespace($namespace, $hints)
    {
        $hints = (array) $hints;
        if (isset($this->hints[$namespace])) {
            $hints = array_merge($hints, $this->hints[$namespace]);
        }
        $this->hints[$namespace] = $hints;
    }
    public function replaceNamespace($namespace, $hints)
    {
        $this->hints[$namespace] = (array) $hints;
    }
    public function addExtension($extension)
    {
        if (($index = array_search($extension, $this->extensions)) !== false) {
            unset($this->extensions[$index]);
        }
        array_unshift($this->extensions, $extension);
    }
    public function hasHintInformation($name)
    {
        return strpos($name, static::HINT_PATH_DELIMITER) > 0;
    }
    public function flush()
    {
        $this->views = [];
    }
    public function getFilesystem()
    {
        return $this->files;
    }
    public function getPaths()
    {
        return $this->paths;
    }
    public function getHints()
    {
        return $this->hints;
    }
    public function getExtensions()
    {
        return $this->extensions;
    }
}
}

namespace Royalcms\Component\View {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use InvalidArgumentException;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\View\Engines\EngineResolver;
use Royalcms\Component\Contracts\Container\Container;
use Royalcms\Component\Contracts\View\Factory as FactoryContract;
class Factory implements FactoryContract
{
    use Concerns\ManagesComponents, Concerns\ManagesEvents, Concerns\ManagesLayouts, Concerns\ManagesLoops, Concerns\ManagesStacks, Concerns\ManagesTranslations;
    protected $engines;
    protected $finder;
    protected $events;
    protected $container;
    protected $shared = [];
    protected $extensions = ['blade.php' => 'blade', 'php' => 'php', 'css' => 'file'];
    protected $composers = [];
    protected $renderCount = 0;
    public function __construct(EngineResolver $engines, ViewFinderInterface $finder, Dispatcher $events)
    {
        $this->finder = $finder;
        $this->events = $events;
        $this->engines = $engines;
        $this->share('__env', $this);
    }
    public function file($path, $data = [], $mergeData = [])
    {
        $data = array_merge($mergeData, $this->parseData($data));
        return tap($this->viewInstance($path, $path, $data), function ($view) {
            $this->callCreator($view);
        });
    }
    public function make($view, $data = [], $mergeData = [])
    {
        $path = $this->finder->find($view = $this->normalizeName($view));
        $data = array_merge($mergeData, $this->parseData($data));
        return tap($this->viewInstance($view, $path, $data), function ($view) {
            $this->callCreator($view);
        });
    }
    public function first(array $views, $data = [], $mergeData = [])
    {
        $view = collect($views)->first(function ($view) {
            return $this->exists($view);
        });
        if (!$view) {
            throw new InvalidArgumentException('None of the views in the given array exist.');
        }
        return $this->make($view, $data, $mergeData);
    }
    public function renderWhen($condition, $view, $data = [], $mergeData = [])
    {
        if (!$condition) {
            return '';
        }
        return $this->make($view, $this->parseData($data), $mergeData)->render();
    }
    public function renderEach($view, $data, $iterator, $empty = 'raw|')
    {
        $result = '';
        if (count($data) > 0) {
            foreach ($data as $key => $value) {
                $result .= $this->make($view, ['key' => $key, $iterator => $value])->render();
            }
        } else {
            $result = Str::startsWith($empty, 'raw|') ? substr($empty, 4) : $this->make($empty)->render();
        }
        return $result;
    }
    protected function normalizeName($name)
    {
        return ViewName::normalize($name);
    }
    protected function parseData($data)
    {
        return $data instanceof Arrayable ? $data->toArray() : $data;
    }
    protected function viewInstance($view, $path, $data)
    {
        return new View($this, $this->getEngineFromPath($path), $view, $path, $data);
    }
    public function exists($view)
    {
        try {
            $this->finder->find($view);
        } catch (InvalidArgumentException $e) {
            return false;
        }
        return true;
    }
    public function getEngineFromPath($path)
    {
        if (!($extension = $this->getExtension($path))) {
            throw new InvalidArgumentException("Unrecognized extension in file: {$path}");
        }
        $engine = $this->extensions[$extension];
        return $this->engines->resolve($engine);
    }
    protected function getExtension($path)
    {
        $extensions = array_keys($this->extensions);
        return Arr::first($extensions, function ($value) use($path) {
            return Str::endsWith($path, '.' . $value);
        });
    }
    public function share($key, $value = null)
    {
        $keys = is_array($key) ? $key : [$key => $value];
        foreach ($keys as $key => $value) {
            $this->shared[$key] = $value;
        }
        return $value;
    }
    public function incrementRender()
    {
        $this->renderCount++;
    }
    public function decrementRender()
    {
        $this->renderCount--;
    }
    public function doneRendering()
    {
        return $this->renderCount == 0;
    }
    public function addLocation($location)
    {
        $this->finder->addLocation($location);
    }
    public function addNamespace($namespace, $hints)
    {
        $this->finder->addNamespace($namespace, $hints);
        return $this;
    }
    public function prependNamespace($namespace, $hints)
    {
        $this->finder->prependNamespace($namespace, $hints);
        return $this;
    }
    public function replaceNamespace($namespace, $hints)
    {
        $this->finder->replaceNamespace($namespace, $hints);
        return $this;
    }
    public function addExtension($extension, $engine, $resolver = null)
    {
        $this->finder->addExtension($extension);
        if (isset($resolver)) {
            $this->engines->register($engine, $resolver);
        }
        unset($this->extensions[$extension]);
        $this->extensions = array_merge([$extension => $engine], $this->extensions);
    }
    public function flushState()
    {
        $this->renderCount = 0;
        $this->flushSections();
        $this->flushStacks();
    }
    public function flushStateIfDoneRendering()
    {
        if ($this->doneRendering()) {
            $this->flushState();
        }
    }
    public function getExtensions()
    {
        return $this->extensions;
    }
    public function getEngineResolver()
    {
        return $this->engines;
    }
    public function getFinder()
    {
        return $this->finder;
    }
    public function setFinder(ViewFinderInterface $finder)
    {
        $this->finder = $finder;
    }
    public function flushFinderCache()
    {
        $this->getFinder()->flush();
    }
    public function getDispatcher()
    {
        return $this->events;
    }
    public function setDispatcher(Dispatcher $events)
    {
        $this->events = $events;
    }
    public function getContainer()
    {
        return $this->container;
    }
    public function setContainer(Container $container)
    {
        $this->container = $container;
    }
    public function shared($key, $default = null)
    {
        return Arr::get($this->shared, $key, $default);
    }
    public function getShared()
    {
        return $this->shared;
    }
}
}

namespace Royalcms\Component\View {
use Exception;
use Throwable;
use ArrayAccess;
use BadMethodCallException;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Support\MessageBag;
use Royalcms\Component\Contracts\View\Engine;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Contracts\Support\Renderable;
use Royalcms\Component\Contracts\Support\MessageProvider;
use Royalcms\Component\Contracts\View\View as ViewContract;
class View implements ArrayAccess, ViewContract
{
    protected $factory;
    protected $engine;
    protected $view;
    protected $data;
    protected $path;
    public function __construct(Factory $factory, Engine $engine, $view, $path, $data = [])
    {
        $this->view = $view;
        $this->path = $path;
        $this->engine = $engine;
        $this->factory = $factory;
        $this->data = $data instanceof Arrayable ? $data->toArray() : (array) $data;
    }
    public function render(callable $callback = null)
    {
        try {
            $contents = $this->renderContents();
            $response = isset($callback) ? call_user_func($callback, $this, $contents) : null;
            $this->factory->flushStateIfDoneRendering();
            return !is_null($response) ? $response : $contents;
        } catch (Exception $e) {
            $this->factory->flushState();
            throw $e;
        } catch (Throwable $e) {
            $this->factory->flushState();
            throw $e;
        }
    }
    protected function renderContents()
    {
        $this->factory->incrementRender();
        $this->factory->callComposer($this);
        $contents = $this->getContents();
        $this->factory->decrementRender();
        return $contents;
    }
    protected function getContents()
    {
        return $this->engine->get($this->path, $this->gatherData());
    }
    protected function gatherData()
    {
        $data = array_merge($this->factory->getShared(), $this->data);
        foreach ($data as $key => $value) {
            if ($value instanceof Renderable) {
                $data[$key] = $value->render();
            }
        }
        return $data;
    }
    public function renderSections()
    {
        return $this->render(function () {
            return $this->factory->getSections();
        });
    }
    public function with($key, $value = null)
    {
        if (is_array($key)) {
            $this->data = array_merge($this->data, $key);
        } else {
            $this->data[$key] = $value;
        }
        return $this;
    }
    public function nest($key, $view, array $data = [])
    {
        return $this->with($key, $this->factory->make($view, $data));
    }
    public function withErrors($provider)
    {
        $this->with('errors', $this->formatErrors($provider));
        return $this;
    }
    protected function formatErrors($provider)
    {
        return $provider instanceof MessageProvider ? $provider->getMessageBag() : new MessageBag((array) $provider);
    }
    public function name()
    {
        return $this->getName();
    }
    public function getName()
    {
        return $this->view;
    }
    public function getData()
    {
        return $this->data;
    }
    public function getPath()
    {
        return $this->path;
    }
    public function setPath($path)
    {
        $this->path = $path;
    }
    public function getFactory()
    {
        return $this->factory;
    }
    public function getEngine()
    {
        return $this->engine;
    }
    public function offsetExists($key)
    {
        return array_key_exists($key, $this->data);
    }
    public function offsetGet($key)
    {
        return $this->data[$key];
    }
    public function offsetSet($key, $value)
    {
        $this->with($key, $value);
    }
    public function offsetUnset($key)
    {
        unset($this->data[$key]);
    }
    public function &__get($key)
    {
        return $this->data[$key];
    }
    public function __set($key, $value)
    {
        $this->with($key, $value);
    }
    public function __isset($key)
    {
        return isset($this->data[$key]);
    }
    public function __unset($key)
    {
        unset($this->data[$key]);
    }
    public function __call($method, $parameters)
    {
        if (!Str::startsWith($method, 'with')) {
            throw new BadMethodCallException(sprintf('Method %s::%s does not exist.', static::class, $method));
        }
        return $this->with(Str::camel(substr($method, 4)), $parameters[0]);
    }
    public function __toString()
    {
        return $this->render();
    }
}
}

namespace Royalcms\Component\View {
class ViewName
{
    public static function normalize($name)
    {
        $delimiter = ViewFinderInterface::HINT_PATH_DELIMITER;
        if (strpos($name, $delimiter) === false) {
            return str_replace('/', '.', $name);
        }
        list($namespace, $name) = explode($delimiter, $name);
        return $namespace . $delimiter . str_replace('/', '.', $name);
    }
}
}

namespace Royalcms\Component\View {
use Royalcms\Component\View\Engines\PhpEngine;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\View\Engines\FileEngine;
use Royalcms\Component\View\Engines\CompilerEngine;
use Royalcms\Component\View\Engines\EngineResolver;
use Royalcms\Component\View\Compilers\BladeCompiler;
class ViewServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerEngineResolver();
        $this->registerViewFinder();
        $this->registerFactory();
    }
    public function registerFactory()
    {
        $this->royalcms->singleton('view', function ($royalcms) {
            $resolver = $royalcms['view.engine.resolver'];
            $finder = $royalcms['view.finder'];
            $factory = $this->createFactory($resolver, $finder, $royalcms['events']);
            $factory->setContainer($royalcms);
            $factory->share('royalcms', $royalcms);
            return $factory;
        });
    }
    protected function createFactory($resolver, $finder, $events)
    {
        return new Factory($resolver, $finder, $events);
    }
    public function registerViewFinder()
    {
        $this->royalcms->bind('view.finder', function ($royalcms) {
            return new FileViewFinder($royalcms['files'], $royalcms['config']['view.paths']);
        });
    }
    public function registerEngineResolver()
    {
        $this->royalcms->singleton('view.engine.resolver', function () {
            $resolver = new EngineResolver();
            foreach (['file', 'php', 'blade'] as $engine) {
                $this->{'register' . ucfirst($engine) . 'Engine'}($resolver);
            }
            return $resolver;
        });
    }
    public function registerFileEngine($resolver)
    {
        $resolver->register('file', function () {
            return new FileEngine();
        });
    }
    public function registerPhpEngine($resolver)
    {
        $resolver->register('php', function () {
            return new PhpEngine();
        });
    }
    public function registerBladeEngine($resolver)
    {
        $this->royalcms->singleton('blade.compiler', function () {
            return new BladeCompiler($this->royalcms['files'], $this->royalcms['config']['view.compiled']);
        });
        $resolver->register('blade', function () {
            return new CompilerEngine($this->royalcms['blade.compiler']);
        });
    }
}
}

namespace Royalcms\Component\Whoops {
use InvalidArgumentException;
use Royalcms\Component\Whoops\Exception\ErrorException;
use Royalcms\Component\Whoops\Exception\Inspector;
use Royalcms\Component\Whoops\Handler\CallbackHandler;
use Royalcms\Component\Whoops\Handler\Handler;
use Royalcms\Component\Whoops\Handler\HandlerInterface;
use Royalcms\Component\Whoops\Util\Misc;
use Royalcms\Component\Whoops\Util\SystemFacade;
final class Run implements RunInterface
{
    private $isRegistered;
    private $allowQuit = true;
    private $sendOutput = true;
    private $sendHttpCode = 500;
    private $handlerStack = [];
    private $silencedPatterns = [];
    private $system;
    public function __construct(SystemFacade $system = null)
    {
        $this->system = $system ?: new SystemFacade();
    }
    public function pushHandler($handler)
    {
        if (is_callable($handler)) {
            $handler = new CallbackHandler($handler);
        }
        if (!$handler instanceof HandlerInterface) {
            throw new InvalidArgumentException("Argument to " . __METHOD__ . " must be a callable, or instance of " . "Royalcms\\Component\\Whoops\\Handler\\HandlerInterface");
        }
        $this->handlerStack[] = $handler;
        return $this;
    }
    public function popHandler()
    {
        return array_pop($this->handlerStack);
    }
    public function getHandlers()
    {
        return $this->handlerStack;
    }
    public function clearHandlers()
    {
        $this->handlerStack = [];
        return $this;
    }
    private function getInspector($exception)
    {
        return new Inspector($exception);
    }
    public function register()
    {
        if (!$this->isRegistered) {
            class_exists("\\Royalcms\\Component\\Whoops\\Exception\\ErrorException");
            class_exists("\\Royalcms\\Component\\Whoops\\Exception\\FrameCollection");
            class_exists("\\Royalcms\\Component\\Whoops\\Exception\\Frame");
            class_exists("\\Royalcms\\Component\\Whoops\\Exception\\Inspector");
            $this->system->setErrorHandler([$this, self::ERROR_HANDLER]);
            $this->system->setExceptionHandler([$this, self::EXCEPTION_HANDLER]);
            $this->system->registerShutdownFunction([$this, self::SHUTDOWN_HANDLER]);
            $this->isRegistered = true;
        }
        return $this;
    }
    public function unregister()
    {
        if ($this->isRegistered) {
            $this->system->restoreExceptionHandler();
            $this->system->restoreErrorHandler();
            $this->isRegistered = false;
        }
        return $this;
    }
    public function allowQuit($exit = null)
    {
        if (func_num_args() == 0) {
            return $this->allowQuit;
        }
        return $this->allowQuit = (bool) $exit;
    }
    public function silenceErrorsInPaths($patterns, $levels = 10240)
    {
        $this->silencedPatterns = array_merge($this->silencedPatterns, array_map(function ($pattern) use($levels) {
            return ["pattern" => $pattern, "levels" => $levels];
        }, (array) $patterns));
        return $this;
    }
    public function getSilenceErrorsInPaths()
    {
        return $this->silencedPatterns;
    }
    public function sendHttpCode($code = null)
    {
        if (func_num_args() == 0) {
            return $this->sendHttpCode;
        }
        if (!$code) {
            return $this->sendHttpCode = false;
        }
        if ($code === true) {
            $code = 500;
        }
        if ($code < 400 || 600 <= $code) {
            throw new InvalidArgumentException("Invalid status code '{$code}', must be 4xx or 5xx");
        }
        return $this->sendHttpCode = $code;
    }
    public function writeToOutput($send = null)
    {
        if (func_num_args() == 0) {
            return $this->sendOutput;
        }
        return $this->sendOutput = (bool) $send;
    }
    public function handleException($exception)
    {
        $inspector = $this->getInspector($exception);
        $this->system->startOutputBuffering();
        $handlerResponse = null;
        $handlerContentType = null;
        foreach (array_reverse($this->handlerStack) as $handler) {
            $handler->setRun($this);
            $handler->setInspector($inspector);
            $handler->setException($exception);
            $handlerResponse = $handler->handle($exception);
            $handlerContentType = method_exists($handler, 'contentType') ? $handler->contentType() : null;
            if (in_array($handlerResponse, [Handler::LAST_HANDLER, Handler::QUIT])) {
                break;
            }
        }
        $willQuit = $handlerResponse == Handler::QUIT && $this->allowQuit();
        $output = $this->system->cleanOutputBuffer();
        if ($this->writeToOutput()) {
            if ($willQuit) {
                while ($this->system->getOutputBufferLevel() > 0) {
                    $this->system->endOutputBuffering();
                }
                if (Misc::canSendHeaders() && $handlerContentType) {
                    header("Content-Type: {$handlerContentType}");
                }
            }
            $this->writeToOutputNow($output);
        }
        if ($willQuit) {
            $this->system->flushOutputBuffer();
            $this->system->stopExecution(1);
        }
        return $output;
    }
    public function handleError($level, $message, $file = null, $line = null)
    {
        if ($level & $this->system->getErrorReportingLevel()) {
            foreach ($this->silencedPatterns as $entry) {
                $pathMatches = (bool) preg_match($entry["pattern"], $file);
                $levelMatches = $level & $entry["levels"];
                if ($pathMatches && $levelMatches) {
                    return true;
                }
            }
            $exception = new ErrorException($message, $level, $level, $file, $line);
            if ($this->canThrowExceptions) {
                throw $exception;
            } else {
                $this->handleException($exception);
            }
            return true;
        }
        return false;
    }
    public function handleShutdown()
    {
        $this->canThrowExceptions = false;
        $error = $this->system->getLastError();
        if ($error && Misc::isLevelFatal($error['type'])) {
            $this->handleError($error['type'], $error['message'], $error['file'], $error['line']);
        }
    }
    private $canThrowExceptions = true;
    private function writeToOutputNow($output)
    {
        if ($this->sendHttpCode() && \Royalcms\Component\Whoops\Util\Misc::canSendHeaders()) {
            $this->system->setHttpResponseCode($this->sendHttpCode());
        }
        echo $output;
        return $this;
    }
}
}

namespace Royalcms\Component\Whoops {
use InvalidArgumentException;
use Royalcms\Component\Whoops\Exception\ErrorException;
use Royalcms\Component\Whoops\Handler\HandlerInterface;
interface RunInterface
{
    const EXCEPTION_HANDLER = "handleException";
    const ERROR_HANDLER = "handleError";
    const SHUTDOWN_HANDLER = "handleShutdown";
    public function pushHandler($handler);
    public function popHandler();
    public function getHandlers();
    public function clearHandlers();
    public function register();
    public function unregister();
    public function allowQuit($exit = null);
    public function silenceErrorsInPaths($patterns, $levels = 10240);
    public function sendHttpCode($code = null);
    public function writeToOutput($send = null);
    public function handleException($exception);
    public function handleError($level, $message, $file = null, $line = null);
    public function handleShutdown();
}
}

namespace Royalcms\Component\Whoops\Handler {
use Royalcms\Component\Whoops\Exception\Inspector;
use Royalcms\Component\Whoops\RunInterface;
interface HandlerInterface
{
    public function handle();
    public function setRun(RunInterface $run);
    public function setException($exception);
    public function setInspector(Inspector $inspector);
}
}

namespace Royalcms\Component\Whoops\Handler {
use Royalcms\Component\Whoops\Exception\Inspector;
use Royalcms\Component\Whoops\RunInterface;
abstract class Handler implements HandlerInterface
{
    const DONE = 0x10;
    const LAST_HANDLER = 0x20;
    const QUIT = 0x30;
    private $run;
    private $inspector;
    private $exception;
    public function setRun(RunInterface $run)
    {
        $this->run = $run;
    }
    protected function getRun()
    {
        return $this->run;
    }
    public function setInspector(Inspector $inspector)
    {
        $this->inspector = $inspector;
    }
    protected function getInspector()
    {
        return $this->inspector;
    }
    public function setException($exception)
    {
        $this->exception = $exception;
    }
    protected function getException()
    {
        return $this->exception;
    }
}
}

namespace Royalcms\Component\Whoops\Handler {
use Royalcms\Component\Whoops\Exception\Formatter;
class JsonResponseHandler extends Handler
{
    private $returnFrames = false;
    private $jsonApi = false;
    public function setJsonApi($jsonApi = false)
    {
        $this->jsonApi = (bool) $jsonApi;
        return $this;
    }
    public function addTraceToOutput($returnFrames = null)
    {
        if (func_num_args() == 0) {
            return $this->returnFrames;
        }
        $this->returnFrames = (bool) $returnFrames;
        return $this;
    }
    public function handle()
    {
        if ($this->jsonApi === true) {
            $response = ['errors' => [Formatter::formatExceptionAsDataArray($this->getInspector(), $this->addTraceToOutput())]];
        } else {
            $response = ['error' => Formatter::formatExceptionAsDataArray($this->getInspector(), $this->addTraceToOutput())];
        }
        echo json_encode($response, defined('JSON_PARTIAL_OUTPUT_ON_ERROR') ? JSON_PARTIAL_OUTPUT_ON_ERROR : 0);
        return Handler::QUIT;
    }
    public function contentType()
    {
        return 'application/json';
    }
}
}

namespace Royalcms\Component\Whoops\Util {
class SystemFacade
{
    public function startOutputBuffering()
    {
        return ob_start();
    }
    public function setErrorHandler(callable $handler, $types = 'use-php-defaults')
    {
        if ($types === 'use-php-defaults') {
            $types = E_ALL | E_STRICT;
        }
        return set_error_handler($handler, $types);
    }
    public function setExceptionHandler(callable $handler)
    {
        return set_exception_handler($handler);
    }
    public function restoreExceptionHandler()
    {
        restore_exception_handler();
    }
    public function restoreErrorHandler()
    {
        restore_error_handler();
    }
    public function registerShutdownFunction(callable $function)
    {
        register_shutdown_function($function);
    }
    public function cleanOutputBuffer()
    {
        return ob_get_clean();
    }
    public function getOutputBufferLevel()
    {
        return ob_get_level();
    }
    public function endOutputBuffering()
    {
        return ob_end_clean();
    }
    public function flushOutputBuffer()
    {
        flush();
    }
    public function getErrorReportingLevel()
    {
        return error_reporting();
    }
    public function getLastError()
    {
        return error_get_last();
    }
    public function setHttpResponseCode($httpCode)
    {
        return http_response_code($httpCode);
    }
    public function stopExecution($exitStatus)
    {
        exit($exitStatus);
    }
}
}

namespace Royalcms\Component\Translation {
use Royalcms\Component\Support\ServiceProvider;
class TranslationServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->registerLoader();
        $this->royalcms->singleton('translator', function ($royalcms) {
            $loader = $royalcms['translation.loader'];
            $locale = $royalcms['config']['system.locale'];
            $items = [];
            if (file_exists($cached = $royalcms->getCachedTranslationPath($locale))) {
                $items = (require $cached);
            }
            $trans = new Translator($loader, $locale, $items);
            $trans->setFallback($royalcms['config']['system.fallback_locale']);
            return $trans;
        });
    }
    protected function registerLoader()
    {
        $this->royalcms->singleton('translation.loader', function ($royalcms) {
            return new FileLoader($royalcms['files'], $royalcms['path.lang']);
        });
    }
    public function provides()
    {
        return ['translator', 'translation.loader'];
    }
}
}

namespace Royalcms\Component\Translation {
use Royalcms\Component\Filesystem\Filesystem;
class FileLoader implements LoaderInterface
{
    protected $files;
    protected $path;
    protected $hints = [];
    public function __construct(Filesystem $files, $path)
    {
        $this->path = $path;
        $this->files = $files;
    }
    public function load($locale, $group, $namespace = null)
    {
        if (is_null($namespace) || $namespace == '*') {
            return $this->loadPath($this->path, $locale, $group);
        }
        return $this->loadNamespaced($locale, $group, $namespace);
    }
    protected function loadNamespaced($locale, $group, $namespace)
    {
        if (isset($this->hints[$namespace])) {
            $lines = $this->loadPath($this->hints[$namespace], $locale, $group);
            return $this->loadNamespaceOverrides($lines, $locale, $group, $namespace);
        }
        return [];
    }
    protected function loadNamespaceOverrides(array $lines, $locale, $group, $namespace)
    {
        $file = "{$this->path}/packages/{$namespace}/{$locale}/{$group}.lang.php";
        if ($this->files->exists($file)) {
            return array_replace_recursive($lines, $this->files->getRequire($file));
        }
        $file = "{$this->path}/packages/{$namespace}/{$locale}/{$group}.php";
        if ($this->files->exists($file)) {
            return array_replace_recursive($lines, $this->files->getRequire($file));
        }
        return $lines;
    }
    protected function loadPath($path, $locale, $group)
    {
        if ($this->files->exists($full = "{$path}/{$locale}/{$group}.lang.php")) {
            return $this->files->getRequire($full);
        } else {
            if ($this->files->exists($full = "{$path}/{$locale}/{$group}.php")) {
                return $this->files->getRequire($full);
            }
        }
        return [];
    }
    public function addNamespace($namespace, $hint)
    {
        $this->hints[$namespace] = $hint;
    }
}
}

namespace Royalcms\Component\Translation {
interface LoaderInterface
{
    public function load($locale, $group, $namespace = null);
    public function addNamespace($namespace, $hint);
}
}

namespace Royalcms\Component\Translation {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Support\NamespacedItemResolver;
use Symfony\Component\Translation\MessageSelector;
use Symfony\Component\Translation\TranslatorInterface;
class Translator extends NamespacedItemResolver implements TranslatorInterface
{
    protected $loader;
    protected $locale;
    protected $fallback;
    protected $loaded = [];
    public function __construct(LoaderInterface $loader, $locale, array $items = [])
    {
        $this->loader = $loader;
        $this->locale = $locale;
        $this->loaded = $items;
    }
    public function hasForLocale($key, $locale = null)
    {
        return $this->has($key, $locale, false);
    }
    public function has($key, $locale = null, $fallback = true)
    {
        return $this->get($key, [], $locale, $fallback) !== $key;
    }
    public function get($key, array $replace = [], $locale = null, $fallback = true)
    {
        list($namespace, $group, $item) = $this->parseKey($key);
        $locales = $fallback ? $this->parseLocale($locale) : [$locale ?: $this->locale];
        foreach ($locales as $locale) {
            $this->load($namespace, $group, $locale);
            $line = $this->getLine($namespace, $group, $locale, $item, $replace);
            if (!is_null($line)) {
                break;
            }
        }
        if (!isset($line)) {
            return $key;
        }
        return $line;
    }
    protected function getLine($namespace, $group, $locale, $item, array $replace)
    {
        $line = Arr::get($this->loaded[$namespace][$group][$locale], $item);
        if (is_string($line)) {
            return $this->makeReplacements($line, $replace);
        } elseif (is_array($line) && count($line) > 0) {
            return $line;
        }
    }
    protected function makeReplacements($line, array $replace)
    {
        $replace = $this->sortReplacements($replace);
        foreach ($replace as $key => $value) {
            $line = str_replace(':' . $key, $value, $line);
        }
        return $line;
    }
    protected function sortReplacements(array $replace)
    {
        return (new Collection($replace))->sortBy(function ($value, $key) {
            return mb_strlen($key) * -1;
        });
    }
    public function choice($key, $number, array $replace = [], $locale = null)
    {
        $line = $this->get($key, $replace, $locale = $locale ?: $this->locale ?: $this->fallback);
        $replace['count'] = $number;
        return $this->makeReplacements($this->getSelector()->choose($line, $number, $locale), $replace);
    }
    public function trans($id, array $parameters = [], $domain = 'messages', $locale = null)
    {
        return $this->get($id, $parameters, $locale);
    }
    public function transChoice($id, $number, array $parameters = [], $domain = 'messages', $locale = null)
    {
        return $this->choice($id, $number, $parameters, $locale);
    }
    public function load($namespace, $group, $locale)
    {
        if ($this->isLoaded($namespace, $group, $locale)) {
            return;
        }
        $lines = $this->loader->load($locale, $group, $namespace);
        $this->loaded[$namespace][$group][$locale] = $lines;
    }
    protected function isLoaded($namespace, $group, $locale)
    {
        return isset($this->loaded[$namespace][$group][$locale]);
    }
    public function addNamespace($namespace, $hint)
    {
        $this->loader->addNamespace($namespace, $hint);
    }
    public function parseKey($key)
    {
        $segments = parent::parseKey($key);
        if (is_null($segments[0])) {
            $segments[0] = '*';
        }
        return $segments;
    }
    protected function parseLocale($locale)
    {
        if (!is_null($locale)) {
            return array_filter([$locale, $this->fallback]);
        }
        return array_filter([$this->locale, $this->fallback]);
    }
    public function getSelector()
    {
        if (!isset($this->selector)) {
            $this->selector = new MessageSelector();
        }
        return $this->selector;
    }
    public function setSelector(MessageSelector $selector)
    {
        $this->selector = $selector;
    }
    public function getLoader()
    {
        return $this->loader;
    }
    public function locale()
    {
        return $this->getLocale();
    }
    public function getLocale()
    {
        return $this->locale;
    }
    public function setLocale($locale)
    {
        $this->locale = $locale;
    }
    public function getFallback()
    {
        return $this->fallback;
    }
    public function setFallback($fallback)
    {
        $this->fallback = $fallback;
    }
    public function all()
    {
        return $this->loaded;
    }
}
}

namespace Royalcms\Component\Translation {
use RC_Config;
use RC_Loader;
trait CompatibleTrait
{
    private static $lang = array();
    private static $packname = array();
    public static function init()
    {
        self::$lang = array();
        self::$packname = array();
    }
    public static function load($file)
    {
        $lang_files = array();
        if (is_array($file)) {
            $lang_files = $file;
        } elseif (is_string($file)) {
            $lang_files = array($file);
        } else {
            return false;
        }
        foreach ($lang_files as $lang_file) {
            $file_arr = array();
            $lang_file_name = $lang_file;
            if (strpos($lang_file, '/')) {
                $file_arr = explode('/', $lang_file);
            }
            if (!empty($file_arr[0])) {
                $m = $file_arr[0];
            }
            if (!empty($file_arr[1])) {
                $lang_file_name = $file_arr[1];
            }
            $m = empty($m) ? ROUTE_M : $m;
            if (empty($m)) {
                continue;
            }
            if ($m != RC_Config::get('system.admin_entrance') && $m != 'system') {
                self::$lang = array_merge(self::$lang, RC_Loader::load_app_lang($lang_file_name, $m));
            } else {
                self::$lang = array_merge(self::$lang, RC_Loader::load_sys_lang($lang_file_name));
            }
            self::$packname[] = $lang_file;
        }
        return self::$lang;
    }
    public static function load_plugin($file)
    {
        $lang_files = array();
        if (is_array($file)) {
            $lang_files = $file;
        } elseif (is_string($file)) {
            $lang_files = array($file);
        } else {
            return false;
        }
        foreach ($lang_files as $lang_file) {
            $file_arr = array();
            $lang_file_name = '';
            if (strpos($lang_file, '/')) {
                $file_arr = explode('/', $lang_file);
            } else {
                $plugin_dir = $lang_file;
            }
            if (!empty($file_arr[0])) {
                $plugin_dir = $file_arr[0];
            }
            if (!empty($file_arr[1])) {
                $lang_file_name = $file_arr[1];
            }
            $lang_file_name = empty($lang_file_name) ? 'plugin' : $lang_file_name;
            if (empty($plugin_dir)) {
                continue;
            }
            self::$lang = array_merge(self::$lang, RC_Loader::load_plugin_lang($lang_file_name, $plugin_dir));
            self::$packname[] = $lang_file;
        }
        return self::$lang;
    }
    public static function load_widget($file)
    {
        $lang_files = array();
        if (is_array($file)) {
            $lang_files = $file;
        } elseif (is_string($file)) {
            $lang_files = array($file);
        } else {
            return false;
        }
        foreach ($lang_files as $lang_file) {
            $file_arr = array();
            $lang_file_name = '';
            if (strpos($lang_file, '/')) {
                $file_arr = explode('/', $lang_file);
            } else {
                $plugin_dir = $lang_file;
            }
            if (!empty($file_arr[0])) {
                $plugin_dir = $file_arr[0];
            }
            if (!empty($file_arr[1])) {
                $lang_file_name = $file_arr[1];
            }
            $lang_file_name = empty($lang_file_name) ? 'widget' : $lang_file_name;
            if (empty($plugin_dir)) {
                continue;
            }
            self::$lang = array_merge(self::$lang, RC_Loader::load_widget_lang($lang_file_name, $plugin_dir));
            self::$packname[] = $lang_file;
        }
        return self::$lang;
    }
    public static function load_theme($file)
    {
        $lang_files = array();
        if (is_array($file)) {
            $lang_files = $file;
        } elseif (is_string($file)) {
            $lang_files = array($file);
        } else {
            return false;
        }
        foreach ($lang_files as $lang_file) {
            $lang_file_name = $lang_file;
            $lang_file_name = empty($lang_file_name) ? 'theme' : $lang_file_name;
            self::$lang = array_merge(self::$lang, RC_Loader::load_theme_lang($lang_file_name));
            self::$packname[] = $lang_file;
        }
        return self::$lang;
    }
    public static function lang($name = null)
    {
        if (is_null($name)) {
            return self::$lang;
        }
        $arr = explode('/', $name);
        $value = '';
        if (count($arr) == 1 && isset(self::$lang[$arr[0]])) {
            $value = self::$lang[$arr[0]];
        } elseif (count($arr) == 2 && is_array(self::$lang[$arr[0]]) && isset(self::$lang[$arr[0]][$arr[1]])) {
            $value = self::$lang[$arr[0]][$arr[1]];
        } elseif (count($arr) == 3 && is_array(self::$lang[$arr[0]][$arr[1]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]])) {
            $value = self::$lang[$arr[0]][$arr[1]][$arr[2]];
        } elseif (count($arr) == 4 && is_array(self::$lang[$arr[0]][$arr[1]][$arr[2]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]])) {
            $value = self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]];
        } elseif (count($arr) == 5 && is_array(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]])) {
            $value = self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]];
        }
        return $value;
    }
    public static function has($name)
    {
        $arr = explode('/', $name);
        $bool = false;
        if (count($arr) == 1 && isset(self::$lang[$arr[0]])) {
            $bool = true;
        } elseif (count($arr) == 2 && is_array(self::$lang[$arr[0]]) && isset(self::$lang[$arr[0]][$arr[1]])) {
            $bool = true;
        } elseif (count($arr) == 3 && is_array(self::$lang[$arr[0]][$arr[1]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]])) {
            $bool = true;
        } elseif (count($arr) == 4 && is_array(self::$lang[$arr[0]][$arr[1]][$arr[2]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]])) {
            $bool = true;
        } elseif (count($arr) == 5 && is_array(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]]) && isset(self::$lang[$arr[0]][$arr[1]][$arr[2]][$arr[3]])) {
            $bool = true;
        }
        return $bool;
    }
}
}

namespace Royalcms\Component\DateTime {
use Closure;
use DateTime;
use DateTimeZone;
use DateInterval;
use DatePeriod;
use InvalidArgumentException;
class Carbon extends DateTime
{
    const SUNDAY = 0;
    const MONDAY = 1;
    const TUESDAY = 2;
    const WEDNESDAY = 3;
    const THURSDAY = 4;
    const FRIDAY = 5;
    const SATURDAY = 6;
    protected static $days = array(self::SUNDAY => 'Sunday', self::MONDAY => 'Monday', self::TUESDAY => 'Tuesday', self::WEDNESDAY => 'Wednesday', self::THURSDAY => 'Thursday', self::FRIDAY => 'Friday', self::SATURDAY => 'Saturday');
    protected static $relativeKeywords = array('this', 'next', 'last', 'tomorrow', 'yesterday', '+', '-', 'first', 'last', 'ago');
    const YEARS_PER_CENTURY = 100;
    const YEARS_PER_DECADE = 10;
    const MONTHS_PER_YEAR = 12;
    const WEEKS_PER_YEAR = 52;
    const DAYS_PER_WEEK = 7;
    const HOURS_PER_DAY = 24;
    const MINUTES_PER_HOUR = 60;
    const SECONDS_PER_MINUTE = 60;
    const DEFAULT_TO_STRING_FORMAT = 'Y-m-d H:i:s';
    protected static $toStringFormat = self::DEFAULT_TO_STRING_FORMAT;
    protected static $testNow;
    protected static function safeCreateDateTimeZone($object)
    {
        if ($object === null) {
            return new DateTimeZone(date_default_timezone_get());
        }
        if ($object instanceof DateTimeZone) {
            return $object;
        }
        $tz = @timezone_open((string) $object);
        if ($tz === false) {
            throw new InvalidArgumentException('Unknown or bad timezone (' . $object . ')');
        }
        return $tz;
    }
    public function __construct($time = null, $tz = null)
    {
        if (static::hasTestNow() && (empty($time) || $time === 'now' || static::hasRelativeKeywords($time))) {
            $testInstance = clone static::getTestNow();
            if (static::hasRelativeKeywords($time)) {
                $testInstance->modify($time);
            }
            if ($tz !== NULL && $tz != static::getTestNow()->tz) {
                $testInstance->setTimezone($tz);
            } else {
                $tz = $testInstance->tz;
            }
            $time = $testInstance->toDateTimeString();
        }
        parent::__construct($time, static::safeCreateDateTimeZone($tz));
    }
    public static function instance(DateTime $dt)
    {
        return new static($dt->format('Y-m-d H:i:s.u'), $dt->getTimeZone());
    }
    public static function parse($time = null, $tz = null)
    {
        return new static($time, $tz);
    }
    public static function now($tz = null)
    {
        return new static(null, $tz);
    }
    public static function today($tz = null)
    {
        return static::now($tz)->startOfDay();
    }
    public static function tomorrow($tz = null)
    {
        return static::today($tz)->addDay();
    }
    public static function yesterday($tz = null)
    {
        return static::today($tz)->subDay();
    }
    public static function maxValue()
    {
        return static::createFromTimestamp(PHP_INT_MAX);
    }
    public static function minValue()
    {
        return static::createFromTimestamp(~PHP_INT_MAX);
    }
    public static function create($year = null, $month = null, $day = null, $hour = null, $minute = null, $second = null, $tz = null)
    {
        $year = $year === null ? date('Y') : $year;
        $month = $month === null ? date('n') : $month;
        $day = $day === null ? date('j') : $day;
        if ($hour === null) {
            $hour = date('G');
            $minute = $minute === null ? date('i') : $minute;
            $second = $second === null ? date('s') : $second;
        } else {
            $minute = $minute === null ? 0 : $minute;
            $second = $second === null ? 0 : $second;
        }
        return static::createFromFormat('Y-n-j G:i:s', sprintf('%s-%s-%s %s:%02s:%02s', $year, $month, $day, $hour, $minute, $second), $tz);
    }
    public static function createFromDate($year = null, $month = null, $day = null, $tz = null)
    {
        return static::create($year, $month, $day, null, null, null, $tz);
    }
    public static function createFromTime($hour = null, $minute = null, $second = null, $tz = null)
    {
        return static::create(null, null, null, $hour, $minute, $second, $tz);
    }
    public static function createFromFormat($format, $time, $tz = null)
    {
        if ($tz !== null) {
            $dt = parent::createFromFormat($format, $time, static::safeCreateDateTimeZone($tz));
        } else {
            $dt = parent::createFromFormat($format, $time);
        }
        if ($dt instanceof DateTime) {
            return static::instance($dt);
        }
        $errors = static::getLastErrors();
        throw new InvalidArgumentException(implode(PHP_EOL, $errors['errors']));
    }
    public static function createFromTimestamp($timestamp, $tz = null)
    {
        return static::now($tz)->setTimestamp($timestamp);
    }
    public static function createFromTimestampUTC($timestamp)
    {
        return new static('@' . $timestamp);
    }
    public function copy()
    {
        return static::instance($this);
    }
    public function __get($name)
    {
        switch (true) {
            case array_key_exists($name, $formats = array('year' => 'Y', 'yearIso' => 'o', 'month' => 'n', 'day' => 'j', 'hour' => 'G', 'minute' => 'i', 'second' => 's', 'micro' => 'u', 'dayOfWeek' => 'w', 'dayOfYear' => 'z', 'weekOfYear' => 'W', 'daysInMonth' => 't', 'timestamp' => 'U')):
                return (int) $this->format($formats[$name]);
            case $name === 'weekOfMonth':
                return (int) ceil($this->day / static::DAYS_PER_WEEK);
            case $name === 'age':
                return (int) $this->diffInYears();
            case $name === 'quarter':
                return (int) ceil($this->month / 3);
            case $name === 'offset':
                return $this->getOffset();
            case $name === 'offsetHours':
                return $this->getOffset() / static::SECONDS_PER_MINUTE / static::MINUTES_PER_HOUR;
            case $name === 'dst':
                return $this->format('I') == '1';
            case $name === 'local':
                return $this->offset == $this->copy()->setTimezone(date_default_timezone_get())->offset;
            case $name === 'utc':
                return $this->offset == 0;
            case $name === 'timezone' || $name === 'tz':
                return $this->getTimezone();
            case $name === 'timezoneName' || $name === 'tzName':
                return $this->getTimezone()->getName();
            default:
                throw new InvalidArgumentException(sprintf("Unknown getter '%s'", $name));
        }
    }
    public function __isset($name)
    {
        try {
            $this->__get($name);
        } catch (InvalidArgumentException $e) {
            return false;
        }
        return true;
    }
    public function __set($name, $value)
    {
        switch ($name) {
            case 'year':
                $this->setDate($value, $this->month, $this->day);
                break;
            case 'month':
                $this->setDate($this->year, $value, $this->day);
                break;
            case 'day':
                $this->setDate($this->year, $this->month, $value);
                break;
            case 'hour':
                $this->setTime($value, $this->minute, $this->second);
                break;
            case 'minute':
                $this->setTime($this->hour, $value, $this->second);
                break;
            case 'second':
                $this->setTime($this->hour, $this->minute, $value);
                break;
            case 'timestamp':
                parent::setTimestamp($value);
                break;
            case 'timezone':
            case 'tz':
                $this->setTimezone($value);
                break;
            default:
                throw new InvalidArgumentException(sprintf("Unknown setter '%s'", $name));
        }
    }
    public function year($value)
    {
        $this->year = $value;
        return $this;
    }
    public function month($value)
    {
        $this->month = $value;
        return $this;
    }
    public function day($value)
    {
        $this->day = $value;
        return $this;
    }
    public function hour($value)
    {
        $this->hour = $value;
        return $this;
    }
    public function minute($value)
    {
        $this->minute = $value;
        return $this;
    }
    public function second($value)
    {
        $this->second = $value;
        return $this;
    }
    public function setDateTime($year, $month, $day, $hour, $minute, $second = 0)
    {
        return $this->setDate($year, $month, $day)->setTime($hour, $minute, $second);
    }
    public function timestamp($value)
    {
        $this->timestamp = $value;
        return $this;
    }
    public function timezone($value)
    {
        return $this->setTimezone($value);
    }
    public function tz($value)
    {
        return $this->setTimezone($value);
    }
    public function setTimezone($value)
    {
        parent::setTimezone(static::safeCreateDateTimeZone($value));
        return $this;
    }
    public static function setTestNow(Carbon $testNow = null)
    {
        static::$testNow = $testNow;
    }
    public static function getTestNow()
    {
        return static::$testNow;
    }
    public static function hasTestNow()
    {
        return static::getTestNow() !== null;
    }
    public static function hasRelativeKeywords($time)
    {
        if (preg_match('/[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}/', $time) !== 1) {
            foreach (static::$relativeKeywords as $keyword) {
                if (stripos($time, $keyword) !== false) {
                    return true;
                }
            }
        }
        return false;
    }
    public function formatLocalized($format)
    {
        if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
            $format = preg_replace('#(?<!%)((?:%%)*)%e#', '\\1%#d', $format);
        }
        return strftime($format, strtotime($this));
    }
    public static function resetToStringFormat()
    {
        static::setToStringFormat(static::DEFAULT_TO_STRING_FORMAT);
    }
    public static function setToStringFormat($format)
    {
        static::$toStringFormat = $format;
    }
    public function __toString()
    {
        return $this->format(static::$toStringFormat);
    }
    public function toDateString()
    {
        return $this->format('Y-m-d');
    }
    public function toFormattedDateString()
    {
        return $this->format('M j, Y');
    }
    public function toTimeString()
    {
        return $this->format('H:i:s');
    }
    public function toDateTimeString()
    {
        return $this->format('Y-m-d H:i:s');
    }
    public function toDayDateTimeString()
    {
        return $this->format('D, M j, Y g:i A');
    }
    public function toAtomString()
    {
        return $this->format(static::ATOM);
    }
    public function toCookieString()
    {
        return $this->format(static::COOKIE);
    }
    public function toIso8601String()
    {
        return $this->format(static::ISO8601);
    }
    public function toRfc822String()
    {
        return $this->format(static::RFC822);
    }
    public function toRfc850String()
    {
        return $this->format(static::RFC850);
    }
    public function toRfc1036String()
    {
        return $this->format(static::RFC1036);
    }
    public function toRfc1123String()
    {
        return $this->format(static::RFC1123);
    }
    public function toRfc2822String()
    {
        return $this->format(static::RFC2822);
    }
    public function toRfc3339String()
    {
        return $this->format(static::RFC3339);
    }
    public function toRssString()
    {
        return $this->format(static::RSS);
    }
    public function toW3cString()
    {
        return $this->format(static::W3C);
    }
    public function eq(Carbon $dt)
    {
        return $this == $dt;
    }
    public function ne(Carbon $dt)
    {
        return !$this->eq($dt);
    }
    public function gt(Carbon $dt)
    {
        return $this > $dt;
    }
    public function gte(Carbon $dt)
    {
        return $this >= $dt;
    }
    public function lt(Carbon $dt)
    {
        return $this < $dt;
    }
    public function lte(Carbon $dt)
    {
        return $this <= $dt;
    }
    public function between(Carbon $dt1, Carbon $dt2, $equal = true)
    {
        if ($dt1->gt($dt2)) {
            $temp = $dt1;
            $dt1 = $dt2;
            $dt2 = $temp;
        }
        if ($equal) {
            return $this->gte($dt1) && $this->lte($dt2);
        } else {
            return $this->gt($dt1) && $this->lt($dt2);
        }
    }
    public function min(Carbon $dt = null)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return $this->lt($dt) ? $this : $dt;
    }
    public function max(Carbon $dt = null)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return $this->gt($dt) ? $this : $dt;
    }
    public function isWeekday()
    {
        return $this->dayOfWeek != static::SUNDAY && $this->dayOfWeek != static::SATURDAY;
    }
    public function isWeekend()
    {
        return !$this->isWeekDay();
    }
    public function isYesterday()
    {
        return $this->toDateString() === static::yesterday($this->tz)->toDateString();
    }
    public function isToday()
    {
        return $this->toDateString() === static::now($this->tz)->toDateString();
    }
    public function isTomorrow()
    {
        return $this->toDateString() === static::tomorrow($this->tz)->toDateString();
    }
    public function isFuture()
    {
        return $this->gt(static::now($this->tz));
    }
    public function isPast()
    {
        return $this->lt(static::now($this->tz));
    }
    public function isLeapYear()
    {
        return $this->format('L') == '1';
    }
    public function isSameDay(Carbon $dt)
    {
        return $this->toDateString() === $dt->toDateString();
    }
    public function addYears($value)
    {
        return $this->modify((int) $value . ' year');
    }
    public function addYear()
    {
        return $this->addYears(1);
    }
    public function subYear()
    {
        return $this->addYears(-1);
    }
    public function subYears($value)
    {
        return $this->addYears(-1 * $value);
    }
    public function addMonths($value)
    {
        return $this->modify((int) $value . ' month');
    }
    public function addMonth()
    {
        return $this->addMonths(1);
    }
    public function subMonth()
    {
        return $this->addMonths(-1);
    }
    public function subMonths($value)
    {
        return $this->addMonths(-1 * $value);
    }
    public function addMonthsNoOverflow($value)
    {
        $date = $this->copy()->addMonths($value);
        if ($date->day != $this->day) {
            $date->day(1)->subMonth()->day($date->daysInMonth);
        }
        return $date;
    }
    public function addMonthNoOverflow()
    {
        return $this->addMonthsNoOverflow(1);
    }
    public function subMonthNoOverflow()
    {
        return $this->addMonthsNoOverflow(-1);
    }
    public function subMonthsNoOverflow($value)
    {
        return $this->addMonthsNoOverflow(-1 * $value);
    }
    public function addDays($value)
    {
        return $this->modify((int) $value . ' day');
    }
    public function addDay()
    {
        return $this->addDays(1);
    }
    public function subDay()
    {
        return $this->addDays(-1);
    }
    public function subDays($value)
    {
        return $this->addDays(-1 * $value);
    }
    public function addWeekdays($value)
    {
        return $this->modify((int) $value . ' weekday');
    }
    public function addWeekday()
    {
        return $this->addWeekdays(1);
    }
    public function subWeekday()
    {
        return $this->addWeekdays(-1);
    }
    public function subWeekdays($value)
    {
        return $this->addWeekdays(-1 * $value);
    }
    public function addWeeks($value)
    {
        return $this->modify((int) $value . ' week');
    }
    public function addWeek()
    {
        return $this->addWeeks(1);
    }
    public function subWeek()
    {
        return $this->addWeeks(-1);
    }
    public function subWeeks($value)
    {
        return $this->addWeeks(-1 * $value);
    }
    public function addHours($value)
    {
        return $this->modify((int) $value . ' hour');
    }
    public function addHour()
    {
        return $this->addHours(1);
    }
    public function subHour()
    {
        return $this->addHours(-1);
    }
    public function subHours($value)
    {
        return $this->addHours(-1 * $value);
    }
    public function addMinutes($value)
    {
        return $this->modify((int) $value . ' minute');
    }
    public function addMinute()
    {
        return $this->addMinutes(1);
    }
    public function subMinute()
    {
        return $this->addMinutes(-1);
    }
    public function subMinutes($value)
    {
        return $this->addMinutes(-1 * $value);
    }
    public function addSeconds($value)
    {
        return $this->modify((int) $value . ' second');
    }
    public function addSecond()
    {
        return $this->addSeconds(1);
    }
    public function subSecond()
    {
        return $this->addSeconds(-1);
    }
    public function subSeconds($value)
    {
        return $this->addSeconds(-1 * $value);
    }
    public function diffInYears(Carbon $dt = null, $abs = true)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return (int) $this->diff($dt, $abs)->format('%r%y');
    }
    public function diffInMonths(Carbon $dt = null, $abs = true)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return $this->diffInYears($dt, $abs) * static::MONTHS_PER_YEAR + $this->diff($dt, $abs)->format('%r%m');
    }
    public function diffInWeeks(Carbon $dt = null, $abs = true)
    {
        return (int) ($this->diffInDays($dt, $abs) / static::DAYS_PER_WEEK);
    }
    public function diffInDays(Carbon $dt = null, $abs = true)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return (int) $this->diff($dt, $abs)->format('%r%a');
    }
    public function diffInDaysFiltered(Closure $callback, Carbon $dt = null, $abs = true)
    {
        $start = $this;
        $end = $dt === null ? static::now($this->tz) : $dt;
        $inverse = false;
        if ($end < $start) {
            $start = $end;
            $end = $this;
            $inverse = true;
        }
        $period = new DatePeriod($start, new DateInterval('P1D'), $end);
        $days = array_filter(iterator_to_array($period), function (DateTime $date) use($callback) {
            return call_user_func($callback, Carbon::instance($date));
        });
        $diff = count($days);
        return $inverse && !$abs ? -$diff : $diff;
    }
    public function diffInWeekdays(Carbon $dt = null, $abs = true)
    {
        return $this->diffInDaysFiltered(function (Carbon $date) {
            return $date->isWeekday();
        }, $dt, $abs);
    }
    public function diffInWeekendDays(Carbon $dt = null, $abs = true)
    {
        return $this->diffInDaysFiltered(function (Carbon $date) {
            return $date->isWeekend();
        }, $dt, $abs);
    }
    public function diffInHours(Carbon $dt = null, $abs = true)
    {
        return (int) ($this->diffInSeconds($dt, $abs) / static::SECONDS_PER_MINUTE / static::MINUTES_PER_HOUR);
    }
    public function diffInMinutes(Carbon $dt = null, $abs = true)
    {
        return (int) ($this->diffInSeconds($dt, $abs) / static::SECONDS_PER_MINUTE);
    }
    public function diffInSeconds(Carbon $dt = null, $abs = true)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        $value = $dt->getTimestamp() - $this->getTimestamp();
        return $abs ? abs($value) : $value;
    }
    public function secondsSinceMidnight()
    {
        return $this->diffInSeconds($this->copy()->startOfDay());
    }
    public function secondsUntilEndOfDay()
    {
        return $this->diffInSeconds($this->copy()->endOfDay());
    }
    public function diffForHumans(Carbon $other = null, $absolute = false)
    {
        $isNow = $other === null;
        if ($isNow) {
            $other = static::now($this->tz);
        }
        $diffInterval = $this->diff($other);
        switch (true) {
            case $diffInterval->y > 0:
                $unit = 'year';
                $delta = $diffInterval->y;
                break;
            case $diffInterval->m > 0:
                $unit = 'month';
                $delta = $diffInterval->m;
                break;
            case $diffInterval->d > 0:
                $unit = 'day';
                $delta = $diffInterval->d;
                if ($delta >= self::DAYS_PER_WEEK) {
                    $unit = 'week';
                    $delta = floor($delta / self::DAYS_PER_WEEK);
                }
                break;
            case $diffInterval->h > 0:
                $unit = 'hour';
                $delta = $diffInterval->h;
                break;
            case $diffInterval->i > 0:
                $unit = 'minute';
                $delta = $diffInterval->i;
                break;
            default:
                $delta = $diffInterval->s;
                $unit = 'second';
                break;
        }
        if ($delta == 0) {
            $delta = 1;
        }
        $txt = $delta . ' ' . $unit;
        $txt .= $delta == 1 ? '' : 's';
        if ($absolute) {
            return $txt;
        }
        $isFuture = $diffInterval->invert === 1;
        if ($isNow) {
            if ($isFuture) {
                return $txt . ' from now';
            }
            return $txt . ' ago';
        }
        if ($isFuture) {
            return $txt . ' after';
        }
        return $txt . ' before';
    }
    public function startOfDay()
    {
        return $this->hour(0)->minute(0)->second(0);
    }
    public function endOfDay()
    {
        return $this->hour(23)->minute(59)->second(59);
    }
    public function startOfMonth()
    {
        return $this->startOfDay()->day(1);
    }
    public function endOfMonth()
    {
        return $this->day($this->daysInMonth)->endOfDay();
    }
    public function startOfYear()
    {
        return $this->month(1)->startOfMonth();
    }
    public function endOfYear()
    {
        return $this->month(static::MONTHS_PER_YEAR)->endOfMonth();
    }
    public function startOfDecade()
    {
        return $this->startOfYear()->year($this->year - $this->year % static::YEARS_PER_DECADE);
    }
    public function endOfDecade()
    {
        return $this->endOfYear()->year($this->year - $this->year % static::YEARS_PER_DECADE + static::YEARS_PER_DECADE - 1);
    }
    public function startOfCentury()
    {
        return $this->startOfYear()->year($this->year - $this->year % static::YEARS_PER_CENTURY);
    }
    public function endOfCentury()
    {
        return $this->endOfYear()->year($this->year - $this->year % static::YEARS_PER_CENTURY + static::YEARS_PER_CENTURY - 1);
    }
    public function startOfWeek()
    {
        if ($this->dayOfWeek != static::MONDAY) {
            $this->previous(static::MONDAY);
        }
        return $this->startOfDay();
    }
    public function endOfWeek()
    {
        if ($this->dayOfWeek != static::SUNDAY) {
            $this->next(static::SUNDAY);
        }
        return $this->endOfDay();
    }
    public function next($dayOfWeek = null)
    {
        if ($dayOfWeek === null) {
            $dayOfWeek = $this->dayOfWeek;
        }
        return $this->startOfDay()->modify('next ' . static::$days[$dayOfWeek]);
    }
    public function previous($dayOfWeek = null)
    {
        if ($dayOfWeek === null) {
            $dayOfWeek = $this->dayOfWeek;
        }
        return $this->startOfDay()->modify('last ' . static::$days[$dayOfWeek]);
    }
    public function firstOfMonth($dayOfWeek = null)
    {
        $this->startOfDay();
        if ($dayOfWeek === null) {
            return $this->day(1);
        }
        return $this->modify('first ' . static::$days[$dayOfWeek] . ' of ' . $this->format('F') . ' ' . $this->year);
    }
    public function lastOfMonth($dayOfWeek = null)
    {
        $this->startOfDay();
        if ($dayOfWeek === null) {
            return $this->day($this->daysInMonth);
        }
        return $this->modify('last ' . static::$days[$dayOfWeek] . ' of ' . $this->format('F') . ' ' . $this->year);
    }
    public function nthOfMonth($nth, $dayOfWeek)
    {
        $dt = $this->copy()->firstOfMonth();
        $check = $dt->format('Y-m');
        $dt->modify('+' . $nth . ' ' . static::$days[$dayOfWeek]);
        return $dt->format('Y-m') === $check ? $this->modify($dt) : false;
    }
    public function firstOfQuarter($dayOfWeek = null)
    {
        return $this->day(1)->month($this->quarter * 3 - 2)->firstOfMonth($dayOfWeek);
    }
    public function lastOfQuarter($dayOfWeek = null)
    {
        return $this->day(1)->month($this->quarter * 3)->lastOfMonth($dayOfWeek);
    }
    public function nthOfQuarter($nth, $dayOfWeek)
    {
        $dt = $this->copy()->day(1)->month($this->quarter * 3);
        $last_month = $dt->month;
        $year = $dt->year;
        $dt->firstOfQuarter()->modify('+' . $nth . ' ' . static::$days[$dayOfWeek]);
        return $last_month < $dt->month || $year !== $dt->year ? false : $this->modify($dt);
    }
    public function firstOfYear($dayOfWeek = null)
    {
        return $this->month(1)->firstOfMonth($dayOfWeek);
    }
    public function lastOfYear($dayOfWeek = null)
    {
        return $this->month(static::MONTHS_PER_YEAR)->lastOfMonth($dayOfWeek);
    }
    public function nthOfYear($nth, $dayOfWeek)
    {
        $dt = $this->copy()->firstOfYear()->modify('+' . $nth . ' ' . static::$days[$dayOfWeek]);
        return $this->year == $dt->year ? $this->modify($dt) : false;
    }
    public function average(Carbon $dt = null)
    {
        $dt = $dt === null ? static::now($this->tz) : $dt;
        return $this->addSeconds((int) ($this->diffInSeconds($dt, false) / 2));
    }
    public function isBirthday(Carbon $dt)
    {
        return $this->format('md') === $dt->format('md');
    }
}
}

namespace Royalcms\Component\Console {
use Royalcms\Component\Contracts\Support\Arrayable;
use Symfony\Component\Console\Helper\Table;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Question\Question;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;
use Symfony\Component\Console\Command\Command as SymfonyCommand;
use Royalcms\Component\Contracts\Foundation\Royalcms as FoundationRoyalcms;
class Command extends SymfonyCommand
{
    protected $royalcms;
    protected $input;
    protected $output;
    protected $signature;
    protected $name;
    protected $description;
    public function __construct()
    {
        if (isset($this->signature)) {
            $this->configureUsingFluentDefinition();
        } else {
            parent::__construct($this->name);
        }
        $this->setDescription($this->description);
        if (!isset($this->signature)) {
            $this->specifyParameters();
        }
    }
    protected function configureUsingFluentDefinition()
    {
        list($name, $arguments, $options) = Parser::parse($this->signature);
        parent::__construct($name);
        foreach ($arguments as $argument) {
            $this->getDefinition()->addArgument($argument);
        }
        foreach ($options as $option) {
            $this->getDefinition()->addOption($option);
        }
    }
    protected function specifyParameters()
    {
        foreach ($this->getArguments() as $arguments) {
            call_user_func_array([$this, 'addArgument'], $arguments);
        }
        foreach ($this->getOptions() as $options) {
            call_user_func_array([$this, 'addOption'], $options);
        }
    }
    public function run(InputInterface $input, OutputInterface $output)
    {
        $this->input = $input;
        $this->output = new OutputStyle($input, $output);
        return parent::run($input, $output);
    }
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $method = method_exists($this, 'handle') ? 'handle' : 'fire';
        return $this->royalcms->call([$this, $method]);
    }
    public function call($command, array $arguments = [])
    {
        $instance = $this->getApplication()->find($command);
        $arguments['command'] = $command;
        return $instance->run(new ArrayInput($arguments), $this->output);
    }
    public function callSilent($command, array $arguments = [])
    {
        $instance = $this->getApplication()->find($command);
        $arguments['command'] = $command;
        return $instance->run(new ArrayInput($arguments), new NullOutput());
    }
    public function argument($key = null)
    {
        if (is_null($key)) {
            return $this->input->getArguments();
        }
        return $this->input->getArgument($key);
    }
    public function option($key = null)
    {
        if (is_null($key)) {
            return $this->input->getOptions();
        }
        return $this->input->getOption($key);
    }
    public function confirm($question, $default = false)
    {
        return $this->output->confirm($question, $default);
    }
    public function ask($question, $default = null)
    {
        return $this->output->ask($question, $default);
    }
    public function anticipate($question, array $choices, $default = null)
    {
        return $this->askWithCompletion($question, $choices, $default);
    }
    public function askWithCompletion($question, array $choices, $default = null)
    {
        $question = new Question($question, $default);
        $question->setAutocompleterValues($choices);
        return $this->output->askQuestion($question);
    }
    public function secret($question, $fallback = true)
    {
        $question = new Question($question);
        $question->setHidden(true)->setHiddenFallback($fallback);
        return $this->output->askQuestion($question);
    }
    public function choice($question, array $choices, $default = null, $attempts = null, $multiple = null)
    {
        $question = new ChoiceQuestion($question, $choices, $default);
        $question->setMaxAttempts($attempts)->setMultiselect($multiple);
        return $this->output->askQuestion($question);
    }
    public function table(array $headers, $rows, $style = 'default')
    {
        $table = new Table($this->output);
        if ($rows instanceof Arrayable) {
            $rows = $rows->toArray();
        }
        $table->setHeaders($headers)->setRows($rows)->setStyle($style)->render();
    }
    public function info($string)
    {
        $this->output->writeln("<info>{$string}</info>");
    }
    public function line($string)
    {
        $this->output->writeln($string);
    }
    public function comment($string)
    {
        $this->output->writeln("<comment>{$string}</comment>");
    }
    public function question($string)
    {
        $this->output->writeln("<question>{$string}</question>");
    }
    public function error($string)
    {
        $this->output->writeln("<error>{$string}</error>");
    }
    public function warn($string)
    {
        if (!$this->output->getFormatter()->hasStyle('warning')) {
            $style = new OutputFormatterStyle('yellow');
            $this->output->getFormatter()->setStyle('warning', $style);
        }
        $this->output->writeln("<warning>{$string}</warning>");
    }
    protected function getArguments()
    {
        return [];
    }
    protected function getOptions()
    {
        return [];
    }
    public function getOutput()
    {
        return $this->output;
    }
    public function getRoyalcms()
    {
        return $this->royalcms;
    }
    public function setRoyalcms(FoundationRoyalcms $royalcms)
    {
        $this->royalcms = $royalcms;
    }
}
}

namespace Psr\Log {
interface LoggerInterface
{
    public function emergency($message, array $context = array());
    public function alert($message, array $context = array());
    public function critical($message, array $context = array());
    public function error($message, array $context = array());
    public function warning($message, array $context = array());
    public function notice($message, array $context = array());
    public function info($message, array $context = array());
    public function debug($message, array $context = array());
    public function log($level, $message, array $context = array());
}
}

namespace Monolog {
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\StreamHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\InvalidArgumentException;
class Logger implements LoggerInterface
{
    const DEBUG = 100;
    const INFO = 200;
    const NOTICE = 250;
    const WARNING = 300;
    const ERROR = 400;
    const CRITICAL = 500;
    const ALERT = 550;
    const EMERGENCY = 600;
    const API = 1;
    protected static $levels = array(self::DEBUG => 'DEBUG', self::INFO => 'INFO', self::NOTICE => 'NOTICE', self::WARNING => 'WARNING', self::ERROR => 'ERROR', self::CRITICAL => 'CRITICAL', self::ALERT => 'ALERT', self::EMERGENCY => 'EMERGENCY');
    protected static $timezone;
    protected $name;
    protected $handlers;
    protected $processors;
    protected $microsecondTimestamps = true;
    public function __construct($name, array $handlers = array(), array $processors = array())
    {
        $this->name = $name;
        $this->handlers = $handlers;
        $this->processors = $processors;
    }
    public function getName()
    {
        return $this->name;
    }
    public function withName($name)
    {
        $new = clone $this;
        $new->name = $name;
        return $new;
    }
    public function pushHandler(HandlerInterface $handler)
    {
        array_unshift($this->handlers, $handler);
        return $this;
    }
    public function popHandler()
    {
        if (!$this->handlers) {
            throw new \LogicException('You tried to pop from an empty handler stack.');
        }
        return array_shift($this->handlers);
    }
    public function setHandlers(array $handlers)
    {
        $this->handlers = array();
        foreach (array_reverse($handlers) as $handler) {
            $this->pushHandler($handler);
        }
        return $this;
    }
    public function getHandlers()
    {
        return $this->handlers;
    }
    public function pushProcessor($callback)
    {
        if (!is_callable($callback)) {
            throw new \InvalidArgumentException('Processors must be valid callables (callback or object with an __invoke method), ' . var_export($callback, true) . ' given');
        }
        array_unshift($this->processors, $callback);
        return $this;
    }
    public function popProcessor()
    {
        if (!$this->processors) {
            throw new \LogicException('You tried to pop from an empty processor stack.');
        }
        return array_shift($this->processors);
    }
    public function getProcessors()
    {
        return $this->processors;
    }
    public function useMicrosecondTimestamps($micro)
    {
        $this->microsecondTimestamps = (bool) $micro;
    }
    public function addRecord($level, $message, array $context = array())
    {
        if (!$this->handlers) {
            $this->pushHandler(new StreamHandler('php://stderr', static::DEBUG));
        }
        $levelName = static::getLevelName($level);
        $handlerKey = null;
        reset($this->handlers);
        while ($handler = current($this->handlers)) {
            if ($handler->isHandling(array('level' => $level))) {
                $handlerKey = key($this->handlers);
                break;
            }
            next($this->handlers);
        }
        if (null === $handlerKey) {
            return false;
        }
        if (!static::$timezone) {
            static::$timezone = new \DateTimeZone(date_default_timezone_get() ?: 'UTC');
        }
        if ($this->microsecondTimestamps) {
            $ts = \DateTime::createFromFormat('U.u', sprintf('%.6F', microtime(true)), static::$timezone);
        } else {
            $ts = new \DateTime(null, static::$timezone);
        }
        $ts->setTimezone(static::$timezone);
        $record = array('message' => (string) $message, 'context' => $context, 'level' => $level, 'level_name' => $levelName, 'channel' => $this->name, 'datetime' => $ts, 'extra' => array());
        foreach ($this->processors as $processor) {
            $record = call_user_func($processor, $record);
        }
        while ($handler = current($this->handlers)) {
            if (true === $handler->handle($record)) {
                break;
            }
            next($this->handlers);
        }
        return true;
    }
    public function addDebug($message, array $context = array())
    {
        return $this->addRecord(static::DEBUG, $message, $context);
    }
    public function addInfo($message, array $context = array())
    {
        return $this->addRecord(static::INFO, $message, $context);
    }
    public function addNotice($message, array $context = array())
    {
        return $this->addRecord(static::NOTICE, $message, $context);
    }
    public function addWarning($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    public function addError($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    public function addCritical($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    public function addAlert($message, array $context = array())
    {
        return $this->addRecord(static::ALERT, $message, $context);
    }
    public function addEmergency($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
    public static function getLevels()
    {
        return array_flip(static::$levels);
    }
    public static function getLevelName($level)
    {
        if (!isset(static::$levels[$level])) {
            throw new InvalidArgumentException('Level "' . $level . '" is not defined, use one of: ' . implode(', ', array_keys(static::$levels)));
        }
        return static::$levels[$level];
    }
    public static function toMonologLevel($level)
    {
        if (is_string($level) && defined(__CLASS__ . '::' . strtoupper($level))) {
            return constant(__CLASS__ . '::' . strtoupper($level));
        }
        return $level;
    }
    public function isHandling($level)
    {
        $record = array('level' => $level);
        foreach ($this->handlers as $handler) {
            if ($handler->isHandling($record)) {
                return true;
            }
        }
        return false;
    }
    public function log($level, $message, array $context = array())
    {
        $level = static::toMonologLevel($level);
        return $this->addRecord($level, $message, $context);
    }
    public function debug($message, array $context = array())
    {
        return $this->addRecord(static::DEBUG, $message, $context);
    }
    public function info($message, array $context = array())
    {
        return $this->addRecord(static::INFO, $message, $context);
    }
    public function notice($message, array $context = array())
    {
        return $this->addRecord(static::NOTICE, $message, $context);
    }
    public function warn($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    public function warning($message, array $context = array())
    {
        return $this->addRecord(static::WARNING, $message, $context);
    }
    public function err($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    public function error($message, array $context = array())
    {
        return $this->addRecord(static::ERROR, $message, $context);
    }
    public function crit($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    public function critical($message, array $context = array())
    {
        return $this->addRecord(static::CRITICAL, $message, $context);
    }
    public function alert($message, array $context = array())
    {
        return $this->addRecord(static::ALERT, $message, $context);
    }
    public function emerg($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
    public function emergency($message, array $context = array())
    {
        return $this->addRecord(static::EMERGENCY, $message, $context);
    }
    public static function setTimezone(\DateTimeZone $tz)
    {
        self::$timezone = $tz;
    }
}
}

namespace Monolog\Handler {
use Monolog\Logger;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\LineFormatter;
abstract class AbstractHandler implements HandlerInterface
{
    protected $level = Logger::DEBUG;
    protected $bubble = true;
    protected $formatter;
    protected $processors = array();
    public function __construct($level = Logger::DEBUG, $bubble = true)
    {
        $this->setLevel($level);
        $this->bubble = $bubble;
    }
    public function isHandling(array $record)
    {
        return $record['level'] >= $this->level;
    }
    public function handleBatch(array $records)
    {
        foreach ($records as $record) {
            $this->handle($record);
        }
    }
    public function close()
    {
    }
    public function pushProcessor($callback)
    {
        if (!is_callable($callback)) {
            throw new \InvalidArgumentException('Processors must be valid callables (callback or object with an __invoke method), ' . var_export($callback, true) . ' given');
        }
        array_unshift($this->processors, $callback);
        return $this;
    }
    public function popProcessor()
    {
        if (!$this->processors) {
            throw new \LogicException('You tried to pop from an empty processor stack.');
        }
        return array_shift($this->processors);
    }
    public function setFormatter(FormatterInterface $formatter)
    {
        $this->formatter = $formatter;
        return $this;
    }
    public function getFormatter()
    {
        if (!$this->formatter) {
            $this->formatter = $this->getDefaultFormatter();
        }
        return $this->formatter;
    }
    public function setLevel($level)
    {
        $this->level = Logger::toMonologLevel($level);
        return $this;
    }
    public function getLevel()
    {
        return $this->level;
    }
    public function setBubble($bubble)
    {
        $this->bubble = $bubble;
        return $this;
    }
    public function getBubble()
    {
        return $this->bubble;
    }
    public function __destruct()
    {
        try {
            $this->close();
        } catch (\Exception $e) {
        } catch (\Throwable $e) {
        }
    }
    protected function getDefaultFormatter()
    {
        return new LineFormatter();
    }
}
}

namespace Monolog\Handler {
abstract class AbstractProcessingHandler extends AbstractHandler
{
    public function handle(array $record)
    {
        if (!$this->isHandling($record)) {
            return false;
        }
        $record = $this->processRecord($record);
        $record['formatted'] = $this->getFormatter()->format($record);
        $this->write($record);
        return false === $this->bubble;
    }
    protected abstract function write(array $record);
    protected function processRecord(array $record)
    {
        if ($this->processors) {
            foreach ($this->processors as $processor) {
                $record = call_user_func($processor, $record);
            }
        }
        return $record;
    }
}
}

namespace Monolog\Handler {
use Monolog\Logger;
class StreamHandler extends AbstractProcessingHandler
{
    protected $stream;
    protected $url;
    private $errorMessage;
    protected $filePermission;
    protected $useLocking;
    private $dirCreated;
    public function __construct($stream, $level = Logger::DEBUG, $bubble = true, $filePermission = null, $useLocking = false)
    {
        parent::__construct($level, $bubble);
        if (is_resource($stream)) {
            $this->stream = $stream;
        } elseif (is_string($stream)) {
            $this->url = $stream;
        } else {
            throw new \InvalidArgumentException('A stream must either be a resource or a string.');
        }
        $this->filePermission = $filePermission;
        $this->useLocking = $useLocking;
    }
    public function close()
    {
        if ($this->url && is_resource($this->stream)) {
            fclose($this->stream);
        }
        $this->stream = null;
    }
    public function getStream()
    {
        return $this->stream;
    }
    public function getUrl()
    {
        return $this->url;
    }
    protected function write(array $record)
    {
        if (!is_resource($this->stream)) {
            if (null === $this->url || '' === $this->url) {
                throw new \LogicException('Missing stream url, the stream can not be opened. This may be caused by a premature call to close().');
            }
            $this->createDir();
            $this->errorMessage = null;
            set_error_handler(array($this, 'customErrorHandler'));
            $this->stream = fopen($this->url, 'a');
            if ($this->filePermission !== null) {
                @chmod($this->url, $this->filePermission);
            }
            restore_error_handler();
            if (!is_resource($this->stream)) {
                $this->stream = null;
                throw new \UnexpectedValueException(sprintf('The stream or file "%s" could not be opened: ' . $this->errorMessage, $this->url));
            }
        }
        if ($this->useLocking) {
            flock($this->stream, LOCK_EX);
        }
        fwrite($this->stream, (string) $record['formatted']);
        if ($this->useLocking) {
            flock($this->stream, LOCK_UN);
        }
    }
    private function customErrorHandler($code, $msg)
    {
        $this->errorMessage = preg_replace('{^(fopen|mkdir)\\(.*?\\): }', '', $msg);
    }
    private function getDirFromStream($stream)
    {
        $pos = strpos($stream, '://');
        if ($pos === false) {
            return dirname($stream);
        }
        if ('file://' === substr($stream, 0, 7)) {
            return dirname(substr($stream, 7));
        }
        return;
    }
    private function createDir()
    {
        if ($this->dirCreated) {
            return;
        }
        $dir = $this->getDirFromStream($this->url);
        if (null !== $dir && !is_dir($dir)) {
            $this->errorMessage = null;
            set_error_handler(array($this, 'customErrorHandler'));
            $status = mkdir($dir, 0777, true);
            restore_error_handler();
            if (false === $status) {
                throw new \UnexpectedValueException(sprintf('There is no existing directory at "%s" and its not buildable: ' . $this->errorMessage, $dir));
            }
        }
        $this->dirCreated = true;
    }
}
}

namespace Monolog\Handler {
use Monolog\Logger;
class RotatingFileHandler extends StreamHandler
{
    const FILE_PER_DAY = 'Y-m-d';
    const FILE_PER_MONTH = 'Y-m';
    const FILE_PER_YEAR = 'Y';
    protected $filename;
    protected $maxFiles;
    protected $mustRotate;
    protected $nextRotation;
    protected $filenameFormat;
    protected $dateFormat;
    public function __construct($filename, $maxFiles = 0, $level = Logger::DEBUG, $bubble = true, $filePermission = null, $useLocking = false)
    {
        $this->filename = $filename;
        $this->maxFiles = (int) $maxFiles;
        $this->nextRotation = new \DateTime('tomorrow');
        $this->filenameFormat = '{filename}-{date}';
        $this->dateFormat = 'Y-m-d';
        parent::__construct($this->getTimedFilename(), $level, $bubble, $filePermission, $useLocking);
    }
    public function close()
    {
        parent::close();
        if (true === $this->mustRotate) {
            $this->rotate();
        }
    }
    public function setFilenameFormat($filenameFormat, $dateFormat)
    {
        if (!preg_match('{^Y(([/_.-]?m)([/_.-]?d)?)?$}', $dateFormat)) {
            trigger_error('Invalid date format - format must be one of ' . 'RotatingFileHandler::FILE_PER_DAY ("Y-m-d"), RotatingFileHandler::FILE_PER_MONTH ("Y-m") ' . 'or RotatingFileHandler::FILE_PER_YEAR ("Y"), or you can set one of the ' . 'date formats using slashes, underscores and/or dots instead of dashes.', E_USER_DEPRECATED);
        }
        if (substr_count($filenameFormat, '{date}') === 0) {
            trigger_error('Invalid filename format - format should contain at least `{date}`, because otherwise rotating is impossible.', E_USER_DEPRECATED);
        }
        $this->filenameFormat = $filenameFormat;
        $this->dateFormat = $dateFormat;
        $this->url = $this->getTimedFilename();
        $this->close();
    }
    protected function write(array $record)
    {
        if (null === $this->mustRotate) {
            $this->mustRotate = !file_exists($this->url);
        }
        if ($this->nextRotation < $record['datetime']) {
            $this->mustRotate = true;
            $this->close();
        }
        parent::write($record);
    }
    protected function rotate()
    {
        $this->url = $this->getTimedFilename();
        $this->nextRotation = new \DateTime('tomorrow');
        if (0 === $this->maxFiles) {
            return;
        }
        $logFiles = glob($this->getGlobPattern());
        if ($this->maxFiles >= count($logFiles)) {
            return;
        }
        usort($logFiles, function ($a, $b) {
            return strcmp($b, $a);
        });
        foreach (array_slice($logFiles, $this->maxFiles) as $file) {
            if (is_writable($file)) {
                set_error_handler(function ($errno, $errstr, $errfile, $errline) {
                });
                unlink($file);
                restore_error_handler();
            }
        }
        $this->mustRotate = false;
    }
    protected function getTimedFilename()
    {
        $fileInfo = pathinfo($this->filename);
        $timedFilename = str_replace(array('{filename}', '{date}'), array($fileInfo['filename'], date($this->dateFormat)), $fileInfo['dirname'] . '/' . $this->filenameFormat);
        if (!empty($fileInfo['extension'])) {
            $timedFilename .= '.' . $fileInfo['extension'];
        }
        return $timedFilename;
    }
    protected function getGlobPattern()
    {
        $fileInfo = pathinfo($this->filename);
        $glob = str_replace(array('{filename}', '{date}'), array($fileInfo['filename'], '*'), $fileInfo['dirname'] . '/' . $this->filenameFormat);
        if (!empty($fileInfo['extension'])) {
            $glob .= '.' . $fileInfo['extension'];
        }
        return $glob;
    }
}
}

namespace Monolog\Handler {
use Monolog\Formatter\FormatterInterface;
interface HandlerInterface
{
    public function isHandling(array $record);
    public function handle(array $record);
    public function handleBatch(array $records);
    public function pushProcessor($callback);
    public function popProcessor();
    public function setFormatter(FormatterInterface $formatter);
    public function getFormatter();
}
}

namespace Monolog\Formatter {
interface FormatterInterface
{
    public function format(array $record);
    public function formatBatch(array $records);
}
}

namespace Monolog\Formatter {
use Exception;
class NormalizerFormatter implements FormatterInterface
{
    const SIMPLE_DATE = "Y-m-d H:i:s";
    protected $dateFormat;
    public function __construct($dateFormat = null)
    {
        $this->dateFormat = $dateFormat ?: static::SIMPLE_DATE;
        if (!function_exists('json_encode')) {
            throw new \RuntimeException('PHP\'s json extension is required to use Monolog\'s NormalizerFormatter');
        }
    }
    public function format(array $record)
    {
        return $this->normalize($record);
    }
    public function formatBatch(array $records)
    {
        foreach ($records as $key => $record) {
            $records[$key] = $this->format($record);
        }
        return $records;
    }
    protected function normalize($data)
    {
        if (null === $data || is_scalar($data)) {
            if (is_float($data)) {
                if (is_infinite($data)) {
                    return ($data > 0 ? '' : '-') . 'INF';
                }
                if (is_nan($data)) {
                    return 'NaN';
                }
            }
            return $data;
        }
        if (is_array($data) || $data instanceof \Traversable) {
            $normalized = array();
            $count = 1;
            foreach ($data as $key => $value) {
                if ($count++ >= 1000) {
                    $normalized['...'] = 'Over 1000 items, aborting normalization';
                    break;
                }
                $normalized[$key] = $this->normalize($value);
            }
            return $normalized;
        }
        if ($data instanceof \DateTime) {
            return $data->format($this->dateFormat);
        }
        if (is_object($data)) {
            if ($data instanceof Exception || PHP_VERSION_ID > 70000 && $data instanceof \Throwable) {
                return $this->normalizeException($data);
            }
            if (method_exists($data, '__toString') && !$data instanceof \JsonSerializable) {
                $value = $data->__toString();
            } else {
                $value = $this->toJson($data, true);
            }
            return sprintf("[object] (%s: %s)", get_class($data), $value);
        }
        if (is_resource($data)) {
            return sprintf('[resource] (%s)', get_resource_type($data));
        }
        return '[unknown(' . gettype($data) . ')]';
    }
    protected function normalizeException($e)
    {
        if (!$e instanceof Exception && !$e instanceof \Throwable) {
            throw new \InvalidArgumentException('Exception/Throwable expected, got ' . gettype($e) . ' / ' . get_class($e));
        }
        $data = array('class' => get_class($e), 'message' => $e->getMessage(), 'code' => $e->getCode(), 'file' => $e->getFile() . ':' . $e->getLine());
        if ($e instanceof \SoapFault) {
            if (isset($e->faultcode)) {
                $data['faultcode'] = $e->faultcode;
            }
            if (isset($e->faultactor)) {
                $data['faultactor'] = $e->faultactor;
            }
            if (isset($e->detail)) {
                $data['detail'] = $e->detail;
            }
        }
        $trace = $e->getTrace();
        foreach ($trace as $frame) {
            if (isset($frame['file'])) {
                $data['trace'][] = $frame['file'] . ':' . $frame['line'];
            } elseif (isset($frame['function']) && $frame['function'] === '{closure}') {
                $data['trace'][] = $frame['function'];
            } else {
                $data['trace'][] = $this->toJson($this->normalize($frame), true);
            }
        }
        if ($previous = $e->getPrevious()) {
            $data['previous'] = $this->normalizeException($previous);
        }
        return $data;
    }
    protected function toJson($data, $ignoreErrors = false)
    {
        if ($ignoreErrors) {
            return @$this->jsonEncode($data);
        }
        $json = $this->jsonEncode($data);
        if ($json === false) {
            $json = $this->handleJsonError(json_last_error(), $data);
        }
        return $json;
    }
    private function jsonEncode($data)
    {
        if (version_compare(PHP_VERSION, '5.4.0', '>=')) {
            return json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
        }
        return json_encode($data);
    }
    private function handleJsonError($code, $data)
    {
        if ($code !== JSON_ERROR_UTF8) {
            $this->throwEncodeError($code, $data);
        }
        if (is_string($data)) {
            $this->detectAndCleanUtf8($data);
        } elseif (is_array($data)) {
            array_walk_recursive($data, array($this, 'detectAndCleanUtf8'));
        } else {
            $this->throwEncodeError($code, $data);
        }
        $json = $this->jsonEncode($data);
        if ($json === false) {
            $this->throwEncodeError(json_last_error(), $data);
        }
        return $json;
    }
    private function throwEncodeError($code, $data)
    {
        switch ($code) {
            case JSON_ERROR_DEPTH:
                $msg = 'Maximum stack depth exceeded';
                break;
            case JSON_ERROR_STATE_MISMATCH:
                $msg = 'Underflow or the modes mismatch';
                break;
            case JSON_ERROR_CTRL_CHAR:
                $msg = 'Unexpected control character found';
                break;
            case JSON_ERROR_UTF8:
                $msg = 'Malformed UTF-8 characters, possibly incorrectly encoded';
                break;
            default:
                $msg = 'Unknown error';
        }
        throw new \RuntimeException('JSON encoding failed: ' . $msg . '. Encoding: ' . var_export($data, true));
    }
    public function detectAndCleanUtf8(&$data)
    {
        if (is_string($data) && !preg_match('//u', $data)) {
            $data = preg_replace_callback('/[\\x80-\\xFF]+/', function ($m) {
                return utf8_encode($m[0]);
            }, $data);
            $data = str_replace(array('', '', '', '', '', '', '', ''), array('', '', '', '', '', '', '', ''), $data);
        }
    }
}
}

namespace Monolog\Formatter {
class LineFormatter extends NormalizerFormatter
{
    const SIMPLE_FORMAT = "[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n";
    protected $format;
    protected $allowInlineLineBreaks;
    protected $ignoreEmptyContextAndExtra;
    protected $includeStacktraces;
    public function __construct($format = null, $dateFormat = null, $allowInlineLineBreaks = false, $ignoreEmptyContextAndExtra = false)
    {
        $this->format = $format ?: static::SIMPLE_FORMAT;
        $this->allowInlineLineBreaks = $allowInlineLineBreaks;
        $this->ignoreEmptyContextAndExtra = $ignoreEmptyContextAndExtra;
        parent::__construct($dateFormat);
    }
    public function includeStacktraces($include = true)
    {
        $this->includeStacktraces = $include;
        if ($this->includeStacktraces) {
            $this->allowInlineLineBreaks = true;
        }
    }
    public function allowInlineLineBreaks($allow = true)
    {
        $this->allowInlineLineBreaks = $allow;
    }
    public function ignoreEmptyContextAndExtra($ignore = true)
    {
        $this->ignoreEmptyContextAndExtra = $ignore;
    }
    public function format(array $record)
    {
        $vars = parent::format($record);
        $output = $this->format;
        foreach ($vars['extra'] as $var => $val) {
            if (false !== strpos($output, '%extra.' . $var . '%')) {
                $output = str_replace('%extra.' . $var . '%', $this->stringify($val), $output);
                unset($vars['extra'][$var]);
            }
        }
        foreach ($vars['context'] as $var => $val) {
            if (false !== strpos($output, '%context.' . $var . '%')) {
                $output = str_replace('%context.' . $var . '%', $this->stringify($val), $output);
                unset($vars['context'][$var]);
            }
        }
        if ($this->ignoreEmptyContextAndExtra) {
            if (empty($vars['context'])) {
                unset($vars['context']);
                $output = str_replace('%context%', '', $output);
            }
            if (empty($vars['extra'])) {
                unset($vars['extra']);
                $output = str_replace('%extra%', '', $output);
            }
        }
        foreach ($vars as $var => $val) {
            if (false !== strpos($output, '%' . $var . '%')) {
                $output = str_replace('%' . $var . '%', $this->stringify($val), $output);
            }
        }
        return $output;
    }
    public function formatBatch(array $records)
    {
        $message = '';
        foreach ($records as $record) {
            $message .= $this->format($record);
        }
        return $message;
    }
    public function stringify($value)
    {
        return $this->replaceNewlines($this->convertToString($value));
    }
    protected function normalizeException($e)
    {
        if (!$e instanceof \Exception && !$e instanceof \Throwable) {
            throw new \InvalidArgumentException('Exception/Throwable expected, got ' . gettype($e) . ' / ' . get_class($e));
        }
        $previousText = '';
        if ($previous = $e->getPrevious()) {
            do {
                $previousText .= ', ' . get_class($previous) . '(code: ' . $previous->getCode() . '): ' . $previous->getMessage() . ' at ' . $previous->getFile() . ':' . $previous->getLine();
            } while ($previous = $previous->getPrevious());
        }
        $str = '[object] (' . get_class($e) . '(code: ' . $e->getCode() . '): ' . $e->getMessage() . ' at ' . $e->getFile() . ':' . $e->getLine() . $previousText . ')';
        if ($this->includeStacktraces) {
            $str .= "\n[stacktrace]\n" . $e->getTraceAsString();
        }
        return $str;
    }
    protected function convertToString($data)
    {
        if (null === $data || is_bool($data)) {
            return var_export($data, true);
        }
        if (is_scalar($data)) {
            return (string) $data;
        }
        if (version_compare(PHP_VERSION, '5.4.0', '>=')) {
            return $this->toJson($data, true);
        }
        return str_replace('\\/', '/', @json_encode($data));
    }
    protected function replaceNewlines($str)
    {
        if ($this->allowInlineLineBreaks) {
            return $str;
        }
        return str_replace(array("\r\n", "\r", "\n"), ' ', $str);
    }
}
}

namespace Royalcms\Component\QrCode {
use Royalcms\Component\Support\ServiceProvider;
class QrCodeServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->singleton('qrcode', function () {
            return new BaconQrCodeGenerator();
        });
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_QrCode', 'Royalcms\\Component\\QrCode\\Facades\\QrCode');
        });
    }
    public function provides()
    {
        return array('qrcode');
    }
}
}

namespace Royalcms\Component\Sms {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Sms\Manager;
class SmsServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->setupConfig();
    }
    protected function setupConfig()
    {
        $this->package('royalcms/sms');
    }
    public function register()
    {
        $this->royalcms->singleton('sms', function () {
            return new Manager($this->royalcms);
        });
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Sms', 'Royalcms\\Component\\Sms\\Facades\\Sms');
        });
    }
    public function provides()
    {
        return ['sms'];
    }
}
}

namespace Royalcms\Component\Omnipay {
use Royalcms\Component\Support\ServiceProvider;
use Omnipay\Common\GatewayFactory;
class OmnipayServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->package('royalcms/omnipay');
    }
    public function register()
    {
        $this->registerManager();
    }
    public function registerManager()
    {
        $this->royalcms->singleton('omnipay', function ($royalcms) {
            $factory = new GatewayFactory();
            $manager = new OmnipayManager($royalcms, $factory);
            return $manager;
        });
    }
    public function provides()
    {
        return ['omnipay'];
    }
}
}

namespace Royalcms\Component\Alidayu {
use Royalcms\Component\Support\ServiceProvider;
class AlidayuServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->setupConfig();
        $this->royalcms['alidayu']->configure($this->royalcms['config']->get('alidayu::config'));
    }
    protected function setupConfig()
    {
        $this->package('royalcms/alidayu');
    }
    public function register()
    {
        $this->royalcms->singleton('alidayu', function () {
            return new Factory($this->royalcms);
        });
    }
    public function provides()
    {
        return ['alidayu'];
    }
}
}

namespace Royalcms\Component\WeChat {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\WeChat\Foundation\WeChat as WeChatContainer;
class WeChatServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
    }
    public function register()
    {
        $this->package('royalcms/wechat');
        $this->registerWeChat();
        $this->registerBase();
        $this->loadAlias();
    }
    protected function registerWeChat()
    {
        $this->royalcms->bindShared('wechat', function ($royalcms) {
            return new WeChatContainer();
        });
    }
    protected function registerBase()
    {
        $wechat = $this->royalcms['wechat'];
        $wechat['request'] = $this->royalcms['request'];
        $wechat['cache'] = $this->royalcms['cache'];
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_WeChat', 'Royalcms\\Component\\WeChat\\Facades\\WeChat');
        });
    }
    public function provides()
    {
        return array('wechat');
    }
}
}

namespace Royalcms\Component\IpAddress {
class Ip
{
    private static function _convert_ip_tiny($ip, $ipdatafile)
    {
        $ip_addres = new IpAddress($ipdatafile);
        $area = $ip_addres->getLocation($ip);
        return $area['country'] . ' ' . $area['area'];
    }
    private static function _change_simply_area($area)
    {
        $tmp = explode(' ', $area);
        return $tmp[0];
    }
    public static function area($ip = '', $isSimple = true, $ip_file = '')
    {
        if (!$ip) {
            $ip = self::client_ip();
        }
        if (preg_match("/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\$/", $ip)) {
            $iparray = explode('.', $ip);
            if ($iparray[0] == 10 || $iparray[0] == 127 || $iparray[0] == 192 && $iparray[1] == 168 || $iparray[0] == 172 && ($iparray[1] >= 16 && $iparray[1] <= 31)) {
                return '';
            } elseif ($iparray[0] > 255 || $iparray[1] > 255 || $iparray[2] > 255 || $iparray[3] > 255) {
                return 'ERROR';
            } elseif ($isSimple) {
                return self::_change_simply_area(self::_convert_ip_tiny($ip, $ip_file));
            } else {
                return self::_convert_ip_tiny($ip, $ip_file);
            }
        }
    }
    public static function client_ip($type = 0)
    {
        static $client_ip = null;
        if ($client_ip !== null) {
            return $type == 0 ? $client_ip[0] : $client_ip[1];
        }
        $ip = '';
        if (isset($_SERVER)) {
            if (isset($_SERVER["HTTP_X_FORWARDED_FOR"])) {
                $ip = $_SERVER["HTTP_X_FORWARDED_FOR"];
            } else {
                if (isset($_SERVER["HTTP_CLIENT_IP"])) {
                    $ip = $_SERVER["HTTP_CLIENT_IP"];
                } else {
                    $ip = $_SERVER["REMOTE_ADDR"];
                }
            }
        } else {
            if (getenv("HTTP_X_FORWARDED_FOR")) {
                $ip = getenv("HTTP_X_FORWARDED_FOR");
            } else {
                if (getenv("HTTP_CLIENT_IP")) {
                    $ip = getenv("HTTP_CLIENT_IP");
                } else {
                    $ip = getenv("REMOTE_ADDR");
                }
            }
        }
        $long = ip2long($ip);
        $client_ip = $long ? array($ip, $long) : array("0.0.0.0", 0);
        return $client_ip[$type];
    }
    public static function server_ip()
    {
        static $serverip = null;
        if ($serverip !== null) {
            return $serverip;
        }
        if (isset($_SERVER)) {
            if (isset($_SERVER['SERVER_ADDR'])) {
                $serverip = $_SERVER['SERVER_ADDR'];
            } else {
                $serverip = '0.0.0.0';
            }
        } else {
            $serverip = getenv('SERVER_ADDR');
        }
        return $serverip;
    }
}
}

namespace Royalcms\Component\ClassLoader {
class ClassManager
{
    protected static $loader;
    public static function import($class)
    {
        $loader = self::auto_loader_class();
        if (!$loader->loadClass($class)) {
            rc_throw_exception($class . __(''));
        }
    }
    public static function auto_loader_class()
    {
        if (!isset(self::$loader)) {
            $dirname = dirname(ROYALCMS_PATH) . DS . 'class-loader' . DS;
            require_once $dirname . 'Royalcms/Component/ClassLoader/ClassLoader.php';
            $dir = rtrim(ROYALCMS_PATH, DIRECTORY_SEPARATOR);
            self::$loader = new ClassLoader();
            self::$loader->registerPrefix('Component', $dir . '/Royalcms');
            self::$loader->register();
        }
        return self::$loader;
    }
    public static function addNamespace($namespace, $directorie)
    {
        self::$loader->registerNamespace($namespace, $directorie);
    }
    public static function addNamespaces(array $namespaces)
    {
        self::$loader->registerNamespaces($namespaces);
    }
    public static function getNamespaces()
    {
        return self::$loader->getNamespaces();
    }
}
}

namespace Royalcms\Component\Purifier {
use Royalcms\Component\Foundation\Royalcms;
use Royalcms\Component\Support\ServiceProvider;
class PurifierServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->setupConfig();
        $dir = static::guessPackageClassPath('royalcms/purifier');
        require $dir . '/helpers.php';
    }
    protected function setupConfig()
    {
        $this->package('royalcms/purifier');
    }
    public function register()
    {
        $this->royalcms->singleton('purifier', function (Royalcms $royalcms) {
            return new Purifier($royalcms['files'], $royalcms['config']);
        });
        $this->royalcms->alias('purifier', 'Royalcms\\Component\\Purifier\\Purifier');
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Purifier', 'Royalcms\\Component\\Purifier\\Facades\\Purifier');
        });
    }
    public function provides()
    {
        return ['purifier'];
    }
}
}

namespace Royalcms\Component\XmlResponse {
use Royalcms\Component\Support\Facades\Response;
use Royalcms\Component\Support\ServiceProvider;
class XmlResponseServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->package('royalcms/xml-response');
    }
    public function register()
    {
        Response::macro('xml', function ($value, $headerTemplate = array()) {
            return with(new XmlResponse())->array2xml($value, false, $headerTemplate);
        });
    }
    public function provides()
    {
        return array('xml-response');
    }
}
}

namespace Royalcms\Component\Tcpdf {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Foundation\AliasLoader;
use RC_Config;
class TcpdfServiceProvider extends ServiceProvider
{
    protected $defer = false;
    private $config_constant_map = ['K_PATH_FONTS' => 'fonts_directory', 'K_PATH_IMAGES' => 'image_directory', 'PDF_HEADER_LOGO' => 'header_logo', 'PDF_HEADER_LOGO_WIDTH' => 'header_logo_width', 'K_PATH_CACHE' => 'cache_directory', 'K_BLANK_IMAGE' => 'blank_image', 'PDF_PAGE_FORMAT' => 'page_format', 'PDF_PAGE_ORIENTATION' => 'page_orientation', 'PDF_CREATOR' => 'creator', 'PDF_AUTHOR' => 'author', 'PDF_HEADER_TITLE' => 'header_title', 'PDF_HEADER_STRING' => 'header_string', 'PDF_UNIT' => 'page_unit', 'PDF_MARGIN_HEADER' => 'header_margin', 'PDF_MARGIN_FOOTER' => 'footer_margin', 'PDF_MARGIN_TOP' => 'margin_top', 'PDF_MARGIN_BOTTOM' => 'margin_bottom', 'PDF_MARGIN_LEFT' => 'margin_left', 'PDF_MARGIN_RIGHT' => 'margin_right', 'PDF_FONT_NAME_MAIN' => 'page_font', 'PDF_FONT_SIZE_MAIN' => 'page_font_size', 'PDF_FONT_NAME_DATA' => 'page_font', 'PDF_FONT_SIZE_DATA' => 'page_font_size', 'PDF_FONT_MONOSPACED' => 'font_monospaced', 'PDF_IMAGE_SCALE_RATIO' => 'image_scale', 'HEAD_MAGNIFICATION' => 'head_magnification', 'K_CELL_HEIGHT_RATIO' => 'cell_height_ratio', 'K_TITLE_MAGNIFICATION' => 'title_magnification', 'K_SMALL_RATIO' => 'small_font_ratio', 'K_THAI_TOPCHARS' => 'thai_topchars', 'K_TCPDF_CALLS_IN_HTML' => 'tcpdf_calls_in_html', 'K_TCPDF_THROW_EXCEPTION_ERROR' => 'tcpdf_throw_exception_error'];
    public function boot()
    {
        $this->package('royalcms/tcpdf');
        if (!defined('K_TCPDF_EXTERNAL_CONFIG')) {
            define('K_TCPDF_EXTERNAL_CONFIG', TRUE);
        }
        $this->setTcpdfConstants();
        AliasLoader::getInstance()->alias('RC_PDF', 'Royalcms\\Component\\Tcpdf\\Facades\\Tcpdf');
    }
    public function register()
    {
        $this->royalcms['tcpdf'] = $this->royalcms->share(function ($royalcms) {
            return new Tcpdf($royalcms);
        });
    }
    public function provides()
    {
        return array('tcpdf');
    }
    private function setTcpdfConstants()
    {
        foreach ($this->config_constant_map as $const => $configkey) {
            if (!defined($const)) {
                if (is_string(RC_Config::get('tcpdf::config.' . $configkey))) {
                    if (strlen(RC_Config::get('tcpdf::config.' . $configkey)) > 0) {
                        define($const, RC_Config::get('tcpdf::config.' . $configkey));
                    }
                } else {
                    define($const, RC_Config::get('tcpdf::config.' . $configkey));
                }
            }
        }
    }
}
}

namespace Royalcms\Component\Excel {
use PHPExcel_Settings;
use PHPExcel_Shared_Font;
use Royalcms\Component\Excel\Readers\HtmlReader;
use Royalcms\Component\Excel\Classes\Cache;
use Royalcms\Component\Excel\Classes\PHPExcel;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Excel\Parsers\CssParser;
use Royalcms\Component\Excel\Parsers\ViewParser;
use Royalcms\Component\Excel\Classes\FormatIdentifier;
use Royalcms\Component\Excel\Readers\ExcelReader;
use Royalcms\Component\Excel\Writers\ExcelWriter;
use TijsVerkoyen\CssToInlineStyles\CssToInlineStyles;
use RC_Config;
class ExcelServiceProvider extends ServiceProvider
{
    protected $defer = false;
    public function boot()
    {
        $this->package('royalcms/excel');
        $this->setAutoSizingSettings();
    }
    public function register()
    {
        $this->bindClasses();
        $this->bindCssParser();
        $this->bindReaders();
        $this->bindParsers();
        $this->bindPHPExcelClass();
        $this->bindWriters();
        $this->bindExcel();
        $this->loadAlias();
    }
    protected function bindPHPExcelClass()
    {
        $me = $this;
        $this->royalcms['phpexcel'] = $this->royalcms->share(function () use($me) {
            $me->setLocale();
            $me->setCacheSettings();
            $excel = new PHPExcel();
            $excel->setDefaultProperties();
            return $excel;
        });
    }
    protected function bindCssParser()
    {
        $this->royalcms['excel.parsers.css'] = $this->royalcms->share(function () {
            return new CssParser(new CssToInlineStyles());
        });
    }
    protected function bindReaders()
    {
        $this->royalcms['excel.reader'] = $this->royalcms->share(function ($royalcms) {
            return new ExcelReader($royalcms['files'], $royalcms['excel.identifier']);
        });
        $this->royalcms['excel.readers.html'] = $this->royalcms->share(function ($royalcms) {
            return new HtmlReader($royalcms['excel.parsers.css']);
        });
    }
    protected function bindParsers()
    {
        $this->royalcms['excel.parsers.view'] = $this->royalcms->share(function ($royalcms) {
            return new ViewParser($royalcms['excel.readers.html']);
        });
    }
    protected function bindWriters()
    {
        $this->royalcms['excel.writer'] = $this->royalcms->share(function ($royalcms) {
            return new ExcelWriter($royalcms->make('response'), $royalcms['files'], $royalcms['excel.identifier']);
        });
    }
    protected function bindExcel()
    {
        $this->royalcms['excel'] = $this->royalcms->share(function ($royalcms) {
            $excel = new Excel($royalcms['phpexcel'], $royalcms['excel.reader'], $royalcms['excel.writer'], $royalcms['excel.parsers.view']);
            $excel->registerFilters($royalcms['config']->get('excel::filters', array()));
            return $excel;
        });
    }
    protected function bindClasses()
    {
        $this->royalcms['excel.identifier'] = $this->royalcms->share(function ($royalcms) {
            return new FormatIdentifier($royalcms['files']);
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Excel', 'Royalcms\\Component\\Excel\\Facades\\Excel');
        });
    }
    public function setCacheSettings()
    {
        return new Cache();
    }
    public function setLocale()
    {
        $locale = RC_Config::get('system.locale', 'zh_CN');
        PHPExcel_Settings::setLocale($locale);
    }
    public function setAutoSizingSettings()
    {
        $method = RC_Config::get('excel::export.autosize-method', PHPExcel_Shared_Font::AUTOSIZE_METHOD_APPROX);
        PHPExcel_Shared_Font::setAutoSizeMethod($method);
    }
    public function provides()
    {
        return array('excel', 'phpexcel', 'excel.reader', 'excel.readers.html', 'excel.parsers.view', 'excel.writer');
    }
}
}

namespace Royalcms\Component\WeChat\MiniProgram {
use Royalcms\Component\Support\ServiceProvider;
class MiniProgramServiceProvider extends ServiceProvider
{
    public function register()
    {
        $wechat = $this->royalcms['wechat'];
        $wechat->bindShared('weapp', function ($wechat) {
            return new MiniProgram($wechat);
        });
    }
}
}

namespace Royalcms\Component\Cron {
use Royalcms\Component\Support\ServiceProvider;
class CronServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $path = $this->royalcms->appPath() . '/cron/classes';
        $this->package('royalcms/cron', null, $path);
    }
    public function register()
    {
        $this->royalcms['cron'] = $this->royalcms->share(function ($royalcms) {
            return new Cron();
        });
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Cron', 'Royalcms\\Component\\Cron\\Facades\\Cron');
        });
        $this->royalcms['cron::command.run'] = $this->royalcms->share(function ($royalcms) {
            return new RunCommand();
        });
        $this->commands('cron::command.run');
        $this->royalcms['cron::command.list'] = $this->royalcms->share(function ($royalcms) {
            return new ListCommand();
        });
        $this->commands('cron::command.list');
        $this->royalcms['cron::command.keygen'] = $this->royalcms->share(function ($royalcms) {
            return new KeygenCommand();
        });
        $this->commands('cron::command.keygen');
    }
    public function provides()
    {
        return array('cron');
    }
}
}

namespace Royalcms\Component\Shoppingcart {
use Royalcms\Component\Support\ServiceProvider;
class ShoppingcartServiceProvider extends ServiceProvider
{
    public function boot()
    {
        $this->package('royalcms/shoppingcart');
    }
    public function register()
    {
        $this->royalcms->bind('cart', function ($royalcms) {
            return new Cart();
        });
    }
}
}

namespace Royalcms\Component\Printer {
use Royalcms\Component\Support\ServiceProvider;
class PrinterServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
    }
    public function register()
    {
        $this->royalcms->singleton('printer', function () {
            return new Factory();
        });
    }
    public function provides()
    {
        return ['printer'];
    }
}
}

namespace Ecjia\App\Adsense {
use Royalcms\Component\App\AppParentServiceProvider;
class AdsenseServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-adsense');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Affiliate {
use Royalcms\Component\App\AppParentServiceProvider;
class AffiliateServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-affiliate');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Api {
use Royalcms\Component\App\AppParentServiceProvider;
class ApiServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-api');
    }
    public function register()
    {
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_api', 'Ecjia\\App\\Api\\BaseControllers\\EcjiaApi');
            $loader->alias('ecjia_api_manager', 'Ecjia\\App\\Api\\LocalRequest\\ApiManager');
            $loader->alias('ecjia_api_const', 'Ecjia\\App\\Api\\LocalRequest\\ApiConst');
            $loader->alias('api_front', 'Ecjia\\App\\Api\\BaseControllers\\EcjiaApiFrontController');
            $loader->alias('api_admin', 'Ecjia\\App\\Api\\BaseControllers\\EcjiaApiAdminController');
            $loader->alias('api_interface', 'Ecjia\\App\\Api\\Responses\\Contracts\\ApiHandler');
        });
    }
}
}

namespace Ecjia\App\Article {
use Royalcms\Component\App\AppParentServiceProvider;
class ArticleServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-article');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Agent {
use Royalcms\Component\App\AppParentServiceProvider;
class AgentServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-agent');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Bonus {
use Royalcms\Component\App\AppParentServiceProvider;
class BonusServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-bonus');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Captcha {
use Royalcms\Component\App\AppParentServiceProvider;
class CaptchaServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-captcha');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Cart {
use Royalcms\Component\App\AppParentServiceProvider;
class CartServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-cart');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Cashier {
use Royalcms\Component\App\AppParentServiceProvider;
class CashierServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-cashier');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Comment {
use Royalcms\Component\App\AppParentServiceProvider;
class CommentServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-comment');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Commission {
use Royalcms\Component\App\AppParentServiceProvider;
class CommissionServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-commission');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Connect {
use Royalcms\Component\App\AppParentServiceProvider;
class ConnectServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-connect');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Cron {
use Royalcms\Component\App\AppParentServiceProvider;
class CronServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-cron');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Express {
use Royalcms\Component\App\AppParentServiceProvider;
class ExpressServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-express');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Favourable {
use Royalcms\Component\App\AppParentServiceProvider;
class FavourableServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-favourable');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Finance {
use Royalcms\Component\App\AppParentServiceProvider;
class FinanceServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-finance');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Franchisee {
use Royalcms\Component\App\AppParentServiceProvider;
class FranchiseeServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-franchisee');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Friendlink {
use Royalcms\Component\App\AppParentServiceProvider;
class FriendlinkServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-friendlink');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Goods {
use Royalcms\Component\App\AppParentServiceProvider;
class GoodsServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-goods');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Goodslib {
use Royalcms\Component\App\AppParentServiceProvider;
class GoodslibServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-goodslib');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Groupbuy {
use Royalcms\Component\App\AppParentServiceProvider;
class GroupbuyServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-groupbuy');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Installer {
use Royalcms\Component\App\AppParentServiceProvider;
class InstallerServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-installer');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Intro {
use Royalcms\Component\App\AppParentServiceProvider;
class IntroServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-intro');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Logviewer {
use Royalcms\Component\App\AppParentServiceProvider;
class LogviewerServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-logviewer');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Mail {
use Royalcms\Component\App\AppParentServiceProvider;
class MailServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-mail');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Main {
use Royalcms\Component\App\AppParentServiceProvider;
class MainServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-main');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Maintain {
use Royalcms\Component\App\AppParentServiceProvider;
class MaintainServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-maintain');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Market {
use Royalcms\Component\App\AppParentServiceProvider;
class MarketServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-market');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Merchant {
use Royalcms\Component\App\AppParentServiceProvider;
class MerchantServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-merchant');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Mobile {
use Royalcms\Component\App\AppParentServiceProvider;
class MobileServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-mobile');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Notification {
use Royalcms\Component\App\AppParentServiceProvider;
class NotificationServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-notification');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Orders {
use Royalcms\Component\App\AppParentServiceProvider;
class OrdersServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-orders');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Payment {
use Royalcms\Component\App\AppParentServiceProvider;
class PaymentServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-payment');
    }
    public function register()
    {
        $this->registerPayment();
        $this->loadAlias();
    }
    public function registerPayment()
    {
        $this->royalcms->bindShared('ecjia.payment', function ($royalcms) {
            return new PaymentPlugin();
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_payment', 'Ecjia\\App\\Payment\\Facades\\Payment');
        });
    }
}
}

namespace Ecjia\App\Platform {
use Royalcms\Component\App\AppParentServiceProvider;
class PlatformServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-platform');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Printer {
use Royalcms\Component\App\AppParentServiceProvider;
class PrinterServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-printer');
    }
    public function register()
    {
        $this->registerPrinterService();
        $this->loadAlias();
    }
    public function registerPrinterService()
    {
        $this->royalcms->bindShared('ecjia.printer', function ($royalcms) {
            return new PrinterManager();
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_printer', 'Ecjia\\App\\Printer\\Facades\\Printer');
        });
    }
}
}

namespace Ecjia\App\Promotion {
use Royalcms\Component\App\AppParentServiceProvider;
class PromotionServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-promotion');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Push {
use Royalcms\Component\App\AppParentServiceProvider;
class PushServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-push');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Quickpay {
use Royalcms\Component\App\AppParentServiceProvider;
class QuickpayServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-quickpay');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Refund {
use Royalcms\Component\App\AppParentServiceProvider;
class RefundServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-refund');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Setting {
use Royalcms\Component\App\AppParentServiceProvider;
class SettingServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-setting');
    }
    public function register()
    {
        $this->registerRegion();
        $this->loadAlias();
    }
    public function registerRegion()
    {
        $this->royalcms->bindShared('ecjia.region', function ($royalcms) {
            return new Region();
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_region', 'Ecjia\\App\\Setting\\Facades\\Region');
        });
    }
}
}

namespace Ecjia\App\Shipping {
use Royalcms\Component\App\AppParentServiceProvider;
class ShippingServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-shipping');
    }
    public function register()
    {
        $this->registerShipping();
        $this->loadAlias();
    }
    public function registerShipping()
    {
        $this->royalcms->bindShared('ecjia.shipping', function ($royalcms) {
            return new ShippingPlugin();
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_shipping', 'Ecjia\\App\\Shipping\\Facades\\Shipping');
        });
    }
}
}

namespace Ecjia\App\Shopguide {
use Royalcms\Component\App\AppParentServiceProvider;
class ShopguideServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-shopguide');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Sms {
use Royalcms\Component\App\AppParentServiceProvider;
class SmsServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-sms');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Staff {
use Royalcms\Component\App\AppParentServiceProvider;
class StaffServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-staff');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Stats {
use Royalcms\Component\App\AppParentServiceProvider;
class StatsServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-stats');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Store {
use Royalcms\Component\App\AppParentServiceProvider;
class StoreServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-store');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Touch {
use Royalcms\Component\App\AppParentServiceProvider;
class TouchServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-touch');
    }
    public function register()
    {
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_touch', 'Ecjia\\App\\Touch\\Frameworks\\EcjiaTouch');
            $loader->alias('ecjia_touch_manager', 'Ecjia\\App\\Touch\\ApiRequest\\ApiManager');
            $loader->alias('ecjia_touch_api', 'Ecjia\\App\\Touch\\ApiRequest\\ApiConst');
            $loader->alias('ecjia_touch_page', 'Ecjia\\App\\Touch\\Frameworks\\Component\\Page');
            $loader->alias('ecjia_touch_user', 'Ecjia\\App\\Touch\\Frameworks\\Component\\User');
        });
    }
}
}

namespace Ecjia\App\Upgrade {
use Royalcms\Component\App\AppParentServiceProvider;
class UpgradeServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-upgrade');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\User {
use Royalcms\Component\App\AppParentServiceProvider;
class UserServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-user');
    }
    public function register()
    {
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('ecjia_user', 'Ecjia\\App\\User\\Frameworks\\EcjiaUser');
        });
    }
}
}

namespace Ecjia\App\Weapp {
use Royalcms\Component\App\AppParentServiceProvider;
class WeappServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-weapp');
    }
    public function register()
    {
    }
}
}

namespace Ecjia\App\Wechat {
use Royalcms\Component\App\AppParentServiceProvider;
class WechatServiceProvider extends AppParentServiceProvider
{
    public function boot()
    {
        $this->package('ecjia/app-wechat');
    }
    public function register()
    {
    }
}
}

namespace Royalcms\Component\Exception {
use Exception;
interface ExceptionDisplayerInterface
{
    public function display($exception);
}
}

namespace Royalcms\Component\Exception {
use Exception;
use Symfony\Component\Debug\ExceptionHandler;
class SymfonyDisplayer implements ExceptionDisplayerInterface
{
    protected $symfony;
    public function __construct(ExceptionHandler $symfony)
    {
        $this->symfony = $symfony;
    }
    public function display($exception)
    {
        $this->symfony->handle($exception);
    }
}
}

namespace Royalcms\Component\Exception {
use Exception;
use Royalcms\Component\Whoops\Run;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface;
class WhoopsDisplayer implements ExceptionDisplayerInterface
{
    protected $whoops;
    protected $runningInConsole;
    public function __construct(Run $whoops, $runningInConsole)
    {
        $this->whoops = $whoops;
        $this->runningInConsole = $runningInConsole;
    }
    public function display($exception)
    {
        $status = $exception instanceof HttpExceptionInterface ? $exception->getStatusCode() : 500;
        $headers = $exception instanceof HttpExceptionInterface ? $exception->getHeaders() : array();
        return new Response($this->whoops->handleException($exception), $status, $headers);
    }
}
}

namespace Royalcms\Component\Exception {
use Exception;
use Psr\Log\LoggerInterface;
use Royalcms\Component\Http\Response;
use Royalcms\Component\Auth\Access\UnauthorizedException;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Console\Application as ConsoleApplication;
use Symfony\Component\Debug\ExceptionHandler as SymfonyExceptionHandler;
use Royalcms\Component\Contracts\Debug\ExceptionHandler as ExceptionHandlerContract;
use Symfony\Component\HttpKernel\Exception\HttpExceptionInterface;
use ReflectionFunction;
use Closure;
class Handler implements ExceptionHandlerContract
{
    protected $log;
    protected $dontReport = [];
    protected $handlers = [];
    public function __construct(LoggerInterface $log)
    {
        $this->log = $log;
    }
    public function report(Exception $e)
    {
        if ($this->shouldReport($e)) {
            $this->log->error($e);
        }
    }
    public function shouldReport(Exception $e)
    {
        return !$this->shouldntReport($e);
    }
    protected function shouldntReport(Exception $e)
    {
        foreach ($this->dontReport as $type) {
            if ($e instanceof $type) {
                return true;
            }
        }
        return false;
    }
    public function render($request, Exception $e)
    {
        if ($this->isUnauthorizedException($e)) {
            $e = new HttpException(403, $e->getMessage());
        }
        if ($this->isHttpException($e)) {
            return $this->toRoyalcmsResponse($this->renderHttpException($e), $e);
        } else {
            return $this->toRoyalcmsResponse($this->convertExceptionToResponse($e), $e);
        }
    }
    protected function toRoyalcmsResponse($response, Exception $e)
    {
        $response = new Response($response->getContent(), $response->getStatusCode(), $response->headers->all());
        $response->exception = $e;
        return $response;
    }
    public function renderForConsole($output, Exception $e)
    {
        (new ConsoleApplication())->renderException($e, $output);
    }
    protected function renderHttpException(HttpException $e)
    {
        $status = $e->getStatusCode();
        if (view()->exists("errors.{$status}")) {
            return response()->view("errors.{$status}", ['exception' => $e], $status);
        } else {
            return $this->convertExceptionToResponse($e);
        }
    }
    protected function convertExceptionToResponse(Exception $e)
    {
        $royalcms = royalcms();
        $response = $this->callCustomHandlers($e);
        if (!is_null($response)) {
            return $response;
        }
        if (isset($royalcms['exception.display'])) {
            return $royalcms['exception.display']->displayException($e);
        } else {
            return (new SymfonyExceptionHandler(config('system.debug')))->createResponse($e);
        }
    }
    protected function isUnauthorizedException(Exception $e)
    {
        return $e instanceof UnauthorizedException;
    }
    protected function isHttpException(Exception $e)
    {
        return $e instanceof HttpException;
    }
    public function error(Closure $callback)
    {
        array_unshift($this->handlers, $callback);
    }
    public function pushError(Closure $callback)
    {
        $this->handlers[] = $callback;
    }
    protected function callCustomHandlers($exception, $fromConsole = false)
    {
        foreach ($this->handlers as $handler) {
            if (!$this->handlesException($handler, $exception)) {
                continue;
            } elseif ($exception instanceof HttpExceptionInterface) {
                $code = $exception->getStatusCode();
            } else {
                $code = 500;
            }
            try {
                $response = $handler($exception, $code, $fromConsole);
            } catch (\Exception $e) {
                $response = $this->formatException($e);
            }
            if (isset($response) && !is_null($response)) {
                return $response;
            }
        }
    }
    protected function handlesException(Closure $handler, $exception)
    {
        $reflection = new ReflectionFunction($handler);
        return $reflection->getNumberOfParameters() == 0 || $this->hints($reflection, $exception);
    }
    protected function hints(ReflectionFunction $reflection, $exception)
    {
        $parameters = $reflection->getParameters();
        $expected = $parameters[0];
        return !$expected->getClass() || $expected->getClass()->isInstance($exception);
    }
    protected function formatException(\Exception $e)
    {
        if (config('system.debug')) {
            $location = $e->getMessage() . ' in ' . $e->getFile() . ':' . $e->getLine();
            return 'Error in exception handler: ' . $location;
        }
        return 'Error in exception handler.';
    }
    public function handleConsole($exception)
    {
        return $this->callCustomHandlers($exception, true);
    }
}
}

namespace Royalcms\Component\Exception {
class HandleDisplayExceptions
{
    protected $plainDisplayer;
    protected $debugDisplayer;
    protected $debug;
    public function __construct(ExceptionDisplayerInterface $plainDisplayer, ExceptionDisplayerInterface $debugDisplayer, $debug = false)
    {
        $this->debug = $debug;
        $this->plainDisplayer = $plainDisplayer;
        $this->debugDisplayer = $debugDisplayer;
    }
    public function setDebug($debug)
    {
        $this->debug = $debug;
    }
    public function displayException($exception)
    {
        $displayer = $this->debug ? $this->debugDisplayer : $this->plainDisplayer;
        return $displayer->display($exception);
    }
}
}

namespace Royalcms\Component\Exception {
use Exception;
use ErrorException;
use RC_Hook;
use Symfony\Component\Debug\Exception\FatalErrorException;
use Symfony\Component\Debug\Exception\FatalThrowableError;
use Symfony\Component\Console\Output\ConsoleOutput;
use Royalcms\Component\Contracts\Foundation\Royalcms;
use Royalcms\Component\Exception\Exceptions\CompileErrorException;
use Royalcms\Component\Exception\Exceptions\CompileWarningException;
use Royalcms\Component\Exception\Exceptions\CoreErrorException;
use Royalcms\Component\Exception\Exceptions\CoreWarningException;
use Royalcms\Component\Exception\Exceptions\DeprecatedException;
use Royalcms\Component\Exception\Exceptions\NoticeException;
use Royalcms\Component\Exception\Exceptions\ParseException;
use Royalcms\Component\Exception\Exceptions\RecoverableErrorException;
use Royalcms\Component\Exception\Exceptions\StrictException;
use Royalcms\Component\Exception\Exceptions\UnknownException;
use Royalcms\Component\Exception\Exceptions\UserDeprecatedException;
use Royalcms\Component\Exception\Exceptions\UserErrorException;
use Royalcms\Component\Exception\Exceptions\UserNoticeException;
use Royalcms\Component\Exception\Exceptions\UserWarningException;
use Royalcms\Component\Exception\Exceptions\WarningException;
class HandlerExceptions
{
    protected $royalcms;
    public function __construct(Royalcms $royalcms)
    {
        $this->royalcms = $royalcms;
    }
    public function register($environment)
    {
        $this->registerErrorHandler();
        $this->registerExceptionHandler();
        if ($environment != 'testing') {
            ini_set('display_errors', 'Off');
            $this->registerShutdownHandler();
        }
    }
    protected function registerErrorHandler()
    {
        set_error_handler(array($this, 'handleError'));
    }
    protected function registerExceptionHandler()
    {
        set_exception_handler(array($this, 'handleUncaughtException'));
    }
    protected function registerShutdownHandler()
    {
        register_shutdown_function(array($this, 'handleShutdown'));
    }
    public function handleError($level, $message, $file = '', $line = 0, $context = [])
    {
        if (error_reporting() & $level) {
            $exception = null;
            switch ($level) {
                case E_ERROR:
                    throw new ErrorException($message, 0, $level, $file, $line);
                    break;
                case E_USER_ERROR:
                    throw new UserErrorException($message, 0, $level, $file, $line);
                    break;
                case E_PARSE:
                    throw new ParseException($message, 0, $level, $file, $line);
                    break;
                case E_CORE_ERROR:
                    throw new CoreErrorException($message, 0, $level, $file, $line);
                    break;
                case E_CORE_WARNING:
                    throw new CoreWarningException($message, 0, $level, $file, $line);
                    break;
                case E_COMPILE_ERROR:
                    throw new CompileErrorException($message, 0, $level, $file, $line);
                    break;
                case E_COMPILE_WARNING:
                    throw new CompileWarningException($message, 0, $level, $file, $line);
                    break;
                case E_STRICT:
                    throw new StrictException($message, 0, $level, $file, $line);
                    break;
                case E_RECOVERABLE_ERROR:
                    throw new RecoverableErrorException($message, 0, $level, $file, $line);
                    break;
                case E_WARNING:
                    $exception = new WarningException($message, 0, $level, $file, $line);
                    break;
                case E_USER_WARNING:
                    $exception = new UserWarningException($message, 0, $level, $file, $line);
                    break;
                case E_NOTICE:
                    $exception = new NoticeException($message, 0, $level, $file, $line);
                    break;
                case E_USER_NOTICE:
                    $exception = new UserNoticeException($message, 0, $level, $file, $line);
                    break;
                case E_DEPRECATED:
                    $exception = new DeprecatedException($message, 0, $level, $file, $line);
                    break;
                case E_USER_DEPRECATED:
                    $exception = new UserDeprecatedException($message, 0, $level, $file, $line);
                    break;
                default:
                    $exception = new UnknownException($message, 0, $level, $file, $line);
                    break;
            }
            if ($exception instanceof ErrorException) {
                royalcms('events')->fire('royalcms.warning.exception', array($exception));
            }
        }
    }
    public function handleException($exception)
    {
        if (!$exception instanceof Exception) {
            $exception = new FatalThrowableError($exception);
        }
        $this->getExceptionHandler()->report($exception);
        if ($this->royalcms->runningInConsole()) {
            $this->renderForConsole($exception);
        } else {
            $this->renderHttpResponse($exception);
        }
    }
    public function handleUncaughtException($exception)
    {
        $this->handleException($exception)->send();
    }
    public function handleShutdown()
    {
        $error = error_get_last();
        if (!is_null($error)) {
            if (!$this->isFatal($error['type'])) {
                return;
            }
            $this->handleException($this->fatalExceptionFromError($error, 0));
        }
        RC_Hook::do_action('shutdown');
    }
    protected function fatalExceptionFromError(array $error, $traceOffset = null)
    {
        return new FatalErrorException($error['message'], $error['type'], 0, $error['file'], $error['line'], $traceOffset);
    }
    protected function isFatal($type)
    {
        return in_array($type, array(E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE));
    }
    public function renderForConsole($e)
    {
        $this->getExceptionHandler()->renderForConsole(new ConsoleOutput(), $e);
    }
    protected function renderHttpResponse($e)
    {
        $this->getExceptionHandler()->render($this->royalcms['request'], $e)->send();
    }
    protected function getExceptionHandler()
    {
        return $this->royalcms->make('Royalcms\\Component\\Contracts\\Debug\\ExceptionHandler');
    }
}
}

namespace Royalcms\Component\Exception\Exceptions {
class CompileErrorException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class CompileWarningException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class CoreErrorException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class CoreWarningException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class DeprecatedException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class NoticeException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class ParseException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class RecoverableErrorException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class StrictException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class UnknownException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class UserDeprecatedException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class UserErrorException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class UserNoticeException extends \ErrorException
{
}
}

namespace Royalcms\Component\Exception\Exceptions {
class WarningException extends \ErrorException
{
}
}

namespace Royalcms\Component\App\Facades {
use RC_Hook;
use Royalcms\Component\Support\Facades\Lang;
use Royalcms\Component\Support\Facades\Cache as RC_Cache;
use Royalcms\Component\Foundation\Uri;
use Royalcms\Component\Support\Format;
use Royalcms\Component\Support\Facades\Facade;
class App extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'app';
    }
    private static $alias_map = array();
    private static $identifier_map = array();
    public static function scan_bundles()
    {
        $bundles = array();
        $bundles = RC_Hook::apply_filters('app_scan_bundles', $bundles);
        if (!empty($bundles)) {
            foreach ($bundles as $bundle) {
                self::$alias_map[$bundle['alias']] = $bundle['identifier'];
                self::$identifier_map[$bundle['identifier']] = $bundle['directory'];
            }
        }
    }
    public static function get_bundle($alias)
    {
        $bundle = array('alias' => $alias);
        if (isset(self::$alias_map[$alias])) {
            $bundle['identifier'] = self::$alias_map[$alias];
        } else {
            $bundle['identifier'] = $alias;
        }
        if (isset(self::$identifier_map[$bundle['identifier']])) {
            $bundle['directory'] = self::$identifier_map[$bundle['identifier']];
        } else {
            $bundle['directory'] = $alias;
        }
        return $bundle;
    }
    public static function get_alias()
    {
        return self::$alias_map;
    }
    public static function get_identifier()
    {
        return self::$identifier_map;
    }
    protected static $cache_key;
    public static function get_apps($application_identifier = '')
    {
        if (defined('RC_SITE')) {
            $cache_key = 'applications' . constant('RC_SITE');
        } else {
            $cache_key = 'applications';
        }
        $cache_applications = RC_Cache::app_cache_get($cache_key, 'system');
        if ($cache_applications) {
            if ($application_identifier && isset($cache_applications[$application_identifier])) {
                return $cache_applications[$application_identifier];
            } else {
                return $cache_applications;
            }
        }
        $rc_apps = array();
        $app_roots = array(RC_APP_PATH, SITE_APP_PATH);
        foreach ($app_roots as $app_root) {
            if (file_exists($app_root)) {
                $apps_dir = @opendir($app_root);
                while (false !== ($file = @readdir($apps_dir))) {
                    if (substr($file, 0, 1) !== '.') {
                        $package = self::get_app_package($file, false, false);
                        if (empty($package['identifier'])) {
                            continue;
                        }
                        $rc_apps[$package['identifier']] = $package;
                    }
                }
                @closedir($apps_dir);
            }
            uasort($rc_apps, array(__CLASS__, '_sort_uname_callback'));
        }
        RC_Cache::app_cache_set($cache_key, $rc_apps, 'system');
        return $rc_apps;
    }
    public static function _sort_uname_callback($a, $b)
    {
        return strnatcasecmp($a['name'], $b['name']);
    }
    public static function get_app_package($app_dir, $markup = true, $translate = true)
    {
        $package = self::get_package_data($app_dir);
        if ($package && $translate) {
            $package['format_name'] = __($package['name'], $package['directory']);
            $package['format_description'] = __($package['description'], $package['directory']);
        } else {
            $package['format_name'] = $package['name'];
            $package['format_description'] = $package['description'];
        }
        return $package;
    }
    public static function get_package_data($app_dir)
    {
        $package_file = royalcms('path') . '/apps/' . $app_dir . '/configs/package.php';
        if (!file_exists($package_file)) {
            $package_file = royalcms('path.content') . '/apps/' . $app_dir . '/configs/package.php';
        }
        if (!file_exists($package_file)) {
            return null;
        }
        return include $package_file;
    }
    public static function apps_url($path = '', $app = '')
    {
        if (defined('RC_SITE') && strpos($app, 'sites' . DS . RC_SITE)) {
            $url = Uri::content_url() . '/apps';
        } else {
            $url = Uri::home_content_url() . '/apps';
        }
        $url = Uri::set_url_scheme($url);
        if (!empty($app) && is_string($app)) {
            $folder = dirname(self::app_basename($app));
            if ('.' != $folder) {
                $url .= '/' . ltrim($folder, '/');
            }
        }
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('apps_url', $url, $path, $app);
    }
    public static function app_dir_url($file)
    {
        return Format::trailingslashit(self::apps_url('', $file));
    }
    public static function app_dir_path($file)
    {
        return Format::trailingslashit(dirname($file));
    }
    public static function app_basename($file)
    {
        if (defined('RC_SITE') && strpos($file, 'sites' . DS . RC_SITE)) {
            $realdir = SITE_APP_PATH;
            $dir = Format::normalize_path(SITE_APP_PATH);
        } else {
            $realdir = RC_APP_PATH;
            $dir = Format::normalize_path(RC_APP_PATH);
        }
        if (strpos($file, $realdir) === 0) {
            $file = substr($file, strlen($realdir));
        }
        $file = Format::normalize_path($file);
        $file = preg_replace('#^' . preg_quote($dir, '#') . '/#', '', $file);
        $file = trim($file, '/');
        return $file;
    }
    public static function clean_applications_cache($clear_update_cache = true)
    {
        if ($clear_update_cache) {
        }
        if (defined('RC_SITE')) {
            $cache_key = 'applications' . constant('RC_SITE');
        } else {
            $cache_key = 'applications';
        }
        RC_Cache::app_cache_delete($cache_key, 'system');
    }
    public static function app_dir_name($alias)
    {
        $alias_directory = self::alias_directory();
        if (isset($alias_directory[$alias])) {
            return $alias_directory[$alias];
        }
        return null;
    }
    public static function has_alias($alias)
    {
        $alias_directory = self::alias_directory();
        if (isset($alias_directory[$alias])) {
            return true;
        }
        return false;
    }
    public static function alias_directory()
    {
        static $alias_directory = array();
        $bundles = array();
        if (RC_Hook::has_filter('app_scan_bundles')) {
            $bundles = RC_Hook::apply_filters('app_scan_bundles', $bundles);
            if (!empty($bundles)) {
                foreach ($bundles as $bundle) {
                    $alias_directory[$bundle['alias']] = $bundle['directory'];
                }
            }
        } else {
            $alias_directory = \RC_Config::get('app');
        }
        return RC_Hook::apply_filters('app_alias_directory_handle', $alias_directory);
    }
}
}

namespace Royalcms\Component\App {
use Royalcms\Component\Support\Manager;
use RC_Hook;
use Royalcms\Component\Support\Facades\File as RC_File;
use Royalcms\Component\App\Bundles\AppBundle;
class AppManager extends Manager
{
    protected $alias = array();
    public function __construct($royalcms)
    {
        parent::__construct($royalcms);
        $this->loadSiteApps();
    }
    public function driver($name = null)
    {
        $bundle = parent::driver($name);
        if (empty($this->alias)) {
            $this->loadAppBundles();
        }
        $bundle = RC_Hook::apply_filters('app_load_bundle', $bundle);
        return $bundle;
    }
    public function hasAlias($alias)
    {
        if (isset($this->alias[$alias])) {
            return true;
        }
        return false;
    }
    public function getDirectory($name)
    {
        return array_get($this->alias, $name);
    }
    public function getAbsolutePath($name)
    {
        return $this->driver($name)->getAbsolutePath();
    }
    public function getDefaultDriver()
    {
        return config('route.default.' . config('route.module'));
    }
    protected function loadAppBundles()
    {
        $bundles = array();
        $alias = array();
        if (RC_Hook::has_filter('app_scan_bundles')) {
            $bundles = RC_Hook::apply_filters('app_scan_bundles', $bundles);
            if (!empty($bundles)) {
                foreach ($bundles as $bundle) {
                    $alias[$bundle['alias']] = $bundle['directory'];
                    if ($bundle['alias'] != $bundle['directory']) {
                        $alias[$bundle['directory']] = $bundle['directory'];
                    }
                }
            }
        } else {
            $alias = config('app');
        }
        $this->alias = RC_Hook::apply_filters('app_alias_directory_handle', $alias);
    }
    protected function loadSiteApps()
    {
        $app_roots = array(RC_APP_PATH, SITE_APP_PATH);
        $app_roots = array_unique($app_roots);
        foreach ($app_roots as $app_root) {
            if (file_exists($app_root)) {
                $apps_dir = RC_File::directories($app_root);
                foreach ($apps_dir as $path) {
                    $dir = basename($path);
                    $bundle = new AppBundle($dir);
                    if (!$bundle->getIdentifier()) {
                        continue;
                    }
                    $this->drivers[$bundle->getAlias()] = $bundle;
                    if ($bundle->getAlias() != $bundle->getDirectory()) {
                        $this->drivers[$bundle->getDirectory()] = $bundle;
                    }
                }
            }
        }
    }
}
}

namespace Royalcms\Component\App {
use Royalcms\Component\Error\Facades\Error as RC_Error;
use JsonSerializable;
abstract class BundleAbstract implements JsonSerializable
{
    protected $identifier;
    protected $directory;
    protected $alias;
    protected $site;
    protected $package;
    protected $namespace;
    protected $provider;
    protected $controllerPath;
    public function getIdentifier()
    {
        return $this->identifier;
    }
    public function getDirectory()
    {
        return $this->directory;
    }
    public function getAlias()
    {
        return $this->alias;
    }
    public function getNameSpace()
    {
        return $this->namespace;
    }
    public function getProvider()
    {
        return $this->provider;
    }
    public function getControllerPath()
    {
        return $this->controllerPath;
    }
    public function getControllerClassName($controller)
    {
        if (!royalcms('app')->hasAlias($this->alias)) {
            return RC_Error::make('not_register_route_app', '');
        }
        $controller_classname = $this->namespace . '\\Controllers\\' . $this->normalizeName($controller) . 'Controller';
        if (class_exists($controller_classname)) {
            return $controller_classname;
        }
        $app_controller = $this->controllerPath . $controller . '.php';
        if (!file_exists($app_controller)) {
            return RC_Error::make('controller_does_not_exist', "Controller {$app_controller} does not exist.");
        }
        include_once $app_controller;
        $controller_classname = $controller;
        $my_controller = $this->controllerPath . 'MY_' . $controller . '.php';
        if (file_exists($my_controller)) {
            $controller_classname = 'MY_' . $controller;
            include_once $my_controller;
        }
        return $controller_classname;
    }
    protected function appPackage($markup = true, $translate = true)
    {
        $package = $this->getPackageData();
        if ($package && $translate) {
            $package['format_name'] = __($package['name'], $this->getContainerName());
            $package['format_description'] = __($package['description'], $this->getContainerName());
        } else {
            $package['format_name'] = $package['name'];
            $package['format_description'] = $package['description'];
        }
        return $package;
    }
    public function getPackage($key = null)
    {
        if (is_null($key)) {
            return $this->package;
        }
        return array_get($this->package, $key);
    }
    public function getPackageData()
    {
        return config($this->getContainerName() . '::' . 'package');
    }
    public function getInstaller()
    {
        $namespace_class = $this->getNamespaceClassName('Installer');
        if (class_exists($namespace_class)) {
            return new $namespace_class();
        }
        $install_class = $this->directory . '_installer';
        if (class_exists($install_class)) {
            return new $install_class();
        }
        return RC_Error::make('class_not_found', sprintf(__("Class '%s' not found"), $install_class));
    }
    public function jsonSerialize()
    {
        return $this->toArray();
    }
    public function toArray()
    {
        return ['identifier' => $this->identifier, 'directory' => $this->directory, 'alias' => $this->alias, 'site' => $this->site, 'package' => $this->package, 'namespace' => $this->namespace, 'provider' => $this->provider, 'controllerPath' => $this->controllerPath];
    }
    protected function normalizeName($name)
    {
        $name = implode('', array_map('ucfirst', explode('-', $name)));
        $name = implode('', array_map('ucfirst', explode('_', $name)));
        $name = implode('\\', array_map('ucfirst', explode('/', $name)));
        return $name;
    }
    protected function getNamespaceClassName($class)
    {
        return $this->getNameSpace() . '\\' . $class;
    }
    public abstract function getContainerName();
}
}

namespace Royalcms\Component\App\Bundles {
use Royalcms\Component\App\Contracts\BundlePackage;
use Royalcms\Component\App\BundleAbstract;
class AppBundle extends BundleAbstract implements BundlePackage
{
    public function __construct($app_floder, $app_alias = null)
    {
        $this->directory = $app_floder;
        if (is_null($app_alias)) {
            $this->alias = $app_floder;
        } else {
            $this->alias = $app_alias;
        }
        $this->package = $this->appPackage();
        if (!empty($this->package)) {
            $this->identifier = $this->package['identifier'];
            $this->namespace = $this->package['namespace'];
            $this->provider = $this->namespace . '\\' . $this->package['provider'];
        }
        $this->site = defined('RC_SITE') ? RC_SITE : 'default';
        $this->makeControllerPath();
    }
    protected function makeControllerPath()
    {
        $this->controllerPath = $this->getAbsolutePath();
    }
    public function getAbsolutePath()
    {
        if ($this->site == 'default') {
            $path = RC_APP_PATH . $this->directory . DIRECTORY_SEPARATOR;
        } else {
            $path = SITE_APP_PATH . $this->directory . DIRECTORY_SEPARATOR;
            if (!file_exists($path)) {
                $path = RC_APP_PATH . $this->directory . DIRECTORY_SEPARATOR;
            }
        }
        return $path;
    }
    public function getContainerName()
    {
        return 'app-' . $this->directory;
    }
}
}

namespace Royalcms\Component\App\Contracts {
interface BundlePackage
{
    public function getAbsolutePath();
    public function getNamespace();
}
}

namespace Royalcms\Component\App {
use Royalcms\Component\DefaultRoute\HttpQueryRoute;
use RC_Hook;
use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use InvalidArgumentException;
use Royalcms\Component\Http\Response as RoyalcmsResponse;
class AppControllerDispatcher
{
    protected $route;
    protected $manager;
    protected $routePath;
    public function __construct()
    {
        $this->route = royalcms('default-router');
        $this->manager = royalcms('app');
        $this->routePath = $this->route->getModule() . '/' . $this->route->getController() . '/' . $this->route->getAction();
    }
    public function getRoute()
    {
        return $this->route;
    }
    public function dispatch()
    {
        $controller = $this->makeController();
        if ($controller instanceof RoyalcmsResponse) {
            return $controller;
        } elseif (is_rc_error($controller)) {
            if (RC_Hook::has_action('royalcms_default_controller')) {
                RC_Hook::do_action('royalcms_default_controller', $this->routePath);
            }
        }
        try {
            if (RC_Hook::has_action($this->routePath)) {
                RC_Hook::do_action($this->routePath);
                return royalcms('response');
            } else {
                $response = $this->route->runControllerAction($controller, $this->route->getAction());
                if ($response instanceof RoyalcmsResponse) {
                    if (!is_null($response->getOriginalContent())) {
                        return $response;
                    }
                }
                if (!is_null($response)) {
                    return $response;
                }
                return royalcms('response');
            }
        } catch (NotFoundHttpException $e) {
            abort(403, $e->getMessage());
        } catch (AccessDeniedHttpException $e) {
            abort(401, $e->getMessage());
        }
    }
    protected function makeController()
    {
        try {
            $bundle = $this->manager->driver($this->route->getModule());
            if (!$bundle) {
                abort(404, "App {$this->route->getModule()} does not found.");
            }
            $controller = $bundle->getControllerClassName($this->route->getController());
            return $controller;
        } catch (InvalidArgumentException $e) {
            abort(403, $e->getMessage());
        }
    }
    protected function before($instance, $route, $request, $method)
    {
        foreach ($instance->getBeforeFilters() as $filter) {
            if ($this->filterApplies($filter, $request, $method)) {
                $response = $this->callFilter($filter, $route, $request);
                if (!is_null($response)) {
                    return $response;
                }
            }
        }
    }
    protected function call($instance, $route, $method)
    {
        $parameters = $route->parametersWithoutNulls();
        return $instance->callAction($method, $parameters);
    }
}
}

namespace Royalcms\Component\App {
use Royalcms\Component\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms['app'] = $this->royalcms->share(function ($royalcms) {
            return new AppManager($royalcms);
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/app');
        return [$dir . "/Facades/App.php", $dir . "/AppManager.php", $dir . "/BundleAbstract.php", $dir . "/Bundles/AppBundle.php", $dir . "/Contracts/BundlePackage.php", $dir . "/AppControllerDispatcher.php", $dir . "/AppServiceProvider.php", $dir . "/AppParentServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\App {
use ReflectionClass;
use Royalcms\Component\Support\ServiceProvider;
abstract class AppParentServiceProvider extends ServiceProvider
{
    public function package($package, $namespace = null, $path = null)
    {
        $namespace = $this->getPackageNamespace($package, $namespace);
        $path = $path ?: $this->guessPackagePath($namespace);
        $config = $path . '/configs';
        if ($this->royalcms['files']->isDirectory($config)) {
            $this->royalcms['config']->package($package, $config, $namespace);
        }
        $lang = $path . '/languages';
        if ($this->royalcms['files']->isDirectory($lang)) {
            $this->royalcms['translator']->addNamespace($namespace, $lang);
            if (strpos($namespace, 'app-', 0) !== false) {
                $this->royalcms['translator']->addNamespace(str_replace('app-', '', $namespace), $lang);
            }
        }
        $appView = $this->getAppViewPath($package);
        if ($this->royalcms['files']->isDirectory($appView)) {
            $this->royalcms['view']->addNamespace($namespace, $appView);
        }
        $view = $path . '/templates';
        if ($this->royalcms['files']->isDirectory($view)) {
            $this->royalcms['view']->addNamespace($namespace, $view);
        }
    }
    public function guessPackagePath($namespace = null)
    {
        if (strpos($namespace, 'app-', 0) !== false) {
            $app = str_replace('app-', '', $namespace);
            return realpath($this->royalcms->appPath($app));
        }
        $path = with(new ReflectionClass($this))->getFileName();
        return realpath(dirname($path) . '/../');
    }
    protected function getPackageNamespace($package, $namespace)
    {
        if (is_null($namespace)) {
            list($vendor, $namespace) = explode('/', $package);
        }
        return $namespace;
    }
    public function commands($commands)
    {
        $commands = is_array($commands) ? $commands : func_get_args();
        $events = $this->royalcms['events'];
        $events->listen('royalcms.start', function ($royalcms) use($commands) {
            $royalcms->resolveCommands($commands);
        });
    }
    protected function getAppViewPath($package)
    {
        return $this->royalcms['path'] . "/views/packages/{$package}";
    }
}
}

namespace Royalcms\Component\Database\Eloquent {
use DateTime;
use Exception;
use ArrayAccess;
use Royalcms\Component\DateTime\Carbon;
use LogicException;
use JsonSerializable;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use Royalcms\Component\Contracts\Support\Jsonable;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Royalcms\Component\Contracts\Support\Arrayable;
use Royalcms\Component\Contracts\Routing\UrlRoutable;
use Royalcms\Component\Contracts\Queue\QueueableEntity;
use Royalcms\Component\Database\Eloquent\Relations\Pivot;
use Royalcms\Component\Database\Eloquent\Relations\HasOne;
use Royalcms\Component\Database\Eloquent\Relations\HasMany;
use Royalcms\Component\Database\Eloquent\Relations\MorphTo;
use Royalcms\Component\Database\Eloquent\Relations\Relation;
use Royalcms\Component\Database\Eloquent\Relations\MorphOne;
use Royalcms\Component\Support\Collection as BaseCollection;
use Royalcms\Component\Database\Eloquent\Relations\MorphMany;
use Royalcms\Component\Database\Eloquent\Relations\BelongsTo;
use Royalcms\Component\Database\Query\Builder as QueryBuilder;
use Royalcms\Component\Database\Eloquent\Relations\MorphToMany;
use Royalcms\Component\Database\Eloquent\Relations\BelongsToMany;
use Royalcms\Component\Database\Eloquent\Relations\HasManyThrough;
use Royalcms\Component\Database\ConnectionResolverInterface as Resolver;
abstract class Model implements ArrayAccess, Arrayable, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable
{
    protected $connection;
    protected $table;
    protected $primaryKey = 'id';
    protected $perPage = 15;
    public $incrementing = true;
    public $timestamps = true;
    protected $attributes = [];
    protected $original = [];
    protected $relations = [];
    protected $hidden = [];
    protected $visible = [];
    protected $appends = [];
    protected $fillable = [];
    protected $guarded = ['*'];
    protected $dates = [];
    protected $dateFormat;
    protected $casts = [];
    protected $touches = [];
    protected $observables = [];
    protected $with = [];
    protected $morphClass;
    public $exists = false;
    public $wasRecentlyCreated = false;
    public static $snakeAttributes = true;
    protected static $resolver;
    protected static $dispatcher;
    protected static $booted = [];
    protected static $globalScopes = [];
    protected static $unguarded = false;
    protected static $mutatorCache = [];
    public static $manyMethods = ['belongsToMany', 'morphToMany', 'morphedByMany'];
    const CREATED_AT = 'created_at';
    const UPDATED_AT = 'updated_at';
    public function __construct(array $attributes = [])
    {
        $this->bootIfNotBooted();
        $this->syncOriginal();
        $this->fill($attributes);
    }
    protected function bootIfNotBooted()
    {
        $class = get_class($this);
        if (!isset(static::$booted[$class])) {
            static::$booted[$class] = true;
            $this->fireModelEvent('booting', false);
            static::boot();
            $this->fireModelEvent('booted', false);
        }
    }
    protected static function boot()
    {
        static::bootTraits();
    }
    protected static function bootTraits()
    {
        foreach (class_uses_recursive(get_called_class()) as $trait) {
            if (method_exists(get_called_class(), $method = 'boot' . class_basename($trait))) {
                forward_static_call([get_called_class(), $method]);
            }
        }
    }
    public static function clearBootedModels()
    {
        static::$booted = [];
    }
    public static function addGlobalScope(ScopeInterface $scope)
    {
        static::$globalScopes[get_called_class()][get_class($scope)] = $scope;
    }
    public static function hasGlobalScope($scope)
    {
        return !is_null(static::getGlobalScope($scope));
    }
    public static function getGlobalScope($scope)
    {
        return Arr::first(static::$globalScopes[get_called_class()], function ($key, $value) use($scope) {
            return $scope instanceof $value;
        });
    }
    public function getGlobalScopes()
    {
        return Arr::get(static::$globalScopes, get_class($this), []);
    }
    public static function observe($class, $priority = 0)
    {
        $instance = new static();
        $className = is_string($class) ? $class : get_class($class);
        foreach ($instance->getObservableEvents() as $event) {
            if (method_exists($class, $event)) {
                static::registerModelEvent($event, $className . '@' . $event, $priority);
            }
        }
    }
    public function fill(array $attributes)
    {
        $totallyGuarded = $this->totallyGuarded();
        foreach ($this->fillableFromArray($attributes) as $key => $value) {
            $key = $this->removeTableFromKey($key);
            if ($this->isFillable($key)) {
                $this->setAttribute($key, $value);
            } elseif ($totallyGuarded) {
                throw new MassAssignmentException($key);
            }
        }
        return $this;
    }
    public function forceFill(array $attributes)
    {
        $model = $this;
        return static::unguarded(function () use($model, $attributes) {
            return $model->fill($attributes);
        });
    }
    protected function fillableFromArray(array $attributes)
    {
        if (count($this->fillable) > 0 && !static::$unguarded) {
            return array_intersect_key($attributes, array_flip($this->fillable));
        }
        return $attributes;
    }
    public function newInstance($attributes = [], $exists = false)
    {
        $model = new static((array) $attributes);
        $model->exists = $exists;
        return $model;
    }
    public function newFromBuilder($attributes = [], $connection = null)
    {
        $model = $this->newInstance([], true);
        $model->setRawAttributes((array) $attributes, true);
        $model->setConnection($connection ?: $this->connection);
        return $model;
    }
    public static function hydrate(array $items, $connection = null)
    {
        $instance = (new static())->setConnection($connection);
        $items = array_map(function ($item) use($instance) {
            return $instance->newFromBuilder($item);
        }, $items);
        return $instance->newCollection($items);
    }
    public static function hydrateRaw($query, $bindings = [], $connection = null)
    {
        $instance = (new static())->setConnection($connection);
        $items = $instance->getConnection()->select($query, $bindings);
        return static::hydrate($items, $connection);
    }
    public static function create(array $attributes = [])
    {
        $model = new static($attributes);
        $model->save();
        return $model;
    }
    public static function forceCreate(array $attributes)
    {
        $model = new static();
        return static::unguarded(function () use($model, $attributes) {
            return $model->create($attributes);
        });
    }
    public static function query()
    {
        return (new static())->newQuery();
    }
    public static function on($connection = null)
    {
        $instance = new static();
        $instance->setConnection($connection);
        return $instance->newQuery();
    }
    public static function onWriteConnection()
    {
        $instance = new static();
        return $instance->newQuery()->useWritePdo();
    }
    public static function all($columns = ['*'])
    {
        $columns = is_array($columns) ? $columns : func_get_args();
        $instance = new static();
        return $instance->newQuery()->get($columns);
    }
    public function fresh(array $with = [])
    {
        if (!$this->exists) {
            return;
        }
        $key = $this->getKeyName();
        return static::with($with)->where($key, $this->getKey())->first();
    }
    public function load($relations)
    {
        if (is_string($relations)) {
            $relations = func_get_args();
        }
        $query = $this->newQuery()->with($relations);
        $query->eagerLoadRelations([$this]);
        return $this;
    }
    public static function with($relations)
    {
        if (is_string($relations)) {
            $relations = func_get_args();
        }
        $instance = new static();
        return $instance->newQuery()->with($relations);
    }
    public function append($attributes)
    {
        if (is_string($attributes)) {
            $attributes = func_get_args();
        }
        $this->appends = array_unique(array_merge($this->appends, $attributes));
        return $this;
    }
    public function hasOne($related, $foreignKey = null, $localKey = null)
    {
        $foreignKey = $foreignKey ?: $this->getForeignKey();
        $instance = new $related();
        $localKey = $localKey ?: $this->getKeyName();
        return new HasOne($instance->newQuery(), $this, $instance->getTable() . '.' . $foreignKey, $localKey);
    }
    public function morphOne($related, $name, $type = null, $id = null, $localKey = null)
    {
        $instance = new $related();
        list($type, $id) = $this->getMorphs($name, $type, $id);
        $table = $instance->getTable();
        $localKey = $localKey ?: $this->getKeyName();
        return new MorphOne($instance->newQuery(), $this, $table . '.' . $type, $table . '.' . $id, $localKey);
    }
    public function belongsTo($related, $foreignKey = null, $otherKey = null, $relation = null)
    {
        if (is_null($relation)) {
            list($current, $caller) = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);
            $relation = $caller['function'];
        }
        if (is_null($foreignKey)) {
            $foreignKey = Str::snake($relation) . '_id';
        }
        $instance = new $related();
        $query = $instance->newQuery();
        $otherKey = $otherKey ?: $instance->getKeyName();
        return new BelongsTo($query, $this, $foreignKey, $otherKey, $relation);
    }
    public function morphTo($name = null, $type = null, $id = null)
    {
        if (is_null($name)) {
            list($current, $caller) = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 2);
            $name = Str::snake($caller['function']);
        }
        list($type, $id) = $this->getMorphs($name, $type, $id);
        if (empty($class = $this->{$type})) {
            return new MorphTo($this->newQuery()->setEagerLoads([]), $this, $id, null, $type, $name);
        } else {
            $class = $this->getActualClassNameForMorph($class);
            $instance = new $class();
            return new MorphTo($instance->newQuery(), $this, $id, $instance->getKeyName(), $type, $name);
        }
    }
    public function getActualClassNameForMorph($class)
    {
        return Arr::get(Relation::morphMap(), $class, $class);
    }
    public function hasMany($related, $foreignKey = null, $localKey = null)
    {
        $foreignKey = $foreignKey ?: $this->getForeignKey();
        $instance = new $related();
        $localKey = $localKey ?: $this->getKeyName();
        return new HasMany($instance->newQuery(), $this, $instance->getTable() . '.' . $foreignKey, $localKey);
    }
    public function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null)
    {
        $through = new $through();
        $firstKey = $firstKey ?: $this->getForeignKey();
        $secondKey = $secondKey ?: $through->getForeignKey();
        $localKey = $localKey ?: $this->getKeyName();
        return new HasManyThrough((new $related())->newQuery(), $this, $through, $firstKey, $secondKey, $localKey);
    }
    public function morphMany($related, $name, $type = null, $id = null, $localKey = null)
    {
        $instance = new $related();
        list($type, $id) = $this->getMorphs($name, $type, $id);
        $table = $instance->getTable();
        $localKey = $localKey ?: $this->getKeyName();
        return new MorphMany($instance->newQuery(), $this, $table . '.' . $type, $table . '.' . $id, $localKey);
    }
    public function belongsToMany($related, $table = null, $foreignKey = null, $otherKey = null, $relation = null)
    {
        if (is_null($relation)) {
            $relation = $this->getBelongsToManyCaller();
        }
        $foreignKey = $foreignKey ?: $this->getForeignKey();
        $instance = new $related();
        $otherKey = $otherKey ?: $instance->getForeignKey();
        if (is_null($table)) {
            $table = $this->joiningTable($related);
        }
        $query = $instance->newQuery();
        return new BelongsToMany($query, $this, $table, $foreignKey, $otherKey, $relation);
    }
    public function morphToMany($related, $name, $table = null, $foreignKey = null, $otherKey = null, $inverse = false)
    {
        $caller = $this->getBelongsToManyCaller();
        $foreignKey = $foreignKey ?: $name . '_id';
        $instance = new $related();
        $otherKey = $otherKey ?: $instance->getForeignKey();
        $query = $instance->newQuery();
        $table = $table ?: Str::plural($name);
        return new MorphToMany($query, $this, $name, $table, $foreignKey, $otherKey, $caller, $inverse);
    }
    public function morphedByMany($related, $name, $table = null, $foreignKey = null, $otherKey = null)
    {
        $foreignKey = $foreignKey ?: $this->getForeignKey();
        $otherKey = $otherKey ?: $name . '_id';
        return $this->morphToMany($related, $name, $table, $foreignKey, $otherKey, true);
    }
    protected function getBelongsToManyCaller()
    {
        $self = __FUNCTION__;
        $caller = Arr::first(debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS), function ($key, $trace) use($self) {
            $caller = $trace['function'];
            return !in_array($caller, Model::$manyMethods) && $caller != $self;
        });
        return !is_null($caller) ? $caller['function'] : null;
    }
    public function joiningTable($related)
    {
        $base = Str::snake(class_basename($this));
        $related = Str::snake(class_basename($related));
        $models = [$related, $base];
        sort($models);
        return strtolower(implode('_', $models));
    }
    public static function destroy($ids)
    {
        $count = 0;
        $ids = is_array($ids) ? $ids : func_get_args();
        $instance = new static();
        $key = $instance->getKeyName();
        foreach ($instance->whereIn($key, $ids)->get() as $model) {
            if ($model->delete()) {
                $count++;
            }
        }
        return $count;
    }
    public function delete()
    {
        if (is_null($this->getKeyName())) {
            throw new Exception('No primary key defined on model.');
        }
        if ($this->exists) {
            if ($this->fireModelEvent('deleting') === false) {
                return false;
            }
            $this->touchOwners();
            $this->performDeleteOnModel();
            $this->exists = false;
            $this->fireModelEvent('deleted', false);
            return true;
        }
    }
    public function forceDelete()
    {
        return $this->delete();
    }
    protected function performDeleteOnModel()
    {
        $this->setKeysForSaveQuery($this->newQueryWithoutScopes())->delete();
    }
    public static function saving($callback, $priority = 0)
    {
        static::registerModelEvent('saving', $callback, $priority);
    }
    public static function saved($callback, $priority = 0)
    {
        static::registerModelEvent('saved', $callback, $priority);
    }
    public static function updating($callback, $priority = 0)
    {
        static::registerModelEvent('updating', $callback, $priority);
    }
    public static function updated($callback, $priority = 0)
    {
        static::registerModelEvent('updated', $callback, $priority);
    }
    public static function creating($callback, $priority = 0)
    {
        static::registerModelEvent('creating', $callback, $priority);
    }
    public static function created($callback, $priority = 0)
    {
        static::registerModelEvent('created', $callback, $priority);
    }
    public static function deleting($callback, $priority = 0)
    {
        static::registerModelEvent('deleting', $callback, $priority);
    }
    public static function deleted($callback, $priority = 0)
    {
        static::registerModelEvent('deleted', $callback, $priority);
    }
    public static function flushEventListeners()
    {
        if (!isset(static::$dispatcher)) {
            return;
        }
        $instance = new static();
        foreach ($instance->getObservableEvents() as $event) {
            static::$dispatcher->forget("eloquent.{$event}: " . get_called_class());
        }
    }
    protected static function registerModelEvent($event, $callback, $priority = 0)
    {
        if (isset(static::$dispatcher)) {
            $name = get_called_class();
            static::$dispatcher->listen("eloquent.{$event}: {$name}", $callback, $priority);
        }
    }
    public function getObservableEvents()
    {
        return array_merge(['creating', 'created', 'updating', 'updated', 'deleting', 'deleted', 'saving', 'saved', 'restoring', 'restored'], $this->observables);
    }
    public function setObservableEvents(array $observables)
    {
        $this->observables = $observables;
        return $this;
    }
    public function addObservableEvents($observables)
    {
        $observables = is_array($observables) ? $observables : func_get_args();
        $this->observables = array_unique(array_merge($this->observables, $observables));
    }
    public function removeObservableEvents($observables)
    {
        $observables = is_array($observables) ? $observables : func_get_args();
        $this->observables = array_diff($this->observables, $observables);
    }
    protected function increment($column, $amount = 1)
    {
        return $this->incrementOrDecrement($column, $amount, 'increment');
    }
    protected function decrement($column, $amount = 1)
    {
        return $this->incrementOrDecrement($column, $amount, 'decrement');
    }
    protected function incrementOrDecrement($column, $amount, $method)
    {
        $query = $this->newQuery();
        if (!$this->exists) {
            return $query->{$method}($column, $amount);
        }
        $this->incrementOrDecrementAttributeValue($column, $amount, $method);
        return $query->where($this->getKeyName(), $this->getKey())->{$method}($column, $amount);
    }
    protected function incrementOrDecrementAttributeValue($column, $amount, $method)
    {
        $this->{$column} = $this->{$column} + ($method == 'increment' ? $amount : $amount * -1);
        $this->syncOriginalAttribute($column);
    }
    public function update(array $attributes = [])
    {
        if (!$this->exists) {
            return false;
        }
        return $this->fill($attributes)->save();
    }
    public function push()
    {
        if (!$this->save()) {
            return false;
        }
        foreach ($this->relations as $models) {
            $models = $models instanceof Collection ? $models->all() : [$models];
            foreach (array_filter($models) as $model) {
                if (!$model->push()) {
                    return false;
                }
            }
        }
        return true;
    }
    public function save(array $options = [])
    {
        $query = $this->newQueryWithoutScopes();
        if ($this->fireModelEvent('saving') === false) {
            return false;
        }
        if ($this->exists) {
            $saved = $this->performUpdate($query, $options);
        } else {
            $saved = $this->performInsert($query, $options);
        }
        if ($saved) {
            $this->finishSave($options);
        }
        return $saved;
    }
    public function saveOrFail(array $options = [])
    {
        return $this->getConnection()->transaction(function () use($options) {
            return $this->save($options);
        });
    }
    protected function finishSave(array $options)
    {
        $this->fireModelEvent('saved', false);
        $this->syncOriginal();
        if (Arr::get($options, 'touch', true)) {
            $this->touchOwners();
        }
    }
    protected function performUpdate(Builder $query, array $options = [])
    {
        $dirty = $this->getDirty();
        if (count($dirty) > 0) {
            if ($this->fireModelEvent('updating') === false) {
                return false;
            }
            if ($this->timestamps && Arr::get($options, 'timestamps', true)) {
                $this->updateTimestamps();
            }
            $dirty = $this->getDirty();
            if (count($dirty) > 0) {
                $numRows = $this->setKeysForSaveQuery($query)->update($dirty);
                $this->fireModelEvent('updated', false);
            }
        }
        return true;
    }
    protected function performInsert(Builder $query, array $options = [])
    {
        if ($this->fireModelEvent('creating') === false) {
            return false;
        }
        if ($this->timestamps && Arr::get($options, 'timestamps', true)) {
            $this->updateTimestamps();
        }
        $attributes = $this->attributes;
        if ($this->incrementing) {
            $this->insertAndSetId($query, $attributes);
        } else {
            $query->insert($attributes);
        }
        $this->exists = true;
        $this->wasRecentlyCreated = true;
        $this->fireModelEvent('created', false);
        return true;
    }
    protected function insertAndSetId(Builder $query, $attributes)
    {
        $id = $query->insertGetId($attributes, $keyName = $this->getKeyName());
        $this->setAttribute($keyName, $id);
    }
    public function touchOwners()
    {
        foreach ($this->touches as $relation) {
            $this->{$relation}()->touch();
            if ($this->{$relation} instanceof self) {
                $this->{$relation}->fireModelEvent('saved', false);
                $this->{$relation}->touchOwners();
            } elseif ($this->{$relation} instanceof Collection) {
                $this->{$relation}->each(function (Model $relation) {
                    $relation->touchOwners();
                });
            }
        }
    }
    public function touches($relation)
    {
        return in_array($relation, $this->touches);
    }
    protected function fireModelEvent($event, $halt = true)
    {
        if (!isset(static::$dispatcher)) {
            return true;
        }
        $event = "eloquent.{$event}: " . get_class($this);
        $method = $halt ? 'until' : 'fire';
        return static::$dispatcher->{$method}($event, $this);
    }
    protected function setKeysForSaveQuery(Builder $query)
    {
        $query->where($this->getKeyName(), '=', $this->getKeyForSaveQuery());
        return $query;
    }
    protected function getKeyForSaveQuery()
    {
        if (isset($this->original[$this->getKeyName()])) {
            return $this->original[$this->getKeyName()];
        }
        return $this->getAttribute($this->getKeyName());
    }
    public function touch()
    {
        if (!$this->timestamps) {
            return false;
        }
        $this->updateTimestamps();
        return $this->save();
    }
    protected function updateTimestamps()
    {
        $time = $this->freshTimestamp();
        if (!$this->isDirty(static::UPDATED_AT)) {
            $this->setUpdatedAt($time);
        }
        if (!$this->exists && !$this->isDirty(static::CREATED_AT)) {
            $this->setCreatedAt($time);
        }
    }
    public function setCreatedAt($value)
    {
        $this->{static::CREATED_AT} = $value;
        return $this;
    }
    public function setUpdatedAt($value)
    {
        $this->{static::UPDATED_AT} = $value;
        return $this;
    }
    public function getCreatedAtColumn()
    {
        return static::CREATED_AT;
    }
    public function getUpdatedAtColumn()
    {
        return static::UPDATED_AT;
    }
    public function freshTimestamp()
    {
        return new Carbon();
    }
    public function freshTimestampString()
    {
        return $this->fromDateTime($this->freshTimestamp());
    }
    public function newQuery()
    {
        $builder = $this->newQueryWithoutScopes();
        return $this->applyGlobalScopes($builder);
    }
    public function newQueryWithoutScope($scope)
    {
        $this->getGlobalScope($scope)->remove($builder = $this->newQuery(), $this);
        return $builder;
    }
    public function newQueryWithoutScopes()
    {
        $builder = $this->newEloquentBuilder($this->newBaseQueryBuilder());
        return $builder->setModel($this)->with($this->with);
    }
    public function applyGlobalScopes($builder)
    {
        foreach ($this->getGlobalScopes() as $scope) {
            $scope->apply($builder, $this);
        }
        return $builder;
    }
    public function removeGlobalScopes($builder)
    {
        foreach ($this->getGlobalScopes() as $scope) {
            $scope->remove($builder, $this);
        }
        return $builder;
    }
    public function newEloquentBuilder($query)
    {
        return new Builder($query);
    }
    protected function newBaseQueryBuilder()
    {
        $conn = $this->getConnection();
        $grammar = $conn->getQueryGrammar();
        return new QueryBuilder($conn, $grammar, $conn->getPostProcessor());
    }
    public function newCollection(array $models = [])
    {
        return new Collection($models);
    }
    public function newPivot(Model $parent, array $attributes, $table, $exists)
    {
        return new Pivot($parent, $attributes, $table, $exists);
    }
    public function getTable()
    {
        if (isset($this->table)) {
            return $this->table;
        }
        return str_replace('\\', '', Str::snake(Str::plural(class_basename($this))));
    }
    public function setTable($table)
    {
        $this->table = $table;
        return $this;
    }
    public function getKey()
    {
        return $this->getAttribute($this->getKeyName());
    }
    public function getQueueableId()
    {
        return $this->getKey();
    }
    public function getKeyName()
    {
        return $this->primaryKey;
    }
    public function setKeyName($key)
    {
        $this->primaryKey = $key;
        return $this;
    }
    public function getQualifiedKeyName()
    {
        return $this->getTable() . '.' . $this->getKeyName();
    }
    public function getRouteKey()
    {
        return $this->getAttribute($this->getRouteKeyName());
    }
    public function getRouteKeyName()
    {
        return $this->getKeyName();
    }
    public function usesTimestamps()
    {
        return $this->timestamps;
    }
    protected function getMorphs($name, $type, $id)
    {
        $type = $type ?: $name . '_type';
        $id = $id ?: $name . '_id';
        return [$type, $id];
    }
    public function getMorphClass()
    {
        $morphMap = Relation::morphMap();
        $class = get_class($this);
        if (!empty($morphMap) && in_array($class, $morphMap)) {
            return array_search($class, $morphMap, true);
        }
        return $this->morphClass ?: $class;
    }
    public function getPerPage()
    {
        return $this->perPage;
    }
    public function setPerPage($perPage)
    {
        $this->perPage = $perPage;
        return $this;
    }
    public function getForeignKey()
    {
        return Str::snake(class_basename($this)) . '_id';
    }
    public function getHidden()
    {
        return $this->hidden;
    }
    public function setHidden(array $hidden)
    {
        $this->hidden = $hidden;
        return $this;
    }
    public function addHidden($attributes = null)
    {
        $attributes = is_array($attributes) ? $attributes : func_get_args();
        $this->hidden = array_merge($this->hidden, $attributes);
    }
    public function withHidden($attributes)
    {
        $this->hidden = array_diff($this->hidden, (array) $attributes);
        return $this;
    }
    public function getVisible()
    {
        return $this->visible;
    }
    public function setVisible(array $visible)
    {
        $this->visible = $visible;
        return $this;
    }
    public function addVisible($attributes = null)
    {
        $attributes = is_array($attributes) ? $attributes : func_get_args();
        $this->visible = array_merge($this->visible, $attributes);
    }
    public function setAppends(array $appends)
    {
        $this->appends = $appends;
        return $this;
    }
    public function getFillable()
    {
        return $this->fillable;
    }
    public function fillable(array $fillable)
    {
        $this->fillable = $fillable;
        return $this;
    }
    public function getGuarded()
    {
        return $this->guarded;
    }
    public function guard(array $guarded)
    {
        $this->guarded = $guarded;
        return $this;
    }
    public static function unguard($state = true)
    {
        static::$unguarded = $state;
    }
    public static function reguard()
    {
        static::$unguarded = false;
    }
    public static function isUnguarded()
    {
        return static::$unguarded;
    }
    public static function unguarded(callable $callback)
    {
        if (static::$unguarded) {
            return $callback();
        }
        static::unguard();
        try {
            return $callback();
        } finally {
            static::reguard();
        }
    }
    public function isFillable($key)
    {
        if (static::$unguarded) {
            return true;
        }
        if (in_array($key, $this->fillable)) {
            return true;
        }
        if ($this->isGuarded($key)) {
            return false;
        }
        return empty($this->fillable) && !Str::startsWith($key, '_');
    }
    public function isGuarded($key)
    {
        return in_array($key, $this->guarded) || $this->guarded == ['*'];
    }
    public function totallyGuarded()
    {
        return count($this->fillable) == 0 && $this->guarded == ['*'];
    }
    protected function removeTableFromKey($key)
    {
        if (!Str::contains($key, '.')) {
            return $key;
        }
        return last(explode('.', $key));
    }
    public function getTouchedRelations()
    {
        return $this->touches;
    }
    public function setTouchedRelations(array $touches)
    {
        $this->touches = $touches;
        return $this;
    }
    public function getIncrementing()
    {
        return $this->incrementing;
    }
    public function setIncrementing($value)
    {
        $this->incrementing = $value;
        return $this;
    }
    public function toJson($options = 0)
    {
        return json_encode($this->jsonSerialize(), $options);
    }
    public function jsonSerialize()
    {
        return $this->toArray();
    }
    public function toArray()
    {
        $attributes = $this->attributesToArray();
        return array_merge($attributes, $this->relationsToArray());
    }
    public function attributesToArray()
    {
        $attributes = $this->getArrayableAttributes();
        foreach ($this->getDates() as $key) {
            if (!isset($attributes[$key])) {
                continue;
            }
            $attributes[$key] = $this->serializeDate($this->asDateTime($attributes[$key]));
        }
        $mutatedAttributes = $this->getMutatedAttributes();
        foreach ($mutatedAttributes as $key) {
            if (!array_key_exists($key, $attributes)) {
                continue;
            }
            $attributes[$key] = $this->mutateAttributeForArray($key, $attributes[$key]);
        }
        foreach ($this->casts as $key => $value) {
            if (!array_key_exists($key, $attributes) || in_array($key, $mutatedAttributes)) {
                continue;
            }
            $attributes[$key] = $this->castAttribute($key, $attributes[$key]);
            if ($attributes[$key] && ($value === 'date' || $value === 'datetime')) {
                $attributes[$key] = $this->serializeDate($attributes[$key]);
            }
        }
        foreach ($this->getArrayableAppends() as $key) {
            $attributes[$key] = $this->mutateAttributeForArray($key, null);
        }
        return $attributes;
    }
    protected function getArrayableAttributes()
    {
        return $this->getArrayableItems($this->attributes);
    }
    protected function getArrayableAppends()
    {
        if (!count($this->appends)) {
            return [];
        }
        return $this->getArrayableItems(array_combine($this->appends, $this->appends));
    }
    public function relationsToArray()
    {
        $attributes = [];
        foreach ($this->getArrayableRelations() as $key => $value) {
            if ($value instanceof Arrayable) {
                $relation = $value->toArray();
            } elseif (is_null($value)) {
                $relation = $value;
            }
            if (static::$snakeAttributes) {
                $key = Str::snake($key);
            }
            if (isset($relation) || is_null($value)) {
                $attributes[$key] = $relation;
            }
            unset($relation);
        }
        return $attributes;
    }
    protected function getArrayableRelations()
    {
        return $this->getArrayableItems($this->relations);
    }
    protected function getArrayableItems(array $values)
    {
        if (count($this->getVisible()) > 0) {
            return array_intersect_key($values, array_flip($this->getVisible()));
        }
        return array_diff_key($values, array_flip($this->getHidden()));
    }
    public function getAttribute($key)
    {
        if (array_key_exists($key, $this->attributes) || $this->hasGetMutator($key)) {
            return $this->getAttributeValue($key);
        }
        return $this->getRelationValue($key);
    }
    public function getAttributeValue($key)
    {
        $value = $this->getAttributeFromArray($key);
        if ($this->hasGetMutator($key)) {
            return $this->mutateAttribute($key, $value);
        }
        if ($this->hasCast($key)) {
            $value = $this->castAttribute($key, $value);
        } elseif (in_array($key, $this->getDates())) {
            if (!is_null($value)) {
                return $this->asDateTime($value);
            }
        }
        return $value;
    }
    public function getRelationValue($key)
    {
        if ($this->relationLoaded($key)) {
            return $this->relations[$key];
        }
        if (method_exists($this, $key)) {
            return $this->getRelationshipFromMethod($key);
        }
    }
    protected function getAttributeFromArray($key)
    {
        if (array_key_exists($key, $this->attributes)) {
            return $this->attributes[$key];
        }
    }
    protected function getRelationshipFromMethod($method)
    {
        $relations = $this->{$method}();
        if (!$relations instanceof Relation) {
            throw new LogicException('Relationship method must return an object of type ' . 'Royalcms\\Component\\Database\\Eloquent\\Relations\\Relation');
        }
        return $this->relations[$method] = $relations->getResults();
    }
    public function hasGetMutator($key)
    {
        return method_exists($this, 'get' . Str::studly($key) . 'Attribute');
    }
    protected function mutateAttribute($key, $value)
    {
        return $this->{'get' . Str::studly($key) . 'Attribute'}($value);
    }
    protected function mutateAttributeForArray($key, $value)
    {
        $value = $this->mutateAttribute($key, $value);
        return $value instanceof Arrayable ? $value->toArray() : $value;
    }
    public function hasCast($key, $types = null)
    {
        if (array_key_exists($key, $this->getCasts())) {
            return $types ? in_array($this->getCastType($key), (array) $types, true) : true;
        }
        return false;
    }
    public function getCasts()
    {
        if ($this->getIncrementing()) {
            return array_merge([$this->getKeyName() => $this->keyType], $this->casts);
        }
        return $this->casts;
    }
    protected function isDateCastable($key)
    {
        return $this->hasCast($key) && in_array($this->getCastType($key), ['date', 'datetime'], true);
    }
    protected function isJsonCastable($key)
    {
        return $this->hasCast($key) && in_array($this->getCastType($key), ['array', 'json', 'object', 'collection'], true);
    }
    protected function getCastType($key)
    {
        return trim(strtolower($this->casts[$key]));
    }
    protected function castAttribute($key, $value)
    {
        if (is_null($value)) {
            return $value;
        }
        switch ($this->getCastType($key)) {
            case 'int':
            case 'integer':
                return (int) $value;
            case 'real':
            case 'float':
            case 'double':
                return (double) $value;
            case 'string':
                return (string) $value;
            case 'bool':
            case 'boolean':
                return (bool) $value;
            case 'object':
                return $this->fromJson($value, true);
            case 'array':
            case 'json':
                return $this->fromJson($value);
            case 'collection':
                return new BaseCollection($this->fromJson($value));
            case 'date':
            case 'datetime':
                return $this->asDateTime($value);
            default:
                return $value;
        }
    }
    public function setAttribute($key, $value)
    {
        if ($this->hasSetMutator($key)) {
            $method = 'set' . Str::studly($key) . 'Attribute';
            return $this->{$method}($value);
        } elseif ($value && (in_array($key, $this->getDates()) || $this->isDateCastable($key))) {
            $value = $this->fromDateTime($value);
        }
        if ($this->isJsonCastable($key) && !is_null($value)) {
            $value = $this->asJson($value);
        }
        $this->attributes[$key] = $value;
        return $this;
    }
    public function hasSetMutator($key)
    {
        return method_exists($this, 'set' . Str::studly($key) . 'Attribute');
    }
    public function getDates()
    {
        $defaults = [static::CREATED_AT, static::UPDATED_AT];
        return $this->timestamps ? array_merge($this->dates, $defaults) : $this->dates;
    }
    public function fromDateTime($value)
    {
        $format = $this->getDateFormat();
        $value = $this->asDateTime($value);
        return $value->format($format);
    }
    protected function asDateTime($value)
    {
        if ($value instanceof Carbon) {
            return $value;
        }
        if ($value instanceof DateTime) {
            return Carbon::instance($value);
        }
        if (is_numeric($value)) {
            return Carbon::createFromTimestamp($value);
        }
        if (preg_match('/^(\\d{4})-(\\d{2})-(\\d{2})$/', $value)) {
            return Carbon::createFromFormat('Y-m-d', $value)->startOfDay();
        }
        return Carbon::createFromFormat($this->getDateFormat(), $value);
    }
    protected function serializeDate(DateTime $date)
    {
        return $date->format($this->getDateFormat());
    }
    protected function getDateFormat()
    {
        return $this->dateFormat ?: $this->getConnection()->getQueryGrammar()->getDateFormat();
    }
    public function setDateFormat($format)
    {
        $this->dateFormat = $format;
        return $this;
    }
    protected function asJson($value)
    {
        return json_encode($value);
    }
    public function fromJson($value, $asObject = false)
    {
        return json_decode($value, !$asObject);
    }
    public function replicate(array $except = null)
    {
        $except = $except ?: [$this->getKeyName(), $this->getCreatedAtColumn(), $this->getUpdatedAtColumn()];
        $attributes = Arr::except($this->attributes, $except);
        with($instance = new static())->setRawAttributes($attributes);
        return $instance->setRelations($this->relations);
    }
    public function getAttributes()
    {
        return $this->attributes;
    }
    public function setRawAttributes(array $attributes, $sync = false)
    {
        $this->attributes = $attributes;
        if ($sync) {
            $this->syncOriginal();
        }
        return $this;
    }
    public function getOriginal($key = null, $default = null)
    {
        return Arr::get($this->original, $key, $default);
    }
    public function syncOriginal()
    {
        $this->original = $this->attributes;
        return $this;
    }
    public function syncOriginalAttribute($attribute)
    {
        $this->original[$attribute] = $this->attributes[$attribute];
        return $this;
    }
    public function isDirty($attributes = null)
    {
        $dirty = $this->getDirty();
        if (is_null($attributes)) {
            return count($dirty) > 0;
        }
        if (!is_array($attributes)) {
            $attributes = func_get_args();
        }
        foreach ($attributes as $attribute) {
            if (array_key_exists($attribute, $dirty)) {
                return true;
            }
        }
        return false;
    }
    public function getDirty()
    {
        $dirty = [];
        foreach ($this->attributes as $key => $value) {
            if (!array_key_exists($key, $this->original)) {
                $dirty[$key] = $value;
            } elseif ($value !== $this->original[$key] && !$this->originalIsNumericallyEquivalent($key)) {
                $dirty[$key] = $value;
            }
        }
        return $dirty;
    }
    protected function originalIsNumericallyEquivalent($key)
    {
        $current = $this->attributes[$key];
        $original = $this->original[$key];
        return is_numeric($current) && is_numeric($original) && strcmp((string) $current, (string) $original) === 0;
    }
    public function getRelations()
    {
        return $this->relations;
    }
    public function getRelation($relation)
    {
        return $this->relations[$relation];
    }
    public function relationLoaded($key)
    {
        return array_key_exists($key, $this->relations);
    }
    public function setRelation($relation, $value)
    {
        $this->relations[$relation] = $value;
        return $this;
    }
    public function setRelations(array $relations)
    {
        $this->relations = $relations;
        return $this;
    }
    public function getConnection()
    {
        return static::resolveConnection($this->connection);
    }
    public function getConnectionName()
    {
        return $this->connection;
    }
    public function setConnection($name)
    {
        $this->connection = $name;
        return $this;
    }
    public static function resolveConnection($connection = null)
    {
        return static::$resolver->connection($connection);
    }
    public static function getConnectionResolver()
    {
        return static::$resolver;
    }
    public static function setConnectionResolver(Resolver $resolver)
    {
        static::$resolver = $resolver;
    }
    public static function unsetConnectionResolver()
    {
        static::$resolver = null;
    }
    public static function getEventDispatcher()
    {
        return static::$dispatcher;
    }
    public static function setEventDispatcher(Dispatcher $dispatcher)
    {
        static::$dispatcher = $dispatcher;
    }
    public static function unsetEventDispatcher()
    {
        static::$dispatcher = null;
    }
    public function getMutatedAttributes()
    {
        $class = get_class($this);
        if (!isset(static::$mutatorCache[$class])) {
            static::cacheMutatedAttributes($class);
        }
        return static::$mutatorCache[$class];
    }
    public static function cacheMutatedAttributes($class)
    {
        $mutatedAttributes = [];
        if (preg_match_all('/(?<=^|;)get([^;]+?)Attribute(;|$)/', implode(';', get_class_methods($class)), $matches)) {
            foreach ($matches[1] as $match) {
                if (static::$snakeAttributes) {
                    $match = Str::snake($match);
                }
                $mutatedAttributes[] = lcfirst($match);
            }
        }
        static::$mutatorCache[$class] = $mutatedAttributes;
    }
    public function __get($key)
    {
        return $this->getAttribute($key);
    }
    public function __set($key, $value)
    {
        $this->setAttribute($key, $value);
    }
    public function offsetExists($offset)
    {
        return isset($this->{$offset});
    }
    public function offsetGet($offset)
    {
        return $this->{$offset};
    }
    public function offsetSet($offset, $value)
    {
        $this->{$offset} = $value;
    }
    public function offsetUnset($offset)
    {
        unset($this->{$offset});
    }
    public function __isset($key)
    {
        if (isset($this->attributes[$key]) || isset($this->relations[$key])) {
            return true;
        }
        if (method_exists($this, $key) && $this->{$key} && isset($this->relations[$key])) {
            return true;
        }
        return $this->hasGetMutator($key) && !is_null($this->getAttributeValue($key));
    }
    public function __unset($key)
    {
        unset($this->attributes[$key], $this->relations[$key]);
    }
    public function __call($method, $parameters)
    {
        if (in_array($method, ['increment', 'decrement'])) {
            return call_user_func_array([$this, $method], $parameters);
        }
        $query = $this->newQuery();
        return call_user_func_array([$query, $method], $parameters);
    }
    public static function __callStatic($method, $parameters)
    {
        $instance = new static();
        return call_user_func_array([$instance, $method], $parameters);
    }
    public function __toString()
    {
        return $this->toJson();
    }
    public function __wakeup()
    {
        $this->bootIfNotBooted();
    }
}
}

namespace Royalcms\Component\Database {
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\Str;
use InvalidArgumentException;
use Royalcms\Component\Database\Connectors\ConnectionFactory;
class DatabaseManager implements ConnectionResolverInterface
{
    protected $royalcms;
    protected $factory;
    protected $connections = [];
    protected $extensions = [];
    public function __construct($royalcms, ConnectionFactory $factory)
    {
        $this->royalcms = $royalcms;
        $this->factory = $factory;
    }
    public function connection($name = null)
    {
        list($name, $type) = $this->parseConnectionName($name);
        if (!isset($this->connections[$name])) {
            $connection = $this->makeConnection($name);
            $this->setPdoForType($connection, $type);
            $this->connections[$name] = $this->prepare($connection);
        }
        return $this->connections[$name];
    }
    protected function parseConnectionName($name)
    {
        $name = $name ?: $this->getDefaultConnection();
        return Str::endsWith($name, ['::read', '::write']) ? explode('::', $name, 2) : [$name, null];
    }
    public function purge($name = null)
    {
        $this->disconnect($name);
        unset($this->connections[$name]);
    }
    public function disconnect($name = null)
    {
        if (isset($this->connections[$name = $name ?: $this->getDefaultConnection()])) {
            $this->connections[$name]->disconnect();
        }
    }
    public function reconnect($name = null)
    {
        $this->disconnect($name = $name ?: $this->getDefaultConnection());
        if (!isset($this->connections[$name])) {
            return $this->connection($name);
        }
        return $this->refreshPdoConnections($name);
    }
    protected function refreshPdoConnections($name)
    {
        $fresh = $this->makeConnection($name);
        return $this->connections[$name]->setPdo($fresh->getPdo())->setReadPdo($fresh->getReadPdo());
    }
    protected function makeConnection($name)
    {
        $config = $this->getConfig($name);
        if (isset($this->extensions[$name])) {
            return call_user_func($this->extensions[$name], $config, $name);
        }
        $driver = $config['driver'];
        if (isset($this->extensions[$driver])) {
            return call_user_func($this->extensions[$driver], $config, $name);
        }
        return $this->factory->make($config, $name);
    }
    protected function prepare(Connection $connection)
    {
        $connection->setFetchMode($this->royalcms['config']['database.fetch']);
        if ($this->royalcms->bound('events')) {
            $connection->setEventDispatcher($this->royalcms['events']);
        }
        $connection->setReconnector(function ($connection) {
            $this->reconnect($connection->getName());
        });
        return $connection;
    }
    protected function setPdoForType(Connection $connection, $type = null)
    {
        if ($type == 'read') {
            $connection->setPdo($connection->getReadPdo());
        } elseif ($type == 'write') {
            $connection->setReadPdo($connection->getPdo());
        }
        return $connection;
    }
    protected function getConfig($name)
    {
        $name = $name ?: $this->getDefaultConnection();
        $connections = $this->royalcms['config']['database.connections'];
        if (is_null($config = Arr::get($connections, $name))) {
            throw new InvalidArgumentException("Database [{$name}] not configured.");
        }
        return $config;
    }
    public function getDefaultConnection()
    {
        return $this->royalcms['config']['database.default'];
    }
    public function setDefaultConnection($name)
    {
        $this->royalcms['config']['database.default'] = $name;
    }
    public function extend($name, callable $resolver)
    {
        $this->extensions[$name] = $resolver;
    }
    public function getConnections()
    {
        return $this->connections;
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->connection(), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Database {
interface ConnectionResolverInterface
{
    public function connection($name = null);
    public function getDefaultConnection();
    public function setDefaultConnection($name);
}
}

namespace Royalcms\Component\Database\Connectors {
use PDO;
use Exception;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Database\DetectsLostConnections;
class Connector
{
    use DetectsLostConnections;
    protected $options = [PDO::ATTR_CASE => PDO::CASE_NATURAL, PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_ORACLE_NULLS => PDO::NULL_NATURAL, PDO::ATTR_STRINGIFY_FETCHES => false, PDO::ATTR_EMULATE_PREPARES => false];
    public function getOptions(array $config)
    {
        $options = Arr::get($config, 'options', []);
        return array_diff_key($this->options, $options) + $options;
    }
    public function createConnection($dsn, array $config, array $options)
    {
        $username = Arr::get($config, 'username');
        $password = Arr::get($config, 'password');
        try {
            $pdo = new PDO($dsn, $username, $password, $options);
        } catch (Exception $e) {
            $pdo = $this->tryAgainIfCausedByLostConnection($e, $dsn, $username, $password, $options);
        }
        return $pdo;
    }
    public function getDefaultOptions()
    {
        return $this->options;
    }
    public function setDefaultOptions(array $options)
    {
        $this->options = $options;
    }
    protected function tryAgainIfCausedByLostConnection(Exception $e, $dsn, $username, $password, $options)
    {
        if ($this->causedByLostConnection($e)) {
            return new PDO($dsn, $username, $password, $options);
        }
        throw $e;
    }
}
}

namespace Royalcms\Component\Database\Connectors {
use PDO;
use Royalcms\Component\Support\Arr;
use InvalidArgumentException;
use Royalcms\Component\Database\MySqlConnection;
use Royalcms\Component\Database\SQLiteConnection;
use Royalcms\Component\Database\PostgresConnection;
use Royalcms\Component\Database\SqlServerConnection;
use Royalcms\Component\Contracts\Container\Container;
class ConnectionFactory
{
    protected $container;
    public function __construct(Container $container)
    {
        $this->container = $container;
    }
    public function make(array $config, $name = null)
    {
        $config = $this->parseConfig($config, $name);
        if (isset($config['read'])) {
            return $this->createReadWriteConnection($config);
        }
        return $this->createSingleConnection($config);
    }
    protected function createSingleConnection(array $config)
    {
        $pdo = $this->createConnector($config)->connect($config);
        return $this->createConnection($config['driver'], $pdo, $config['database'], $config['prefix'], $config);
    }
    protected function createReadWriteConnection(array $config)
    {
        $connection = $this->createSingleConnection($this->getWriteConfig($config));
        return $connection->setReadPdo($this->createReadPdo($config));
    }
    protected function createReadPdo(array $config)
    {
        $readConfig = $this->getReadConfig($config);
        return $this->createConnector($readConfig)->connect($readConfig);
    }
    protected function getReadConfig(array $config)
    {
        $readConfig = $this->getReadWriteConfig($config, 'read');
        if (isset($readConfig['host']) && is_array($readConfig['host'])) {
            $readConfig['host'] = count($readConfig['host']) > 1 ? $readConfig['host'][array_rand($readConfig['host'])] : $readConfig['host'][0];
        }
        return $this->mergeReadWriteConfig($config, $readConfig);
    }
    protected function getWriteConfig(array $config)
    {
        $writeConfig = $this->getReadWriteConfig($config, 'write');
        return $this->mergeReadWriteConfig($config, $writeConfig);
    }
    protected function getReadWriteConfig(array $config, $type)
    {
        if (isset($config[$type][0])) {
            return $config[$type][array_rand($config[$type])];
        }
        return $config[$type];
    }
    protected function mergeReadWriteConfig(array $config, array $merge)
    {
        return Arr::except(array_merge($config, $merge), ['read', 'write']);
    }
    protected function parseConfig(array $config, $name)
    {
        return Arr::add(Arr::add($config, 'prefix', ''), 'name', $name);
    }
    public function createConnector(array $config)
    {
        if (!isset($config['driver'])) {
            throw new InvalidArgumentException('A driver must be specified.');
        }
        if ($this->container->bound($key = "db.connector.{$config['driver']}")) {
            return $this->container->make($key);
        }
        switch ($config['driver']) {
            case 'mysql':
                return new MySqlConnector();
            case 'pgsql':
                return new PostgresConnector();
            case 'sqlite':
                return new SQLiteConnector();
            case 'sqlsrv':
                return new SqlServerConnector();
        }
        throw new InvalidArgumentException("Unsupported driver [{$config['driver']}]");
    }
    protected function createConnection($driver, PDO $connection, $database, $prefix = '', array $config = [])
    {
        if ($this->container->bound($key = "db.connection.{$driver}")) {
            return $this->container->make($key, [$connection, $database, $prefix, $config]);
        }
        switch ($driver) {
            case 'mysql':
                return new MySqlConnection($connection, $database, $prefix, $config);
            case 'pgsql':
                return new PostgresConnection($connection, $database, $prefix, $config);
            case 'sqlite':
                return new SQLiteConnection($connection, $database, $prefix, $config);
            case 'sqlsrv':
                return new SqlServerConnection($connection, $database, $prefix, $config);
        }
        throw new InvalidArgumentException("Unsupported driver [{$driver}]");
    }
}
}

namespace Royalcms\Component\Database\Connectors {
interface ConnectorInterface
{
    public function connect(array $config);
}
}

namespace Royalcms\Component\Database {
use Exception;
use Royalcms\Component\Support\Str;
trait DetectsLostConnections
{
    protected function causedByLostConnection(Exception $e)
    {
        $message = $e->getMessage();
        return Str::contains($message, ['server has gone away', 'no connection to the server', 'Lost connection', 'is dead or not enabled', 'Error while sending', 'decryption failed or bad record mac', 'server closed the connection unexpectedly', 'SSL connection has been closed unexpectedly', 'Error writing data to the connection', 'Resource deadlock avoided']);
    }
}
}

namespace Royalcms\Component\Database {
use PDO;
use Closure;
use Exception;
use Throwable;
use LogicException;
use RuntimeException;
use DateTimeInterface;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Database\Query\Expression;
use Royalcms\Component\Contracts\Events\Dispatcher;
use Royalcms\Component\Database\Query\Processors\Processor;
use Doctrine\DBAL\Connection as DoctrineConnection;
use Royalcms\Component\Database\Query\Builder as QueryBuilder;
use Royalcms\Component\Database\Schema\Builder as SchemaBuilder;
use Royalcms\Component\Database\Query\Grammars\Grammar as QueryGrammar;
class Connection implements ConnectionInterface
{
    use DetectsLostConnections;
    protected $pdo;
    protected $readPdo;
    protected $reconnector;
    protected $queryGrammar;
    protected $schemaGrammar;
    protected $postProcessor;
    protected $events;
    protected $fetchMode = PDO::FETCH_OBJ;
    protected $transactions = 0;
    protected $queryLog = [];
    protected $loggingQueries = false;
    protected $pretending = false;
    protected $database;
    protected $doctrineConnection;
    protected $tablePrefix = '';
    protected $config = [];
    public function __construct(PDO $pdo, $database = '', $tablePrefix = '', array $config = [])
    {
        $this->pdo = $pdo;
        $this->database = $database;
        $this->tablePrefix = $tablePrefix;
        $this->config = $config;
        $this->useDefaultQueryGrammar();
        $this->useDefaultPostProcessor();
    }
    public function useDefaultQueryGrammar()
    {
        $this->queryGrammar = $this->getDefaultQueryGrammar();
    }
    protected function getDefaultQueryGrammar()
    {
        return new QueryGrammar();
    }
    public function useDefaultSchemaGrammar()
    {
        $this->schemaGrammar = $this->getDefaultSchemaGrammar();
    }
    protected function getDefaultSchemaGrammar()
    {
    }
    public function useDefaultPostProcessor()
    {
        $this->postProcessor = $this->getDefaultPostProcessor();
    }
    protected function getDefaultPostProcessor()
    {
        return new Processor();
    }
    public function getSchemaBuilder()
    {
        if (is_null($this->schemaGrammar)) {
            $this->useDefaultSchemaGrammar();
        }
        return new SchemaBuilder($this);
    }
    public function table($table)
    {
        return $this->query()->from($table);
    }
    public function query()
    {
        return new QueryBuilder($this, $this->getQueryGrammar(), $this->getPostProcessor());
    }
    public function raw($value)
    {
        return new Expression($value);
    }
    public function selectOne($query, $bindings = [])
    {
        $records = $this->select($query, $bindings);
        return count($records) > 0 ? reset($records) : null;
    }
    public function selectFromWriteConnection($query, $bindings = [])
    {
        return $this->select($query, $bindings, false);
    }
    public function select($query, $bindings = [], $useReadPdo = true)
    {
        return $this->run($query, $bindings, function ($me, $query, $bindings) use($useReadPdo) {
            if ($me->pretending()) {
                return [];
            }
            $statement = $this->getPdoForSelect($useReadPdo)->prepare($query);
            $statement->execute($me->prepareBindings($bindings));
            return $statement->fetchAll($me->getFetchMode());
        });
    }
    protected function getPdoForSelect($useReadPdo = true)
    {
        return $useReadPdo ? $this->getReadPdo() : $this->getPdo();
    }
    public function insert($query, $bindings = [])
    {
        return $this->statement($query, $bindings);
    }
    public function update($query, $bindings = [])
    {
        return $this->affectingStatement($query, $bindings);
    }
    public function delete($query, $bindings = [])
    {
        return $this->affectingStatement($query, $bindings);
    }
    public function statement($query, $bindings = [])
    {
        return $this->run($query, $bindings, function ($me, $query, $bindings) {
            if ($me->pretending()) {
                return true;
            }
            $bindings = $me->prepareBindings($bindings);
            return $me->getPdo()->prepare($query)->execute($bindings);
        });
    }
    public function affectingStatement($query, $bindings = [])
    {
        return $this->run($query, $bindings, function ($me, $query, $bindings) {
            if ($me->pretending()) {
                return 0;
            }
            $statement = $me->getPdo()->prepare($query);
            $statement->execute($me->prepareBindings($bindings));
            return $statement->rowCount();
        });
    }
    public function unprepared($query)
    {
        return $this->run($query, [], function ($me, $query) {
            if ($me->pretending()) {
                return true;
            }
            return (bool) $me->getPdo()->exec($query);
        });
    }
    public function prepareBindings(array $bindings)
    {
        $grammar = $this->getQueryGrammar();
        foreach ($bindings as $key => $value) {
            if ($value instanceof DateTimeInterface) {
                $bindings[$key] = $value->format($grammar->getDateFormat());
            } elseif ($value === false) {
                $bindings[$key] = 0;
            }
        }
        return $bindings;
    }
    public function transaction(Closure $callback)
    {
        $this->beginTransaction();
        try {
            $result = $callback($this);
            $this->commit();
        } catch (Exception $e) {
            $this->rollBack();
            throw $e;
        } catch (Throwable $e) {
            $this->rollBack();
            throw $e;
        }
        return $result;
    }
    public function beginTransaction()
    {
        ++$this->transactions;
        if ($this->transactions == 1) {
            try {
                $this->pdo->beginTransaction();
            } catch (Exception $e) {
                --$this->transactions;
                throw $e;
            }
        } elseif ($this->transactions > 1 && $this->queryGrammar->supportsSavepoints()) {
            $this->pdo->exec($this->queryGrammar->compileSavepoint('trans' . $this->transactions));
        }
        $this->fireConnectionEvent('beganTransaction');
    }
    public function commit()
    {
        if ($this->transactions == 1) {
            $this->pdo->commit();
        }
        --$this->transactions;
        $this->fireConnectionEvent('committed');
    }
    public function rollBack()
    {
        if ($this->transactions == 1) {
            $this->pdo->rollBack();
        } elseif ($this->transactions > 1 && $this->queryGrammar->supportsSavepoints()) {
            $this->pdo->exec($this->queryGrammar->compileSavepointRollBack('trans' . $this->transactions));
        }
        $this->transactions = max(0, $this->transactions - 1);
        $this->fireConnectionEvent('rollingBack');
    }
    public function transactionLevel()
    {
        return $this->transactions;
    }
    public function pretend(Closure $callback)
    {
        $loggingQueries = $this->loggingQueries;
        $this->enableQueryLog();
        $this->pretending = true;
        $this->queryLog = [];
        $callback($this);
        $this->pretending = false;
        $this->loggingQueries = $loggingQueries;
        return $this->queryLog;
    }
    protected function run($query, $bindings, Closure $callback)
    {
        $this->reconnectIfMissingConnection();
        $start = microtime(true);
        try {
            $result = $this->runQueryCallback($query, $bindings, $callback);
        } catch (QueryException $e) {
            if ($this->transactions >= 1) {
                throw $e;
            }
            $result = $this->tryAgainIfCausedByLostConnection($e, $query, $bindings, $callback);
        }
        $time = $this->getElapsedTime($start);
        $this->logQuery($query, $bindings, $time);
        return $result;
    }
    protected function runQueryCallback($query, $bindings, Closure $callback)
    {
        try {
            $result = $callback($this, $query, $bindings);
        } catch (Exception $e) {
            throw new QueryException($query, $this->prepareBindings($bindings), $e);
        }
        return $result;
    }
    protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)
    {
        if ($this->causedByLostConnection($e->getPrevious())) {
            $this->reconnect();
            return $this->runQueryCallback($query, $bindings, $callback);
        }
        throw $e;
    }
    public function disconnect()
    {
        $this->setPdo(null)->setReadPdo(null);
    }
    public function reconnect()
    {
        if (is_callable($this->reconnector)) {
            return call_user_func($this->reconnector, $this);
        }
        throw new LogicException('Lost connection and no reconnector available.');
    }
    protected function reconnectIfMissingConnection()
    {
        if (is_null($this->getPdo()) || is_null($this->getReadPdo())) {
            $this->reconnect();
        }
    }
    public function logQuery($query, $bindings, $time = null)
    {
        if (isset($this->events)) {
            $this->events->fire('royalcms.query', [$query, $bindings, $time, $this->getName()]);
        }
        if (!$this->loggingQueries) {
            return;
        }
        $this->queryLog[] = compact('query', 'bindings', 'time');
    }
    public function listen(Closure $callback)
    {
        if (isset($this->events)) {
            $this->events->listen('royalcms.query', $callback);
        }
    }
    protected function fireConnectionEvent($event)
    {
        if (isset($this->events)) {
            $this->events->fire('connection.' . $this->getName() . '.' . $event, $this);
        }
    }
    protected function getElapsedTime($start)
    {
        return round((microtime(true) - $start) * 1000, 2);
    }
    public function isDoctrineAvailable()
    {
        return class_exists('Doctrine\\DBAL\\Connection');
    }
    public function getDoctrineColumn($table, $column)
    {
        $schema = $this->getDoctrineSchemaManager();
        return $schema->listTableDetails($table)->getColumn($column);
    }
    public function getDoctrineSchemaManager()
    {
        return $this->getDoctrineDriver()->getSchemaManager($this->getDoctrineConnection());
    }
    public function getDoctrineConnection()
    {
        if (is_null($this->doctrineConnection)) {
            $driver = $this->getDoctrineDriver();
            $data = ['pdo' => $this->pdo, 'dbname' => $this->getConfig('database')];
            $this->doctrineConnection = new DoctrineConnection($data, $driver);
        }
        return $this->doctrineConnection;
    }
    public function getPdo()
    {
        return $this->pdo;
    }
    public function getReadPdo()
    {
        if ($this->transactions >= 1) {
            return $this->getPdo();
        }
        return $this->readPdo ?: $this->pdo;
    }
    public function setPdo($pdo)
    {
        if ($this->transactions >= 1) {
            throw new RuntimeException("Can't swap PDO instance while within transaction.");
        }
        $this->pdo = $pdo;
        return $this;
    }
    public function setReadPdo($pdo)
    {
        $this->readPdo = $pdo;
        return $this;
    }
    public function setReconnector(callable $reconnector)
    {
        $this->reconnector = $reconnector;
        return $this;
    }
    public function getName()
    {
        return $this->getConfig('name');
    }
    public function getConfig($option)
    {
        return Arr::get($this->config, $option);
    }
    public function getDriverName()
    {
        return $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);
    }
    public function getQueryGrammar()
    {
        return $this->queryGrammar;
    }
    public function setQueryGrammar(Query\Grammars\Grammar $grammar)
    {
        $this->queryGrammar = $grammar;
    }
    public function getSchemaGrammar()
    {
        return $this->schemaGrammar;
    }
    public function setSchemaGrammar(Schema\Grammars\Grammar $grammar)
    {
        $this->schemaGrammar = $grammar;
    }
    public function getPostProcessor()
    {
        return $this->postProcessor;
    }
    public function setPostProcessor(Processor $processor)
    {
        $this->postProcessor = $processor;
    }
    public function getEventDispatcher()
    {
        return $this->events;
    }
    public function setEventDispatcher(Dispatcher $events)
    {
        $this->events = $events;
    }
    public function pretending()
    {
        return $this->pretending === true;
    }
    public function getFetchMode()
    {
        return $this->fetchMode;
    }
    public function setFetchMode($fetchMode)
    {
        $this->fetchMode = $fetchMode;
    }
    public function getQueryLog()
    {
        return $this->queryLog;
    }
    public function flushQueryLog()
    {
        $this->queryLog = [];
    }
    public function enableQueryLog()
    {
        $this->loggingQueries = true;
    }
    public function disableQueryLog()
    {
        $this->loggingQueries = false;
    }
    public function logging()
    {
        return $this->loggingQueries;
    }
    public function getDatabaseName()
    {
        return $this->database;
    }
    public function setDatabaseName($database)
    {
        $this->database = $database;
    }
    public function getTableFullName($table)
    {
        return $this->tablePrefix . $table;
    }
    public function getTablePrefix()
    {
        return $this->tablePrefix;
    }
    public function setTablePrefix($prefix)
    {
        $this->tablePrefix = $prefix;
        $this->getQueryGrammar()->setTablePrefix($prefix);
    }
    public function withTablePrefix(Grammar $grammar)
    {
        $grammar->setTablePrefix($this->tablePrefix);
        return $grammar;
    }
}
}

namespace Royalcms\Component\Database {
use Closure;
interface ConnectionInterface
{
    public function table($table);
    public function raw($value);
    public function selectOne($query, $bindings = []);
    public function select($query, $bindings = []);
    public function insert($query, $bindings = []);
    public function update($query, $bindings = []);
    public function delete($query, $bindings = []);
    public function statement($query, $bindings = []);
    public function affectingStatement($query, $bindings = []);
    public function unprepared($query);
    public function prepareBindings(array $bindings);
    public function transaction(Closure $callback);
    public function beginTransaction();
    public function commit();
    public function rollBack();
    public function transactionLevel();
    public function pretend(Closure $callback);
}
}

namespace Royalcms\Component\Database {
use Royalcms\Component\Database\Query\Expression;
abstract class Grammar
{
    protected $tablePrefix = '';
    public function wrapArray(array $values)
    {
        return array_map([$this, 'wrap'], $values);
    }
    public function wrapTable($table)
    {
        if ($this->isExpression($table)) {
            return $this->getValue($table);
        }
        return $this->wrap($this->tablePrefix . $table, false);
    }
    public function wrap($value, $prefixAlias = false)
    {
        if ($this->isExpression($value)) {
            return $this->getValue($value);
        }
        if (strpos(strtolower($value), ' as ') !== false) {
            $segments = explode(' ', $value);
            if ($prefixAlias) {
                $segments[2] = $this->tablePrefix . $segments[2];
            }
            return $this->wrap($segments[0]) . ' as ' . $this->wrapValue($segments[2]);
        }
        $wrapped = [];
        $segments = explode('.', $value);
        foreach ($segments as $key => $segment) {
            if ($key == 0 && count($segments) > 1) {
                $wrapped[] = $this->wrapTable($segment);
            } else {
                $wrapped[] = $this->wrapValue($segment);
            }
        }
        return implode('.', $wrapped);
    }
    protected function wrapValue($value)
    {
        if ($value === '*') {
            return $value;
        }
        return '"' . str_replace('"', '""', $value) . '"';
    }
    public function columnize(array $columns)
    {
        return implode(', ', array_map([$this, 'wrap'], $columns));
    }
    public function parameterize(array $values)
    {
        return implode(', ', array_map([$this, 'parameter'], $values));
    }
    public function parameter($value)
    {
        return $this->isExpression($value) ? $this->getValue($value) : '?';
    }
    public function getValue($expression)
    {
        return $expression->getValue();
    }
    public function isExpression($value)
    {
        return $value instanceof Expression;
    }
    public function getDateFormat()
    {
        return 'Y-m-d H:i:s';
    }
    public function getTablePrefix()
    {
        return $this->tablePrefix;
    }
    public function setTablePrefix($prefix)
    {
        $this->tablePrefix = $prefix;
        return $this;
    }
}
}

namespace Royalcms\Component\Database\Query\Processors {
class MySqlProcessor extends Processor
{
    public function processColumnListing($results)
    {
        $mapping = function ($r) {
            $r = (object) $r;
            return $r->column_name;
        };
        return array_map($mapping, $results);
    }
}
}

namespace Royalcms\Component\Database\Query\Processors {
use Royalcms\Component\Database\Query\Builder;
class Processor
{
    public function processSelect(Builder $query, $results)
    {
        return $results;
    }
    public function processInsertGetId(Builder $query, $sql, $values, $sequence = null)
    {
        $query->getConnection()->insert($sql, $values);
        $id = $query->getConnection()->getPdo()->lastInsertId($sequence);
        return is_numeric($id) ? (int) $id : $id;
    }
    public function processColumnListing($results)
    {
        return $results;
    }
}
}

namespace Royalcms\Component\Database\Connectors {
class MySqlConnector extends Connector implements ConnectorInterface
{
    public function connect(array $config)
    {
        $dsn = $this->getDsn($config);
        $options = $this->getOptions($config);
        $connection = $this->createConnection($dsn, $config, $options);
        if (!empty($config['database'])) {
            $connection->exec("use `{$config['database']}`;");
        }
        $collation = $config['collation'];
        if (isset($config['charset'])) {
            $charset = $config['charset'];
            $names = "set names '{$charset}'" . (!is_null($collation) ? " collate '{$collation}'" : '');
            $connection->prepare($names)->execute();
        }
        if (isset($config['timezone'])) {
            $connection->prepare('set time_zone="' . $config['timezone'] . '"')->execute();
        }
        $this->setModes($connection, $config);
        return $connection;
    }
    protected function getDsn(array $config)
    {
        return $this->configHasSocket($config) ? $this->getSocketDsn($config) : $this->getHostDsn($config);
    }
    protected function configHasSocket(array $config)
    {
        return isset($config['unix_socket']) && !empty($config['unix_socket']);
    }
    protected function getSocketDsn(array $config)
    {
        return "mysql:unix_socket={$config['unix_socket']};dbname={$config['database']}";
    }
    protected function getHostDsn(array $config)
    {
        $host = $database = $port = null;
        extract($config, EXTR_IF_EXISTS);
        return isset($port) ? "mysql:host={$host};port={$port};dbname={$database}" : "mysql:host={$host};dbname={$database}";
    }
    protected function setModes(\PDO $connection, array $config)
    {
        if (isset($config['modes'])) {
            $this->setCustomModes($connection, $config);
        } elseif (isset($config['strict'])) {
            if ($config['strict']) {
                $connection->prepare($this->strictMode())->execute();
            } else {
                $connection->prepare("set session sql_mode='NO_ENGINE_SUBSTITUTION'")->execute();
            }
        }
    }
    protected function setCustomModes(\PDO $connection, array $config)
    {
        $modes = implode(',', $config['modes']);
        $connection->prepare("set session sql_mode='{$modes}'")->execute();
    }
    protected function strictMode()
    {
        return "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'";
    }
}
}

namespace Royalcms\Component\Database {
use Royalcms\Component\Database\Schema\MySqlBuilder;
use Royalcms\Component\Database\Query\Processors\MySqlProcessor;
use Doctrine\DBAL\Driver\PDOMySql\Driver as DoctrineDriver;
use Royalcms\Component\Database\Query\Grammars\MySqlGrammar as QueryGrammar;
use Royalcms\Component\Database\Schema\Grammars\MySqlGrammar as SchemaGrammar;
class MySqlConnection extends Connection
{
    public function getSchemaBuilder()
    {
        if (is_null($this->schemaGrammar)) {
            $this->useDefaultSchemaGrammar();
        }
        return new MySqlBuilder($this);
    }
    protected function getDefaultQueryGrammar()
    {
        return $this->withTablePrefix(new QueryGrammar());
    }
    protected function getDefaultSchemaGrammar()
    {
        return $this->withTablePrefix(new SchemaGrammar());
    }
    protected function getDefaultPostProcessor()
    {
        return new MySqlProcessor();
    }
    protected function getDoctrineDriver()
    {
        return new DoctrineDriver();
    }
}
}

namespace Royalcms\Component\Database\Query\Grammars {
use Royalcms\Component\Database\Query\Builder;
class MySqlGrammar extends Grammar
{
    protected $selectComponents = ['aggregate', 'columns', 'from', 'joins', 'wheres', 'groups', 'havings', 'orders', 'limit', 'offset', 'lock'];
    public function compileSelect(Builder $query)
    {
        $sql = parent::compileSelect($query);
        if ($query->unions) {
            $sql = '(' . $sql . ') ' . $this->compileUnions($query);
        }
        return $sql;
    }
    protected function compileUnion(array $union)
    {
        $joiner = $union['all'] ? ' union all ' : ' union ';
        return $joiner . '(' . $union['query']->toSql() . ')';
    }
    protected function compileLock(Builder $query, $value)
    {
        if (is_string($value)) {
            return $value;
        }
        return $value ? 'for update' : 'lock in share mode';
    }
    public function compileUpdate(Builder $query, $values)
    {
        $sql = parent::compileUpdate($query, $values);
        if (isset($query->orders)) {
            $sql .= ' ' . $this->compileOrders($query, $query->orders);
        }
        if (isset($query->limit)) {
            $sql .= ' ' . $this->compileLimit($query, $query->limit);
        }
        return rtrim($sql);
    }
    public function compileDelete(Builder $query)
    {
        $table = $this->wrapTable($query->from);
        $where = is_array($query->wheres) ? $this->compileWheres($query) : '';
        if (isset($query->joins)) {
            $joins = ' ' . $this->compileJoins($query, $query->joins);
            $sql = trim("delete {$table} from {$table}{$joins} {$where}");
        } else {
            $sql = trim("delete from {$table} {$where}");
            if (isset($query->orders)) {
                $sql .= ' ' . $this->compileOrders($query, $query->orders);
            }
            if (isset($query->limit)) {
                $sql .= ' ' . $this->compileLimit($query, $query->limit);
            }
        }
        return $sql;
    }
    protected function wrapValue($value)
    {
        if ($value === '*') {
            return $value;
        }
        return '`' . str_replace('`', '``', $value) . '`';
    }
}
}

namespace Royalcms\Component\Database\Query\Grammars {
use Royalcms\Component\Database\Query\Builder;
use Royalcms\Component\Database\Grammar as BaseGrammar;
class Grammar extends BaseGrammar
{
    protected $selectComponents = ['aggregate', 'columns', 'from', 'joins', 'wheres', 'groups', 'havings', 'orders', 'limit', 'offset', 'unions', 'lock'];
    public function compileSelect(Builder $query)
    {
        if (is_null($query->columns)) {
            $query->columns = ['*'];
        }
        return trim($this->concatenate($this->compileComponents($query)));
    }
    protected function compileComponents(Builder $query)
    {
        $sql = [];
        foreach ($this->selectComponents as $component) {
            if (!is_null($query->{$component})) {
                $method = 'compile' . ucfirst($component);
                $sql[$component] = $this->{$method}($query, $query->{$component});
            }
        }
        return $sql;
    }
    protected function compileAggregate(Builder $query, $aggregate)
    {
        $column = $this->columnize($aggregate['columns']);
        if ($query->distinct && $column !== '*') {
            $column = 'distinct ' . $column;
        }
        return 'select ' . $aggregate['function'] . '(' . $column . ') as aggregate';
    }
    protected function compileColumns(Builder $query, $columns)
    {
        if (!is_null($query->aggregate)) {
            return;
        }
        $select = $query->distinct ? 'select distinct ' : 'select ';
        return $select . $this->columnize($columns);
    }
    protected function compileFrom(Builder $query, $table)
    {
        return 'from ' . $this->wrapTable($table);
    }
    protected function compileJoins(Builder $query, $joins)
    {
        $sql = [];
        foreach ($joins as $join) {
            $table = $this->wrapTable($join->table);
            $clauses = [];
            foreach ($join->clauses as $clause) {
                $clauses[] = $this->compileJoinConstraint($clause);
            }
            $clauses[0] = $this->removeLeadingBoolean($clauses[0]);
            $clauses = implode(' ', $clauses);
            $type = $join->type;
            $sql[] = "{$type} join {$table} on {$clauses}";
        }
        return implode(' ', $sql);
    }
    protected function compileJoinConstraint(array $clause)
    {
        if ($clause['nested']) {
            return $this->compileNestedJoinConstraint($clause);
        }
        $first = $this->wrap($clause['first']);
        if ($clause['where']) {
            if ($clause['operator'] === 'in' || $clause['operator'] === 'not in') {
                $second = '(' . implode(', ', array_fill(0, $clause['second'], '?')) . ')';
            } else {
                $second = '?';
            }
        } else {
            $second = $this->wrap($clause['second']);
        }
        return "{$clause['boolean']} {$first} {$clause['operator']} {$second}";
    }
    protected function compileNestedJoinConstraint(array $clause)
    {
        $clauses = [];
        foreach ($clause['join']->clauses as $nestedClause) {
            $clauses[] = $this->compileJoinConstraint($nestedClause);
        }
        $clauses[0] = $this->removeLeadingBoolean($clauses[0]);
        $clauses = implode(' ', $clauses);
        return "{$clause['boolean']} ({$clauses})";
    }
    protected function compileWheres(Builder $query)
    {
        $sql = [];
        if (is_null($query->wheres)) {
            return '';
        }
        foreach ($query->wheres as $where) {
            $method = "where{$where['type']}";
            $sql[] = $where['boolean'] . ' ' . $this->{$method}($query, $where);
        }
        if (count($sql) > 0) {
            $sql = implode(' ', $sql);
            return 'where ' . $this->removeLeadingBoolean($sql);
        }
        return '';
    }
    protected function whereNested(Builder $query, $where)
    {
        $nested = $where['query'];
        return '(' . substr($this->compileWheres($nested), 6) . ')';
    }
    protected function whereSub(Builder $query, $where)
    {
        $select = $this->compileSelect($where['query']);
        return $this->wrap($where['column']) . ' ' . $where['operator'] . " ({$select})";
    }
    protected function whereBasic(Builder $query, $where)
    {
        $value = $this->parameter($where['value']);
        return $this->wrap($where['column']) . ' ' . $where['operator'] . ' ' . $value;
    }
    protected function whereBetween(Builder $query, $where)
    {
        $between = $where['not'] ? 'not between' : 'between';
        return $this->wrap($where['column']) . ' ' . $between . ' ? and ?';
    }
    protected function whereExists(Builder $query, $where)
    {
        return 'exists (' . $this->compileSelect($where['query']) . ')';
    }
    protected function whereNotExists(Builder $query, $where)
    {
        return 'not exists (' . $this->compileSelect($where['query']) . ')';
    }
    protected function whereIn(Builder $query, $where)
    {
        if (empty($where['values'])) {
            return '0 = 1';
        }
        $values = $this->parameterize($where['values']);
        return $this->wrap($where['column']) . ' in (' . $values . ')';
    }
    protected function whereNotIn(Builder $query, $where)
    {
        if (empty($where['values'])) {
            return '1 = 1';
        }
        $values = $this->parameterize($where['values']);
        return $this->wrap($where['column']) . ' not in (' . $values . ')';
    }
    protected function whereInSub(Builder $query, $where)
    {
        $select = $this->compileSelect($where['query']);
        return $this->wrap($where['column']) . ' in (' . $select . ')';
    }
    protected function whereNotInSub(Builder $query, $where)
    {
        $select = $this->compileSelect($where['query']);
        return $this->wrap($where['column']) . ' not in (' . $select . ')';
    }
    protected function whereNull(Builder $query, $where)
    {
        return $this->wrap($where['column']) . ' is null';
    }
    protected function whereNotNull(Builder $query, $where)
    {
        return $this->wrap($where['column']) . ' is not null';
    }
    protected function whereDate(Builder $query, $where)
    {
        return $this->dateBasedWhere('date', $query, $where);
    }
    protected function whereDay(Builder $query, $where)
    {
        return $this->dateBasedWhere('day', $query, $where);
    }
    protected function whereMonth(Builder $query, $where)
    {
        return $this->dateBasedWhere('month', $query, $where);
    }
    protected function whereYear(Builder $query, $where)
    {
        return $this->dateBasedWhere('year', $query, $where);
    }
    protected function dateBasedWhere($type, Builder $query, $where)
    {
        $value = $this->parameter($where['value']);
        return $type . '(' . $this->wrap($where['column']) . ') ' . $where['operator'] . ' ' . $value;
    }
    protected function whereRaw(Builder $query, $where)
    {
        return $where['sql'];
    }
    protected function compileGroups(Builder $query, $groups)
    {
        return 'group by ' . $this->columnize($groups);
    }
    protected function compileHavings(Builder $query, $havings)
    {
        $sql = implode(' ', array_map([$this, 'compileHaving'], $havings));
        return 'having ' . $this->removeLeadingBoolean($sql);
    }
    protected function compileHaving(array $having)
    {
        if ($having['type'] === 'raw') {
            return $having['boolean'] . ' ' . $having['sql'];
        }
        return $this->compileBasicHaving($having);
    }
    protected function compileBasicHaving($having)
    {
        $column = $this->wrap($having['column']);
        $parameter = $this->parameter($having['value']);
        return $having['boolean'] . ' ' . $column . ' ' . $having['operator'] . ' ' . $parameter;
    }
    protected function compileOrders(Builder $query, $orders)
    {
        return 'order by ' . implode(', ', array_map(function ($order) {
            if (isset($order['sql'])) {
                return $order['sql'];
            }
            return $this->wrap($order['column']) . ' ' . $order['direction'];
        }, $orders));
    }
    protected function compileLimit(Builder $query, $limit)
    {
        return 'limit ' . (int) $limit;
    }
    protected function compileOffset(Builder $query, $offset)
    {
        return 'offset ' . (int) $offset;
    }
    protected function compileUnions(Builder $query)
    {
        $sql = '';
        foreach ($query->unions as $union) {
            $sql .= $this->compileUnion($union);
        }
        if (isset($query->unionOrders)) {
            $sql .= ' ' . $this->compileOrders($query, $query->unionOrders);
        }
        if (isset($query->unionLimit)) {
            $sql .= ' ' . $this->compileLimit($query, $query->unionLimit);
        }
        if (isset($query->unionOffset)) {
            $sql .= ' ' . $this->compileOffset($query, $query->unionOffset);
        }
        return ltrim($sql);
    }
    protected function compileUnion(array $union)
    {
        $joiner = $union['all'] ? ' union all ' : ' union ';
        return $joiner . $union['query']->toSql();
    }
    public function compileExists(Builder $query)
    {
        $select = $this->compileSelect($query);
        return "select exists({$select}) as {$this->wrap('exists')}";
    }
    public function compileInsert(Builder $query, array $values)
    {
        $table = $this->wrapTable($query->from);
        if (!is_array(reset($values))) {
            $values = [$values];
        }
        $columns = $this->columnize(array_keys(reset($values)));
        $parameters = [];
        foreach ($values as $record) {
            $parameters[] = '(' . $this->parameterize($record) . ')';
        }
        $parameters = implode(', ', $parameters);
        return "insert into {$table} ({$columns}) values {$parameters}";
    }
    public function compileInsertGetId(Builder $query, $values, $sequence)
    {
        return $this->compileInsert($query, $values);
    }
    public function compileUpdate(Builder $query, $values)
    {
        $table = $this->wrapTable($query->from);
        $columns = [];
        foreach ($values as $key => $value) {
            $columns[] = $this->wrap($key) . ' = ' . $this->parameter($value);
        }
        $columns = implode(', ', $columns);
        if (isset($query->joins)) {
            $joins = ' ' . $this->compileJoins($query, $query->joins);
        } else {
            $joins = '';
        }
        $where = $this->compileWheres($query);
        return trim("update {$table}{$joins} set {$columns} {$where}");
    }
    public function compileDelete(Builder $query)
    {
        $table = $this->wrapTable($query->from);
        $where = is_array($query->wheres) ? $this->compileWheres($query) : '';
        return trim("delete from {$table} " . $where);
    }
    public function compileTruncate(Builder $query)
    {
        return ['truncate ' . $this->wrapTable($query->from) => []];
    }
    protected function compileLock(Builder $query, $value)
    {
        return is_string($value) ? $value : '';
    }
    public function supportsSavepoints()
    {
        return true;
    }
    public function compileSavepoint($name)
    {
        return 'SAVEPOINT ' . $name;
    }
    public function compileSavepointRollBack($name)
    {
        return 'ROLLBACK TO SAVEPOINT ' . $name;
    }
    protected function concatenate($segments)
    {
        return implode(' ', array_filter($segments, function ($value) {
            return (string) $value !== '';
        }));
    }
    protected function removeLeadingBoolean($value)
    {
        return preg_replace('/and |or /i', '', $value, 1);
    }
}
}

namespace Royalcms\Component\NativeSession {
use Royalcms\Component\Session\SessionInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
use Royalcms\Component\Session\StoreInterface;
use Royalcms\Component\Support\Str;
class Store implements SessionInterface, StoreInterface
{
    use CompatibleTrait;
    private $session;
    public function __construct(SessionInterface $session)
    {
        $this->session = $session;
    }
    public function start()
    {
        $this->loadSession();
        if (!$this->has('_token')) {
            $this->regenerateToken();
        }
        return $this->session->start();
    }
    protected function loadSession()
    {
        session_id($this->session->getId());
        if (session_status() !== PHP_SESSION_ACTIVE) {
            session_start();
        }
        $this->mergeNativeSession();
    }
    protected function mergeNativeSession()
    {
        foreach ($_SESSION as $name => $value) {
            $this->session->set($name, $value);
        }
    }
    public function getId()
    {
        return $this->session->getId();
    }
    public function getName()
    {
        return $this->session->getName();
    }
    public function setName($name)
    {
        session_name($name);
        $this->session->setName($name);
    }
    public function invalidate($lifetime = null)
    {
        session_destroy();
        $this->session->invalidate($lifetime);
        $this->regenerate(true);
        return true;
    }
    public function save()
    {
        $this->session->save();
        $mergeData = array_merge($_SESSION, $this->session->all());
        $this->replace($mergeData);
        session_write_close();
    }
    public function set($name, $value)
    {
        array_set($_SESSION, $name, $value);
        $this->session->set($name, $value);
    }
    public function put($key, $value = null)
    {
        if (!is_array($key)) {
            $key = [$key => $value];
        }
        foreach ($key as $arrayKey => $arrayValue) {
            $this->set($arrayKey, $arrayValue);
        }
    }
    public function push($key, $value)
    {
        $array = $this->get($key, []);
        $array[] = $value;
        $this->put($key, $array);
    }
    public function all()
    {
        return $this->session->all();
    }
    public function exists($name)
    {
        return $this->session->has($name);
    }
    public function handlerNeedsRequest()
    {
        return $this->session->handlerNeedsRequest();
    }
    public function setRequestOnHandler(Request $request)
    {
        $this->session->setRequestOnHandler($request);
    }
    public function setId($id)
    {
        session_id($id);
        return $this->session->setId($id);
    }
    public function migrate($destroy = false, $lifetime = null)
    {
        return $this->session->migrate($destroy, $lifetime);
    }
    public function regenerate($destroy = false)
    {
        $this->migrate($destroy);
        session_commit();
        ini_set('session.use_strict_mode', 0);
        session_id($this->session->getId());
        session_start();
        return true;
    }
    public function has($name)
    {
        return $this->session->has($name);
    }
    public function get($name, $default = null)
    {
        $this->mergeNativeSession();
        return $this->session->get($name, $default);
    }
    public function replace(array $attributes)
    {
        $_SESSION = $attributes;
        $this->session->replace($attributes);
    }
    public function remove($name)
    {
        unset($_SESSION[$name]);
        return $this->session->remove($name);
    }
    public function clear()
    {
        $_SESSION = [];
        $this->session->clear();
    }
    public function flush()
    {
        $this->clear();
        session_unset();
        session_destroy();
        session_write_close();
    }
    public function isStarted()
    {
        return $this->session->isStarted();
    }
    public function registerBag(SessionBagInterface $bag)
    {
        $this->session->registerBag($bag);
    }
    public function getBag($name)
    {
        return $this->session->getBag($name);
    }
    public function getMetadataBag()
    {
        return $this->session->getMetadataBag();
    }
    public function getHandler()
    {
        return $this->session->getHandler();
    }
    public function ageFlashData()
    {
        $this->session->forget($this->get('flash.old', []));
        $this->put('flash.old', $this->get('flash.new', []));
        $this->put('flash.new', []);
    }
    public function flash($key, $value)
    {
        $this->put($key, $value);
        $this->push('flash.new', $key);
        $this->removeFromOldFlashData([$key]);
    }
    public function now($key, $value)
    {
        $this->put($key, $value);
        $this->push('flash.old', $key);
    }
    public function flashInput(array $value)
    {
        $this->flash('_old_input', $value);
    }
    public function reflash()
    {
        $this->mergeNewFlashes($this->get('flash.old', []));
        $this->put('flash.old', []);
    }
    public function keep($keys = null)
    {
        $keys = is_array($keys) ? $keys : func_get_args();
        $this->mergeNewFlashes($keys);
        $this->removeFromOldFlashData($keys);
    }
    protected function mergeNewFlashes(array $keys)
    {
        $values = array_unique(array_merge($this->get('flash.new', []), $keys));
        $this->put('flash.new', $values);
    }
    protected function removeFromOldFlashData(array $keys)
    {
        $this->put('flash.old', array_diff($this->get('flash.old', []), $keys));
    }
    public function token()
    {
        return $this->get('_token');
    }
    public function getToken()
    {
        return $this->token();
    }
    public function regenerateToken()
    {
        $this->put('_token', Str::random(40));
    }
    public function setPreviousUrl($url)
    {
        $this->put('_previous.url', $url);
    }
    public function __call($name, $arguments)
    {
        return call_user_func_array([$this->session, $name], $arguments);
    }
}
}

namespace Royalcms\Component\NativeSession {
trait CompatibleTrait
{
    public function session()
    {
        return $this->getHandler();
    }
    public function session_id()
    {
        return $this->getId();
    }
    public function destroy()
    {
        return $this->flush();
    }
    public function delete($name)
    {
        $this->remove($name);
    }
}
}

namespace Royalcms\Component\NativeSession {
class Serialize
{
    public static function unserialize($session_data)
    {
        $method = ini_get("session.serialize_handler");
        switch ($method) {
            case "php":
                return self::unserialize_php($session_data);
                break;
            case "php_binary":
                return self::unserialize_phpbinary($session_data);
                break;
            default:
                throw new \Exception("Unsupported session.serialize_handler: " . $method . ". Supported: php, php_binary");
        }
    }
    private static function unserialize_php($session_data)
    {
        $return_data = array();
        $offset = 0;
        while ($offset < strlen($session_data)) {
            if (!strstr(substr($session_data, $offset), "|")) {
                throw new \Exception("invalid data, remaining: " . substr($session_data, $offset));
            }
            $pos = strpos($session_data, "|", $offset);
            $num = $pos - $offset;
            $varname = substr($session_data, $offset, $num);
            $offset += $num + 1;
            $data = unserialize(substr($session_data, $offset));
            $return_data[$varname] = $data;
            $offset += strlen(serialize($data));
        }
        return $return_data;
    }
    private static function unserialize_phpbinary($session_data)
    {
        $return_data = array();
        $offset = 0;
        while ($offset < strlen($session_data)) {
            $num = ord($session_data[$offset]);
            $offset += 1;
            $varname = substr($session_data, $offset, $num);
            $offset += $num;
            $data = unserialize(substr($session_data, $offset));
            $return_data[$varname] = $data;
            $offset += strlen(serialize($data));
        }
        return $return_data;
    }
}
}

namespace Royalcms\Component\NativeSession {
use Royalcms\Component\Session\SessionManager as RoyalcmsSessionManager;
class SessionManager extends RoyalcmsSessionManager
{
    protected function buildSession($handler)
    {
        $session = parent::buildSession($handler);
        $session_name = \RC_Hook::apply_filters('royalcms_session_name', $this->royalcms['config']['session.name']);
        $session_id = \RC_Hook::apply_filters('royalcms_session_id', null);
        $session->setId($session_id);
        $session->setName($session_name);
        return new Store($session);
    }
}
}

namespace Royalcms\Component\NativeSession {
use Closure;
use SessionHandlerInterface;
use Royalcms\Component\DateTime\Carbon;
use Symfony\Component\HttpFoundation\Request;
use RC_Hook;
use Royalcms\Component\Session\SessionInterface;
class StartSession
{
    protected $manager;
    protected $session;
    public function __construct(SessionManager $manager)
    {
        $this->manager = $manager;
    }
    public function start(Request $request)
    {
        if ($this->sessionConfigured()) {
            $this->session = $session = $this->startSession($request);
            $request->setSession($session);
        }
    }
    public function close()
    {
        if ($this->sessionConfigured()) {
            $this->closeSession($this->session);
        }
    }
    protected function setNativeSessionHandler(SessionHandlerInterface $handler)
    {
        session_set_save_handler($handler, true);
        session_register_shutdown();
    }
    protected function startSession(Request $request)
    {
        with($session = $this->getSession($request))->setRequestOnHandler($request);
        $this->setNativeSessionHandler($session->getHandler());
        $this->addCookie($session);
        $session->start();
        return $session;
    }
    protected function closeSession(SessionInterface $session)
    {
        $session->save();
        $this->collectGarbage($session);
    }
    protected function getUrl(Request $request)
    {
        $url = rtrim(preg_replace('/\\?.*/', '', $request->getUri()), '/');
        return $request->getQueryString() ? $url . '?' . $request->getQueryString() : $url;
    }
    protected function collectGarbage(SessionInterface $session)
    {
        $config = $this->manager->getSessionConfig();
        if ($this->configHitsLottery($config)) {
            $session->getHandler()->gc($this->getLifetimeSeconds());
        }
    }
    protected function configHitsLottery(array $config)
    {
        return mt_rand(1, $config['lottery'][1]) <= $config['lottery'][0];
    }
    protected function addCookie(SessionInterface $session)
    {
        $s = $session;
        if ($this->sessionIsPersistent($c = $this->manager->getSessionConfig())) {
            $secure = array_get($c, 'secure', false);
            $httponly = array_get($c, 'httponly', false);
            session_cache_limiter('nocache');
            session_id($s->getId());
            session_name($s->getName());
            session_set_cookie_params($this->getLifetimeSeconds(), $c['path'], $c['domain'], $secure, $httponly);
        }
    }
    protected function getLifetimeSeconds()
    {
        return array_get($this->manager->getSessionConfig(), 'lifetime') * 60;
    }
    protected function getCookieLifetime()
    {
        $config = $this->manager->getSessionConfig();
        return $config['expire_on_close'] ? 0 : Carbon::now()->addMinutes($config['lifetime']);
    }
    protected function sessionConfigured()
    {
        return !is_null(array_get($this->manager->getSessionConfig(), 'driver'));
    }
    protected function sessionIsPersistent(array $config = null)
    {
        $config = $config ?: $this->manager->getSessionConfig();
        return !in_array($config['driver'], array(null, 'array'));
    }
    public function getSession(Request $request)
    {
        $session = $this->manager->driver();
        if (RC_Hook::has_filter('royalcms_session_id') && RC_Hook::apply_filters('royalcms_session_id', null)) {
            $sessionId = RC_Hook::apply_filters('royalcms_session_id', null);
        } elseif ($request->exists($session->getName())) {
            $sessionId = $request->input($session->getName());
        } elseif ($request->cookies->has($session->getName())) {
            $sessionId = $request->cookies->get($session->getName());
        } else {
            $sessionId = null;
        }
        $session->setId($sessionId);
        return $session;
    }
}
}

namespace Royalcms\Component\NativeSession {
use Royalcms\Component\Support\ServiceProvider;
class NativeSessionServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerSessionManager();
        $this->registerSessionDriver();
        $this->registerStartSession();
    }
    private function registerSessionManager()
    {
        unset($this->royalcms['session']);
        $this->royalcms->bindShared('session', function ($royalcms) {
            return new SessionManager($royalcms);
        });
    }
    private function registerSessionDriver()
    {
        unset($this->royalcms['session.store']);
        $this->royalcms->bindShared('session.store', function ($royalcms) {
            $manager = $royalcms['session'];
            return $manager->driver();
        });
    }
    protected function registerStartSession()
    {
        unset($this->royalcms['session.start']);
        $this->royalcms->bindShared('session.start', function ($royalcms) {
            $manager = $royalcms['session'];
            return new StartSession($manager);
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/native-session');
        return [$dir . "/Store.php", $dir . "/CompatibleTrait.php", $dir . "/Serialize.php", $dir . "/SessionManager.php", $dir . "/StartSession.php", $dir . "/NativeSessionServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Package {
use Royalcms\Component\Support\ServiceProvider;
class PackageServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->bindShared('package', function ($royalcms) {
            return new PackageManager($royalcms);
        });
    }
    public function provides()
    {
        return array('package');
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/package');
        return [$dir . "/PackageServiceProvider.php", $dir . "/PackageManager.php", $dir . "/FileLoader.php", $dir . "/LoaderInterface.php", $dir . "/SystemPackage.php", $dir . "/Package.php", $dir . "/PackageInterface.php", $dir . "/ApplicationPackage.php", $dir . "/Facades/Package.php"];
    }
}
}

namespace Royalcms\Component\Package {
use Closure;
use Royalcms\Component\Support\NamespacedItemResolver;
use Royalcms\Component\Package\FileLoader;
class PackageManager extends NamespacedItemResolver
{
    protected $royalcms;
    public function __construct($royalcms)
    {
        $this->royalcms = $royalcms;
    }
    protected $packages = array();
    public function package($name = null)
    {
        $name = $name ?: $this->getDefaultDriver();
        return $this->packages[$name] = $this->get($name);
    }
    public function parseKey($key)
    {
        $segments = parent::parseKey($key);
        if (is_null($segments[0])) {
            $segments[0] = '*';
        }
        if (isset($segments[2])) {
            unset($segments[2]);
        }
        return $segments;
    }
    protected function get($name)
    {
        list($namespace, $group) = $this->parseKey($name);
        if ($namespace == '*' && $group == 'system') {
            $namespace = 'system';
        } elseif ($namespace == 'app' && $group == 'system') {
            $namespace = 'system';
        }
        return isset($this->packages[$namespace]) ? $this->packages[$namespace] : $this->resolve($namespace, $group);
    }
    protected function resolve($name, $alias)
    {
        if (isset($this->customCreators[$name])) {
            return $this->callCustomCreator($name);
        }
        return $this->{"create" . ucfirst($name) . "Package"}($alias);
    }
    public function createAppPackage($alias)
    {
        $path = '/' . $alias;
        $loader = new FileLoader($this->royalcms['files'], $this->royalcms['path.app'] . $path, $this->royalcms['path.content'] . '/apps' . $path);
        return new ApplicationPackage($loader, $alias);
    }
    public function createPluginPackage($alias)
    {
        return new PluginPackage($alias);
    }
    public function createSystemPackage($alias)
    {
        $loader = new FileLoader($this->royalcms['files'], $this->royalcms['path.system']);
        return new SystemPackage($loader, $alias);
    }
    public function createThemePackage($alias)
    {
        return new ThemePackage($alias);
    }
    protected function callCustomCreator($alias)
    {
    }
    public function getDefaultPackage()
    {
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array(array($this->package(), $method), $parameters);
    }
}
}

namespace Royalcms\Component\Package {
use Royalcms\Component\Filesystem\Filesystem;
class FileLoader implements LoaderInterface
{
    protected $files;
    protected $filePath;
    protected $sitePath;
    protected $defaultPath;
    protected $hints = array();
    public function __construct(Filesystem $files, $sitePath, $defaultPath = null)
    {
        $this->sitePath = $sitePath;
        $this->files = $files;
        if ($sitePath == $defaultPath) {
            $this->defaultPath = null;
        } else {
            $this->defaultPath = $defaultPath;
        }
        if (!$this->existsSite() && $defaultPath) {
            $this->sitePath = $defaultPath;
        }
    }
    public function load($group, $namespace = null)
    {
        if (is_null($namespace) || $namespace == '*') {
            return $this->loadPath($this->sitePath, $group);
        } else {
            return $this->loadNamespaced($group, $namespace);
        }
    }
    protected function loadNamespaced($group, $namespace)
    {
        if (isset($this->hints[$namespace])) {
            return $this->loadPath($this->hints[$namespace], $group);
        }
        return $this;
    }
    protected function loadPath($path, $group)
    {
        $this->filePath = "{$path}/{$group}";
        return $this;
    }
    public function fileContent()
    {
        if ($this->files->exists($this->filePath)) {
            return $this->files->getRequire($this->filePath);
        }
        return false;
    }
    public function addNamespace($namespace, $hint)
    {
        $this->hints[$namespace] = $hint;
    }
    public function loadClass($class)
    {
        $path = "classes/{$class}.class.php";
        return $this->load($path)->fileContent();
    }
    public function loadModel($class)
    {
        $path = "model/{$class}.class.php";
        return $this->load($path)->fileContent();
    }
    public function loadModule($class)
    {
        $path = "modules/{$class}.class.php";
        return $this->load($path)->fileContent();
    }
    public function loadController($class)
    {
        $path = "{$class}.php";
        return $this->load($path)->fileContent();
    }
    public function loadApi($class)
    {
        $path = "apis/{$class}.class.php";
        return $this->load($path)->fileContent();
    }
    public function loadConfig($cfgname)
    {
        $path = "configs/{$cfgname}.php";
        $content = $this->load($path)->fileContent();
        if ($content === false) {
            $path = "configs/{$cfgname}.cfg.php";
            $content = $this->load($path)->fileContent();
        }
        return $content;
    }
    public function loadLanguage($langname)
    {
        $locale = royalcms('config')->get('system.locale');
        $path = "languages/{$locale}/{$langname}.lang.php";
        return $this->load($path)->fileContent();
    }
    public function loadFunction($filename)
    {
        $path = "functions/{$filename}.func.php";
        return $this->load($path)->fileContent();
    }
    public function loadTemplate($templatename)
    {
        $path = "templates/{$templatename}.php";
        return $this->load($path)->fileContent();
    }
    public function loadTemplatePath($templatename)
    {
        $path = "templates/{$templatename}.php";
        return $this->load($path)->filePath();
    }
    public function existsSite()
    {
        if ($this->files->isDirectory($this->sitePath)) {
            return true;
        } else {
            return false;
        }
    }
    public function sitePath()
    {
        return $this->sitePath;
    }
    public function filePath()
    {
        return $this->filePath;
    }
}
}

namespace Royalcms\Component\Package {
interface LoaderInterface
{
    public function load($group, $namespace = null);
    public function addNamespace($namespace, $hint);
}
}

namespace Royalcms\Component\Package {
class SystemPackage extends Package implements PackageInterface
{
    public function __construct(LoaderInterface $loader, $alias)
    {
        parent::__construct($loader);
        $this->alias = $alias;
    }
    public function loadController($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($classname . $initialize);
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadController($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadModel($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($classname . $initialize);
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadModel($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadModule($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($classname . $initialize);
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadModule($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadClass($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($classname . $initialize);
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadClass($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadApi($apiname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $apiname);
        $apikey = basename($classname);
        $new_classname = 'system_' . $apikey . '_api';
        $classname = str_replace($apikey, $new_classname, $classname);
        $key = md5($classname . $initialize);
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadApi($classname)) {
            if ($initialize) {
                $classes[$key] = new $new_classname();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadConfig($cfgname)
    {
        static $configs = array();
        $cfgname = str_replace(".", DIRECTORY_SEPARATOR, $cfgname);
        $key = md5($cfgname);
        if (isset($configs[$key])) {
            return $configs[$key];
        }
        $configs[$key] = $this->loader->loadConfig($cfgname);
        return $configs[$key];
    }
    public function loadLanguage($langname)
    {
        static $languages = array();
        $langname = str_replace(".", DIRECTORY_SEPARATOR, $langname);
        $key = md5($langname);
        if (isset($languages[$key])) {
            return $languages[$key];
        }
        $languages[$key] = $this->loader->loadLanguage($langname);
        return $languages[$key];
    }
    public function loadFunction($filename)
    {
        static $files = array();
        $filename = str_replace(".", DIRECTORY_SEPARATOR, $filename);
        $key = md5($filename);
        if (isset($files[$key])) {
            return $files[$key];
        }
        $files[$key] = $this->loader->loadFunction($filename);
        return $files[$key];
    }
    public function loadTemplate($templatename, $returnPath = false)
    {
        static $templates = array();
        $key = md5($templatename);
        if (isset($templates[$key])) {
            return $templates[$key];
        }
        $templates[$key] = $this->loader->loadTemplate($templatename);
        if ($returnPath) {
            return $this->loader->filePath();
        } else {
            return $templates[$key];
        }
    }
}
}

namespace Royalcms\Component\Package {
class Package
{
    protected $loader;
    protected $packageId;
    protected $packageName;
    protected $directory;
    protected $alias;
    public function __construct(LoaderInterface $loader)
    {
        $this->loader = $loader;
    }
    public function getPackageId()
    {
        return $this->packageId;
    }
    public function getPackageName()
    {
        return $this->packageName;
    }
    public function getDirectory()
    {
        return $this->directory;
    }
    public function getAlias()
    {
        return $this->alias;
    }
}
}

namespace Royalcms\Component\Package {
interface PackageInterface
{
    public function loadClass($classname, $initialize = true);
    public function loadController($classname, $initialize = true);
    public function loadModel($classname, $initialize = true);
    public function loadModule($classname, $initialize = true);
    public function loadApi($apiname, $initialize = true);
    public function loadConfig($cfgname);
    public function loadLanguage($langname);
    public function loadFunction($filename);
    public function loadTemplate($templatename, $returnPath = false);
}
}

namespace Royalcms\Component\Package {
class ApplicationPackage extends Package implements PackageInterface
{
    public function __construct(LoaderInterface $loader, $alias)
    {
        parent::__construct($loader);
        $this->alias = $alias;
    }
    public function loadController($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($this->alias . $classname . ($initialize ? 'true' : 'false'));
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadController($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadModel($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($this->alias . $classname . ($initialize ? 'true' : 'false'));
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadModel($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadModule($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($this->alias . $classname . ($initialize ? 'true' : 'false'));
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadModule($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadClass($classname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $classname);
        $class = basename($classname);
        $key = md5($this->alias . $classname . ($initialize ? 'true' : 'false'));
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadClass($classname)) {
            if ($initialize) {
                $classes[$key] = new $class();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadApi($apiname, $initialize = true)
    {
        static $classes = array();
        $classname = str_replace(".", DIRECTORY_SEPARATOR, $apiname);
        $apikey = basename($classname);
        $new_classname = $this->alias . '_' . $apikey . '_api';
        $classname = str_replace($apikey, $new_classname, $classname);
        $key = md5($this->alias . $classname . ($initialize ? 'true' : 'false'));
        if (isset($classes[$key])) {
            return $classes[$key];
        }
        if ($this->loader->loadApi($classname)) {
            if ($initialize) {
                $classes[$key] = new $new_classname();
            } else {
                $classes[$key] = true;
            }
            return $classes[$key];
        } else {
            return false;
        }
    }
    public function loadConfig($cfgname)
    {
        static $configs = array();
        $cfgname = str_replace(".", DIRECTORY_SEPARATOR, $cfgname);
        $key = md5($this->alias . $cfgname);
        if (isset($configs[$key])) {
            return $configs[$key];
        }
        $configs[$key] = $this->loader->loadConfig($cfgname);
        return $configs[$key];
    }
    public function loadLanguage($langname)
    {
        static $languages = array();
        $langname = str_replace(".", DIRECTORY_SEPARATOR, $langname);
        $key = md5($this->alias . $langname);
        if (isset($languages[$key])) {
            return $languages[$key];
        }
        $languages[$key] = $this->loader->loadLanguage($langname);
        return $languages[$key];
    }
    public function loadFunction($filename)
    {
        static $files = array();
        $filename = str_replace(".", DIRECTORY_SEPARATOR, $filename);
        $key = md5($this->alias . $filename);
        if (isset($files[$key])) {
            return $files[$key];
        }
        $files[$key] = $this->loader->loadFunction($filename);
        return $files[$key];
    }
    public function loadTemplate($templatename, $returnPath = false)
    {
        if ($returnPath) {
            return $this->loader->loadTemplatePath($templatename);
        } else {
            static $templates = array();
            $key = md5($this->alias . $templatename);
            if (isset($templates[$key])) {
                return $templates[$key];
            }
            $templates[$key] = $this->loader->loadTemplate($templatename);
            return $templates[$key];
        }
    }
}
}

namespace Royalcms\Component\Package\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Package extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'package';
    }
}
}

namespace Predis\Command {
interface CommandInterface
{
    public function getId();
    public function setSlot($slot);
    public function getSlot();
    public function setArguments(array $arguments);
    public function setRawArguments(array $arguments);
    public function getArguments();
    public function getArgument($index);
    public function parseResponse($data);
}
}

namespace Predis\Command {
abstract class Command implements CommandInterface
{
    private $slot;
    private $arguments = array();
    protected function filterArguments(array $arguments)
    {
        return $arguments;
    }
    public function setArguments(array $arguments)
    {
        $this->arguments = $this->filterArguments($arguments);
        unset($this->slot);
    }
    public function setRawArguments(array $arguments)
    {
        $this->arguments = $arguments;
        unset($this->slot);
    }
    public function getArguments()
    {
        return $this->arguments;
    }
    public function getArgument($index)
    {
        if (isset($this->arguments[$index])) {
            return $this->arguments[$index];
        }
    }
    public function setSlot($slot)
    {
        $this->slot = $slot;
    }
    public function getSlot()
    {
        if (isset($this->slot)) {
            return $this->slot;
        }
    }
    public function parseResponse($data)
    {
        return $data;
    }
    public static function normalizeArguments(array $arguments)
    {
        if (count($arguments) === 1 && is_array($arguments[0])) {
            return $arguments[0];
        }
        return $arguments;
    }
    public static function normalizeVariadic(array $arguments)
    {
        if (count($arguments) === 2 && is_array($arguments[1])) {
            return array_merge(array($arguments[0]), $arguments[1]);
        }
        return $arguments;
    }
}
}

namespace Predis\Command {
class StringGet extends Command
{
    public function getId()
    {
        return 'GET';
    }
}
}

namespace Predis\Command {
class RawCommand implements CommandInterface
{
    private $slot;
    private $commandID;
    private $arguments;
    public function __construct(array $arguments)
    {
        if (!$arguments) {
            throw new \InvalidArgumentException('The arguments array must contain at least the command ID.');
        }
        $this->commandID = strtoupper(array_shift($arguments));
        $this->arguments = $arguments;
    }
    public static function create($commandID)
    {
        $arguments = func_get_args();
        $command = new self($arguments);
        return $command;
    }
    public function getId()
    {
        return $this->commandID;
    }
    public function setArguments(array $arguments)
    {
        $this->arguments = $arguments;
        unset($this->slot);
    }
    public function setRawArguments(array $arguments)
    {
        $this->setArguments($arguments);
    }
    public function getArguments()
    {
        return $this->arguments;
    }
    public function getArgument($index)
    {
        if (isset($this->arguments[$index])) {
            return $this->arguments[$index];
        }
    }
    public function setSlot($slot)
    {
        $this->slot = $slot;
    }
    public function getSlot()
    {
        if (isset($this->slot)) {
            return $this->slot;
        }
    }
    public function parseResponse($data)
    {
        return $data;
    }
}
}

namespace Predis\Configuration {
use Predis\Profile\Factory;
use Predis\Profile\ProfileInterface;
use Predis\Profile\RedisProfile;
class ProfileOption implements OptionInterface
{
    protected function setProcessors(OptionsInterface $options, ProfileInterface $profile)
    {
        if (isset($options->prefix) && $profile instanceof RedisProfile) {
            $profile->setProcessor($options->__get('prefix'));
        }
    }
    public function filter(OptionsInterface $options, $value)
    {
        if (is_string($value)) {
            $value = Factory::get($value);
            $this->setProcessors($options, $value);
        } elseif (!$value instanceof ProfileInterface) {
            throw new \InvalidArgumentException('Invalid value for the profile option.');
        }
        return $value;
    }
    public function getDefault(OptionsInterface $options)
    {
        $profile = Factory::getDefault();
        $this->setProcessors($options, $profile);
        return $profile;
    }
}
}

namespace Predis\Response {
class Status implements ResponseInterface
{
    private static $OK;
    private static $QUEUED;
    private $payload;
    public function __construct($payload)
    {
        $this->payload = $payload;
    }
    public function __toString()
    {
        return $this->payload;
    }
    public function getPayload()
    {
        return $this->payload;
    }
    public static function get($payload)
    {
        switch ($payload) {
            case 'OK':
            case 'QUEUED':
                if (isset(self::${$payload})) {
                    return self::${$payload};
                }
                return self::${$payload} = new self($payload);
            default:
                return new self($payload);
        }
    }
}
}

namespace Predis\Profile {
use Predis\Command\CommandInterface;
interface ProfileInterface
{
    public function getVersion();
    public function supportsCommand($commandID);
    public function supportsCommands(array $commandIDs);
    public function createCommand($commandID, array $arguments = array());
}
}

namespace Predis\Profile {
use Predis\ClientException;
use Predis\Command\Processor\ProcessorInterface;
abstract class RedisProfile implements ProfileInterface
{
    private $commands;
    private $processor;
    public function __construct()
    {
        $this->commands = $this->getSupportedCommands();
    }
    protected abstract function getSupportedCommands();
    public function supportsCommand($commandID)
    {
        return isset($this->commands[strtoupper($commandID)]);
    }
    public function supportsCommands(array $commandIDs)
    {
        foreach ($commandIDs as $commandID) {
            if (!$this->supportsCommand($commandID)) {
                return false;
            }
        }
        return true;
    }
    public function getCommandClass($commandID)
    {
        if (isset($this->commands[$commandID = strtoupper($commandID)])) {
            return $this->commands[$commandID];
        }
    }
    public function createCommand($commandID, array $arguments = array())
    {
        $commandID = strtoupper($commandID);
        if (!isset($this->commands[$commandID])) {
            throw new ClientException("Command '{$commandID}' is not a registered Redis command.");
        }
        $commandClass = $this->commands[$commandID];
        $command = new $commandClass();
        $command->setArguments($arguments);
        if (isset($this->processor)) {
            $this->processor->process($command);
        }
        return $command;
    }
    public function defineCommand($commandID, $class)
    {
        $reflection = new \ReflectionClass($class);
        if (!$reflection->isSubclassOf('Predis\\Command\\CommandInterface')) {
            throw new \InvalidArgumentException("The class '{$class}' is not a valid command class.");
        }
        $this->commands[strtoupper($commandID)] = $class;
    }
    public function setProcessor(ProcessorInterface $processor = null)
    {
        $this->processor = $processor;
    }
    public function getProcessor()
    {
        return $this->processor;
    }
    public function __toString()
    {
        return $this->getVersion();
    }
}
}

namespace Predis\Profile {
class RedisVersion300 extends RedisProfile
{
    public function getVersion()
    {
        return '3.0';
    }
    public function getSupportedCommands()
    {
        return array('EXISTS' => 'Predis\\Command\\KeyExists', 'DEL' => 'Predis\\Command\\KeyDelete', 'TYPE' => 'Predis\\Command\\KeyType', 'KEYS' => 'Predis\\Command\\KeyKeys', 'RANDOMKEY' => 'Predis\\Command\\KeyRandom', 'RENAME' => 'Predis\\Command\\KeyRename', 'RENAMENX' => 'Predis\\Command\\KeyRenamePreserve', 'EXPIRE' => 'Predis\\Command\\KeyExpire', 'EXPIREAT' => 'Predis\\Command\\KeyExpireAt', 'TTL' => 'Predis\\Command\\KeyTimeToLive', 'MOVE' => 'Predis\\Command\\KeyMove', 'SORT' => 'Predis\\Command\\KeySort', 'DUMP' => 'Predis\\Command\\KeyDump', 'RESTORE' => 'Predis\\Command\\KeyRestore', 'SET' => 'Predis\\Command\\StringSet', 'SETNX' => 'Predis\\Command\\StringSetPreserve', 'MSET' => 'Predis\\Command\\StringSetMultiple', 'MSETNX' => 'Predis\\Command\\StringSetMultiplePreserve', 'GET' => 'Predis\\Command\\StringGet', 'MGET' => 'Predis\\Command\\StringGetMultiple', 'GETSET' => 'Predis\\Command\\StringGetSet', 'INCR' => 'Predis\\Command\\StringIncrement', 'INCRBY' => 'Predis\\Command\\StringIncrementBy', 'DECR' => 'Predis\\Command\\StringDecrement', 'DECRBY' => 'Predis\\Command\\StringDecrementBy', 'RPUSH' => 'Predis\\Command\\ListPushTail', 'LPUSH' => 'Predis\\Command\\ListPushHead', 'LLEN' => 'Predis\\Command\\ListLength', 'LRANGE' => 'Predis\\Command\\ListRange', 'LTRIM' => 'Predis\\Command\\ListTrim', 'LINDEX' => 'Predis\\Command\\ListIndex', 'LSET' => 'Predis\\Command\\ListSet', 'LREM' => 'Predis\\Command\\ListRemove', 'LPOP' => 'Predis\\Command\\ListPopFirst', 'RPOP' => 'Predis\\Command\\ListPopLast', 'RPOPLPUSH' => 'Predis\\Command\\ListPopLastPushHead', 'SADD' => 'Predis\\Command\\SetAdd', 'SREM' => 'Predis\\Command\\SetRemove', 'SPOP' => 'Predis\\Command\\SetPop', 'SMOVE' => 'Predis\\Command\\SetMove', 'SCARD' => 'Predis\\Command\\SetCardinality', 'SISMEMBER' => 'Predis\\Command\\SetIsMember', 'SINTER' => 'Predis\\Command\\SetIntersection', 'SINTERSTORE' => 'Predis\\Command\\SetIntersectionStore', 'SUNION' => 'Predis\\Command\\SetUnion', 'SUNIONSTORE' => 'Predis\\Command\\SetUnionStore', 'SDIFF' => 'Predis\\Command\\SetDifference', 'SDIFFSTORE' => 'Predis\\Command\\SetDifferenceStore', 'SMEMBERS' => 'Predis\\Command\\SetMembers', 'SRANDMEMBER' => 'Predis\\Command\\SetRandomMember', 'ZADD' => 'Predis\\Command\\ZSetAdd', 'ZINCRBY' => 'Predis\\Command\\ZSetIncrementBy', 'ZREM' => 'Predis\\Command\\ZSetRemove', 'ZRANGE' => 'Predis\\Command\\ZSetRange', 'ZREVRANGE' => 'Predis\\Command\\ZSetReverseRange', 'ZRANGEBYSCORE' => 'Predis\\Command\\ZSetRangeByScore', 'ZCARD' => 'Predis\\Command\\ZSetCardinality', 'ZSCORE' => 'Predis\\Command\\ZSetScore', 'ZREMRANGEBYSCORE' => 'Predis\\Command\\ZSetRemoveRangeByScore', 'PING' => 'Predis\\Command\\ConnectionPing', 'AUTH' => 'Predis\\Command\\ConnectionAuth', 'SELECT' => 'Predis\\Command\\ConnectionSelect', 'ECHO' => 'Predis\\Command\\ConnectionEcho', 'QUIT' => 'Predis\\Command\\ConnectionQuit', 'INFO' => 'Predis\\Command\\ServerInfoV26x', 'SLAVEOF' => 'Predis\\Command\\ServerSlaveOf', 'MONITOR' => 'Predis\\Command\\ServerMonitor', 'DBSIZE' => 'Predis\\Command\\ServerDatabaseSize', 'FLUSHDB' => 'Predis\\Command\\ServerFlushDatabase', 'FLUSHALL' => 'Predis\\Command\\ServerFlushAll', 'SAVE' => 'Predis\\Command\\ServerSave', 'BGSAVE' => 'Predis\\Command\\ServerBackgroundSave', 'LASTSAVE' => 'Predis\\Command\\ServerLastSave', 'SHUTDOWN' => 'Predis\\Command\\ServerShutdown', 'BGREWRITEAOF' => 'Predis\\Command\\ServerBackgroundRewriteAOF', 'SETEX' => 'Predis\\Command\\StringSetExpire', 'APPEND' => 'Predis\\Command\\StringAppend', 'SUBSTR' => 'Predis\\Command\\StringSubstr', 'BLPOP' => 'Predis\\Command\\ListPopFirstBlocking', 'BRPOP' => 'Predis\\Command\\ListPopLastBlocking', 'ZUNIONSTORE' => 'Predis\\Command\\ZSetUnionStore', 'ZINTERSTORE' => 'Predis\\Command\\ZSetIntersectionStore', 'ZCOUNT' => 'Predis\\Command\\ZSetCount', 'ZRANK' => 'Predis\\Command\\ZSetRank', 'ZREVRANK' => 'Predis\\Command\\ZSetReverseRank', 'ZREMRANGEBYRANK' => 'Predis\\Command\\ZSetRemoveRangeByRank', 'HSET' => 'Predis\\Command\\HashSet', 'HSETNX' => 'Predis\\Command\\HashSetPreserve', 'HMSET' => 'Predis\\Command\\HashSetMultiple', 'HINCRBY' => 'Predis\\Command\\HashIncrementBy', 'HGET' => 'Predis\\Command\\HashGet', 'HMGET' => 'Predis\\Command\\HashGetMultiple', 'HDEL' => 'Predis\\Command\\HashDelete', 'HEXISTS' => 'Predis\\Command\\HashExists', 'HLEN' => 'Predis\\Command\\HashLength', 'HKEYS' => 'Predis\\Command\\HashKeys', 'HVALS' => 'Predis\\Command\\HashValues', 'HGETALL' => 'Predis\\Command\\HashGetAll', 'MULTI' => 'Predis\\Command\\TransactionMulti', 'EXEC' => 'Predis\\Command\\TransactionExec', 'DISCARD' => 'Predis\\Command\\TransactionDiscard', 'SUBSCRIBE' => 'Predis\\Command\\PubSubSubscribe', 'UNSUBSCRIBE' => 'Predis\\Command\\PubSubUnsubscribe', 'PSUBSCRIBE' => 'Predis\\Command\\PubSubSubscribeByPattern', 'PUNSUBSCRIBE' => 'Predis\\Command\\PubSubUnsubscribeByPattern', 'PUBLISH' => 'Predis\\Command\\PubSubPublish', 'CONFIG' => 'Predis\\Command\\ServerConfig', 'PERSIST' => 'Predis\\Command\\KeyPersist', 'STRLEN' => 'Predis\\Command\\StringStrlen', 'SETRANGE' => 'Predis\\Command\\StringSetRange', 'GETRANGE' => 'Predis\\Command\\StringGetRange', 'SETBIT' => 'Predis\\Command\\StringSetBit', 'GETBIT' => 'Predis\\Command\\StringGetBit', 'RPUSHX' => 'Predis\\Command\\ListPushTailX', 'LPUSHX' => 'Predis\\Command\\ListPushHeadX', 'LINSERT' => 'Predis\\Command\\ListInsert', 'BRPOPLPUSH' => 'Predis\\Command\\ListPopLastPushHeadBlocking', 'ZREVRANGEBYSCORE' => 'Predis\\Command\\ZSetReverseRangeByScore', 'WATCH' => 'Predis\\Command\\TransactionWatch', 'UNWATCH' => 'Predis\\Command\\TransactionUnwatch', 'OBJECT' => 'Predis\\Command\\ServerObject', 'SLOWLOG' => 'Predis\\Command\\ServerSlowlog', 'CLIENT' => 'Predis\\Command\\ServerClient', 'PTTL' => 'Predis\\Command\\KeyPreciseTimeToLive', 'PEXPIRE' => 'Predis\\Command\\KeyPreciseExpire', 'PEXPIREAT' => 'Predis\\Command\\KeyPreciseExpireAt', 'MIGRATE' => 'Predis\\Command\\KeyMigrate', 'PSETEX' => 'Predis\\Command\\StringPreciseSetExpire', 'INCRBYFLOAT' => 'Predis\\Command\\StringIncrementByFloat', 'BITOP' => 'Predis\\Command\\StringBitOp', 'BITCOUNT' => 'Predis\\Command\\StringBitCount', 'HINCRBYFLOAT' => 'Predis\\Command\\HashIncrementByFloat', 'EVAL' => 'Predis\\Command\\ServerEval', 'EVALSHA' => 'Predis\\Command\\ServerEvalSHA', 'SCRIPT' => 'Predis\\Command\\ServerScript', 'TIME' => 'Predis\\Command\\ServerTime', 'SENTINEL' => 'Predis\\Command\\ServerSentinel', 'SCAN' => 'Predis\\Command\\KeyScan', 'BITPOS' => 'Predis\\Command\\StringBitPos', 'SSCAN' => 'Predis\\Command\\SetScan', 'ZSCAN' => 'Predis\\Command\\ZSetScan', 'ZLEXCOUNT' => 'Predis\\Command\\ZSetLexCount', 'ZRANGEBYLEX' => 'Predis\\Command\\ZSetRangeByLex', 'ZREMRANGEBYLEX' => 'Predis\\Command\\ZSetRemoveRangeByLex', 'ZREVRANGEBYLEX' => 'Predis\\Command\\ZSetReverseRangeByLex', 'HSCAN' => 'Predis\\Command\\HashScan', 'PUBSUB' => 'Predis\\Command\\PubSubPubsub', 'PFADD' => 'Predis\\Command\\HyperLogLogAdd', 'PFCOUNT' => 'Predis\\Command\\HyperLogLogCount', 'PFMERGE' => 'Predis\\Command\\HyperLogLogMerge', 'COMMAND' => 'Predis\\Command\\ServerCommand');
    }
}
}

namespace Predis\Profile {
use Predis\ClientException;
final class Factory
{
    private static $profiles = array('2.0' => 'Predis\\Profile\\RedisVersion200', '2.2' => 'Predis\\Profile\\RedisVersion220', '2.4' => 'Predis\\Profile\\RedisVersion240', '2.6' => 'Predis\\Profile\\RedisVersion260', '2.8' => 'Predis\\Profile\\RedisVersion280', '3.0' => 'Predis\\Profile\\RedisVersion300', '3.2' => 'Predis\\Profile\\RedisVersion320', 'dev' => 'Predis\\Profile\\RedisUnstable', 'default' => 'Predis\\Profile\\RedisVersion300');
    private function __construct()
    {
    }
    public static function getDefault()
    {
        return self::get('default');
    }
    public static function getDevelopment()
    {
        return self::get('dev');
    }
    public static function define($alias, $class)
    {
        $reflection = new \ReflectionClass($class);
        if (!$reflection->isSubclassOf('Predis\\Profile\\ProfileInterface')) {
            throw new \InvalidArgumentException("The class '{$class}' is not a valid profile class.");
        }
        self::$profiles[$alias] = $class;
    }
    public static function get($version)
    {
        if (!isset(self::$profiles[$version])) {
            throw new ClientException("Unknown server profile: '{$version}'.");
        }
        $profile = self::$profiles[$version];
        return new $profile();
    }
}
}

namespace Predis\Connection {
interface FactoryInterface
{
    public function define($scheme, $initializer);
    public function undefine($scheme);
    public function create($parameters);
    public function aggregate(AggregateConnectionInterface $aggregate, array $parameters);
}
}

namespace Predis\Connection {
use Predis\Command\RawCommand;
class Factory implements FactoryInterface
{
    protected $schemes = array('tcp' => 'Predis\\Connection\\StreamConnection', 'unix' => 'Predis\\Connection\\StreamConnection', 'redis' => 'Predis\\Connection\\StreamConnection', 'http' => 'Predis\\Connection\\WebdisConnection');
    protected function checkInitializer($initializer)
    {
        if (is_callable($initializer)) {
            return $initializer;
        }
        $class = new \ReflectionClass($initializer);
        if (!$class->isSubclassOf('Predis\\Connection\\NodeConnectionInterface')) {
            throw new \InvalidArgumentException('A connection initializer must be a valid connection class or a callable object.');
        }
        return $initializer;
    }
    public function define($scheme, $initializer)
    {
        $this->schemes[$scheme] = $this->checkInitializer($initializer);
    }
    public function undefine($scheme)
    {
        unset($this->schemes[$scheme]);
    }
    public function create($parameters)
    {
        if (!$parameters instanceof ParametersInterface) {
            $parameters = $this->createParameters($parameters);
        }
        $scheme = $parameters->scheme;
        if (!isset($this->schemes[$scheme])) {
            throw new \InvalidArgumentException("Unknown connection scheme: '{$scheme}'.");
        }
        $initializer = $this->schemes[$scheme];
        if (is_callable($initializer)) {
            $connection = call_user_func($initializer, $parameters, $this);
        } else {
            $connection = new $initializer($parameters);
            $this->prepareConnection($connection);
        }
        if (!$connection instanceof NodeConnectionInterface) {
            throw new \UnexpectedValueException('Objects returned by connection initializers must implement ' . "'Predis\\Connection\\NodeConnectionInterface'.");
        }
        return $connection;
    }
    public function aggregate(AggregateConnectionInterface $connection, array $parameters)
    {
        foreach ($parameters as $node) {
            $connection->add($node instanceof NodeConnectionInterface ? $node : $this->create($node));
        }
    }
    protected function createParameters($parameters)
    {
        return Parameters::create($parameters);
    }
    protected function prepareConnection(NodeConnectionInterface $connection)
    {
        $parameters = $connection->getParameters();
        if (isset($parameters->password)) {
            $connection->addConnectCommand(new RawCommand(array('AUTH', $parameters->password)));
        }
        if (isset($parameters->database)) {
            $connection->addConnectCommand(new RawCommand(array('SELECT', $parameters->database)));
        }
    }
}
}

namespace Predis\Connection {
interface ParametersInterface
{
    public function __isset($parameter);
    public function __get($parameter);
    public function toArray();
}
}

namespace Predis\Connection {
use Predis\Command\CommandInterface;
interface NodeConnectionInterface extends ConnectionInterface
{
    public function __toString();
    public function getResource();
    public function getParameters();
    public function addConnectCommand(CommandInterface $command);
    public function read();
}
}

namespace Predis\Connection {
use Predis\Command\CommandInterface;
interface ConnectionInterface
{
    public function connect();
    public function disconnect();
    public function isConnected();
    public function writeRequest(CommandInterface $command);
    public function readResponse(CommandInterface $command);
    public function executeCommand(CommandInterface $command);
}
}

namespace Predis\Connection {
use Predis\Command\CommandInterface;
use Predis\CommunicationException;
use Predis\Protocol\ProtocolException;
abstract class AbstractConnection implements NodeConnectionInterface
{
    private $resource;
    private $cachedId;
    protected $parameters;
    protected $initCommands = array();
    public function __construct(ParametersInterface $parameters)
    {
        $this->parameters = $this->assertParameters($parameters);
    }
    public function __destruct()
    {
        $this->disconnect();
    }
    protected function assertParameters(ParametersInterface $parameters)
    {
        switch ($parameters->scheme) {
            case 'tcp':
            case 'redis':
            case 'unix':
                break;
            default:
                throw new \InvalidArgumentException("Invalid scheme: '{$parameters->scheme}'.");
        }
        return $parameters;
    }
    protected abstract function createResource();
    public function isConnected()
    {
        return isset($this->resource);
    }
    public function connect()
    {
        if (!$this->isConnected()) {
            $this->resource = $this->createResource();
            return true;
        }
        return false;
    }
    public function disconnect()
    {
        unset($this->resource);
    }
    public function addConnectCommand(CommandInterface $command)
    {
        $this->initCommands[] = $command;
    }
    public function executeCommand(CommandInterface $command)
    {
        $this->writeRequest($command);
        return $this->readResponse($command);
    }
    public function readResponse(CommandInterface $command)
    {
        return $this->read();
    }
    private function createExceptionMessage($message)
    {
        $parameters = $this->parameters;
        if ($parameters->scheme === 'unix') {
            return "{$message} [{$parameters->scheme}:{$parameters->path}]";
        }
        if (filter_var($parameters->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            return "{$message} [{$parameters->scheme}://[{$parameters->host}]:{$parameters->port}]";
        }
        return "{$message} [{$parameters->scheme}://{$parameters->host}:{$parameters->port}]";
    }
    protected function onConnectionError($message, $code = null)
    {
        CommunicationException::handle(new ConnectionException($this, static::createExceptionMessage($message), $code));
    }
    protected function onProtocolError($message)
    {
        CommunicationException::handle(new ProtocolException($this, static::createExceptionMessage($message)));
    }
    public function getResource()
    {
        if (isset($this->resource)) {
            return $this->resource;
        }
        $this->connect();
        return $this->resource;
    }
    public function getParameters()
    {
        return $this->parameters;
    }
    protected function getIdentifier()
    {
        if ($this->parameters->scheme === 'unix') {
            return $this->parameters->path;
        }
        return "{$this->parameters->host}:{$this->parameters->port}";
    }
    public function __toString()
    {
        if (!isset($this->cachedId)) {
            $this->cachedId = $this->getIdentifier();
        }
        return $this->cachedId;
    }
    public function __sleep()
    {
        return array('parameters', 'initCommands');
    }
}
}

namespace Predis\Connection {
class Parameters implements ParametersInterface
{
    private $parameters;
    private static $defaults = array('scheme' => 'tcp', 'host' => '127.0.0.1', 'port' => 6379, 'timeout' => 5.0);
    public function __construct(array $parameters = array())
    {
        $this->parameters = $this->filter($parameters) + $this->getDefaults();
    }
    protected function getDefaults()
    {
        return self::$defaults;
    }
    public static function create($parameters)
    {
        if (is_string($parameters)) {
            $parameters = static::parse($parameters);
        }
        return new static($parameters ?: array());
    }
    public static function parse($uri)
    {
        if (stripos($uri, 'unix') === 0) {
            $uri = str_ireplace('unix:///', 'unix://localhost/', $uri);
        }
        if (!($parsed = parse_url($uri))) {
            throw new \InvalidArgumentException("Invalid parameters URI: {$uri}");
        }
        if (isset($parsed['host']) && false !== strpos($parsed['host'], '[') && false !== strpos($parsed['host'], ']')) {
            $parsed['host'] = substr($parsed['host'], 1, -1);
        }
        if (isset($parsed['query'])) {
            parse_str($parsed['query'], $queryarray);
            unset($parsed['query']);
            $parsed = array_merge($parsed, $queryarray);
        }
        if (stripos($uri, 'redis') === 0) {
            if (isset($parsed['pass'])) {
                $parsed['password'] = $parsed['pass'];
                unset($parsed['pass']);
            }
            if (isset($parsed['path']) && preg_match('/^\\/(\\d+)(\\/.*)?/', $parsed['path'], $path)) {
                $parsed['database'] = $path[1];
                if (isset($path[2])) {
                    $parsed['path'] = $path[2];
                } else {
                    unset($parsed['path']);
                }
            }
        }
        return $parsed;
    }
    protected function filter(array $parameters)
    {
        return $parameters ?: array();
    }
    public function __get($parameter)
    {
        if (isset($this->parameters[$parameter])) {
            return $this->parameters[$parameter];
        }
    }
    public function __isset($parameter)
    {
        return isset($this->parameters[$parameter]);
    }
    public function toArray()
    {
        return $this->parameters;
    }
    public function __sleep()
    {
        return array('parameters');
    }
}
}

namespace Predis\Connection {
use Predis\Command\CommandInterface;
use Predis\Response\Error as ErrorResponse;
use Predis\Response\Status as StatusResponse;
class StreamConnection extends AbstractConnection
{
    public function __destruct()
    {
        if (isset($this->parameters->persistent) && $this->parameters->persistent) {
            return;
        }
        $this->disconnect();
    }
    protected function createResource()
    {
        switch ($this->parameters->scheme) {
            case 'tcp':
            case 'redis':
                return $this->tcpStreamInitializer($this->parameters);
            case 'unix':
                return $this->unixStreamInitializer($this->parameters);
            default:
                throw new \InvalidArgumentException("Invalid scheme: '{$this->parameters->scheme}'.");
        }
    }
    protected function tcpStreamInitializer(ParametersInterface $parameters)
    {
        if (!filter_var($parameters->host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6)) {
            $uri = "tcp://{$parameters->host}:{$parameters->port}";
        } else {
            $uri = "tcp://[{$parameters->host}]:{$parameters->port}";
        }
        $flags = STREAM_CLIENT_CONNECT;
        if (isset($parameters->async_connect) && (bool) $parameters->async_connect) {
            $flags |= STREAM_CLIENT_ASYNC_CONNECT;
        }
        if (isset($parameters->persistent) && (bool) $parameters->persistent) {
            $flags |= STREAM_CLIENT_PERSISTENT;
            $uri .= strpos($path = $parameters->path, '/') === 0 ? $path : "/{$path}";
        }
        $resource = @stream_socket_client($uri, $errno, $errstr, (double) $parameters->timeout, $flags);
        if (!$resource) {
            $this->onConnectionError(trim($errstr), $errno);
        }
        if (isset($parameters->read_write_timeout)) {
            $rwtimeout = (double) $parameters->read_write_timeout;
            $rwtimeout = $rwtimeout > 0 ? $rwtimeout : -1;
            $timeoutSeconds = floor($rwtimeout);
            $timeoutUSeconds = ($rwtimeout - $timeoutSeconds) * 1000000;
            stream_set_timeout($resource, $timeoutSeconds, $timeoutUSeconds);
        }
        if (isset($parameters->tcp_nodelay) && function_exists('socket_import_stream')) {
            $socket = socket_import_stream($resource);
            socket_set_option($socket, SOL_TCP, TCP_NODELAY, (int) $parameters->tcp_nodelay);
        }
        return $resource;
    }
    protected function unixStreamInitializer(ParametersInterface $parameters)
    {
        if (!isset($parameters->path)) {
            throw new \InvalidArgumentException('Missing UNIX domain socket path.');
        }
        $uri = "unix://{$parameters->path}";
        $flags = STREAM_CLIENT_CONNECT;
        if ((bool) $parameters->persistent) {
            $flags |= STREAM_CLIENT_PERSISTENT;
        }
        $resource = @stream_socket_client($uri, $errno, $errstr, (double) $parameters->timeout, $flags);
        if (!$resource) {
            $this->onConnectionError(trim($errstr), $errno);
        }
        if (isset($parameters->read_write_timeout)) {
            $rwtimeout = (double) $parameters->read_write_timeout;
            $rwtimeout = $rwtimeout > 0 ? $rwtimeout : -1;
            $timeoutSeconds = floor($rwtimeout);
            $timeoutUSeconds = ($rwtimeout - $timeoutSeconds) * 1000000;
            stream_set_timeout($resource, $timeoutSeconds, $timeoutUSeconds);
        }
        return $resource;
    }
    public function connect()
    {
        if (parent::connect() && $this->initCommands) {
            foreach ($this->initCommands as $command) {
                $this->executeCommand($command);
            }
        }
    }
    public function disconnect()
    {
        if ($this->isConnected()) {
            fclose($this->getResource());
            parent::disconnect();
        }
    }
    protected function write($buffer)
    {
        $socket = $this->getResource();
        while (($length = strlen($buffer)) > 0) {
            $written = @fwrite($socket, $buffer);
            if ($length === $written) {
                return;
            }
            if ($written === false || $written === 0) {
                $this->onConnectionError('Error while writing bytes to the server.');
            }
            $buffer = substr($buffer, $written);
        }
    }
    public function read()
    {
        $socket = $this->getResource();
        $chunk = fgets($socket);
        if ($chunk === false || $chunk === '') {
            $this->onConnectionError('Error while reading line from the server.');
        }
        $prefix = $chunk[0];
        $payload = substr($chunk, 1, -2);
        switch ($prefix) {
            case '+':
                return StatusResponse::get($payload);
            case '$':
                $size = (int) $payload;
                if ($size === -1) {
                    return;
                }
                $bulkData = '';
                $bytesLeft = $size += 2;
                do {
                    $chunk = fread($socket, min($bytesLeft, 4096));
                    if ($chunk === false || $chunk === '') {
                        $this->onConnectionError('Error while reading bytes from the server.');
                    }
                    $bulkData .= $chunk;
                    $bytesLeft = $size - strlen($bulkData);
                } while ($bytesLeft > 0);
                return substr($bulkData, 0, -2);
            case '*':
                $count = (int) $payload;
                if ($count === -1) {
                    return;
                }
                $multibulk = array();
                for ($i = 0; $i < $count; ++$i) {
                    $multibulk[$i] = $this->read();
                }
                return $multibulk;
            case ':':
                return (int) $payload;
            case '-':
                return new ErrorResponse($payload);
            default:
                $this->onProtocolError("Unknown response prefix: '{$prefix}'.");
                return;
        }
    }
    public function writeRequest(CommandInterface $command)
    {
        $commandID = $command->getId();
        $arguments = $command->getArguments();
        $cmdlen = strlen($commandID);
        $reqlen = count($arguments) + 1;
        $buffer = "*{$reqlen}\r\n\${$cmdlen}\r\n{$commandID}\r\n";
        foreach ($arguments as $argument) {
            $arglen = strlen($argument);
            $buffer .= "\${$arglen}\r\n{$argument}\r\n";
        }
        $this->write($buffer);
    }
}
}

namespace Predis\Response {
interface ResponseInterface
{
}
}

namespace Predis\Configuration {
interface OptionsInterface
{
    public function getDefault($option);
    public function defined($option);
    public function __isset($option);
    public function __get($option);
}
}

namespace Predis\Configuration {
interface OptionInterface
{
    public function filter(OptionsInterface $options, $value);
    public function getDefault(OptionsInterface $options);
}
}

namespace Predis {
use Predis\Command\CommandInterface;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Profile\ProfileInterface;
interface ClientInterface
{
    public function getProfile();
    public function getOptions();
    public function connect();
    public function disconnect();
    public function getConnection();
    public function createCommand($method, $arguments = array());
    public function executeCommand(CommandInterface $command);
    public function __call($method, $arguments);
}
}

namespace Predis {
use Predis\Command\CommandInterface;
use Predis\Command\RawCommand;
use Predis\Command\ScriptCommand;
use Predis\Configuration\Options;
use Predis\Configuration\OptionsInterface;
use Predis\Connection\AggregateConnectionInterface;
use Predis\Connection\ConnectionInterface;
use Predis\Connection\ParametersInterface;
use Predis\Monitor\Consumer as MonitorConsumer;
use Predis\Pipeline\Pipeline;
use Predis\PubSub\Consumer as PubSubConsumer;
use Predis\Response\ErrorInterface as ErrorResponseInterface;
use Predis\Response\ResponseInterface;
use Predis\Response\ServerException;
use Predis\Transaction\MultiExec as MultiExecTransaction;
class Client implements ClientInterface
{
    const VERSION = '1.0.4';
    protected $connection;
    protected $options;
    private $profile;
    public function __construct($parameters = null, $options = null)
    {
        $this->options = $this->createOptions($options ?: array());
        $this->connection = $this->createConnection($parameters ?: array());
        $this->profile = $this->options->profile;
    }
    protected function createOptions($options)
    {
        if (is_array($options)) {
            return new Options($options);
        }
        if ($options instanceof OptionsInterface) {
            return $options;
        }
        throw new \InvalidArgumentException('Invalid type for client options.');
    }
    protected function createConnection($parameters)
    {
        if ($parameters instanceof ConnectionInterface) {
            return $parameters;
        }
        if ($parameters instanceof ParametersInterface || is_string($parameters)) {
            return $this->options->connections->create($parameters);
        }
        if (is_array($parameters)) {
            if (!isset($parameters[0])) {
                return $this->options->connections->create($parameters);
            }
            $options = $this->options;
            if ($options->defined('aggregate')) {
                $initializer = $this->getConnectionInitializerWrapper($options->aggregate);
                $connection = $initializer($parameters, $options);
            } else {
                if ($options->defined('replication') && ($replication = $options->replication)) {
                    $connection = $replication;
                } else {
                    $connection = $options->cluster;
                }
                $options->connections->aggregate($connection, $parameters);
            }
            return $connection;
        }
        if (is_callable($parameters)) {
            $initializer = $this->getConnectionInitializerWrapper($parameters);
            $connection = $initializer($this->options);
            return $connection;
        }
        throw new \InvalidArgumentException('Invalid type for connection parameters.');
    }
    protected function getConnectionInitializerWrapper($callable)
    {
        return function () use($callable) {
            $connection = call_user_func_array($callable, func_get_args());
            if (!$connection instanceof ConnectionInterface) {
                throw new \UnexpectedValueException('The callable connection initializer returned an invalid type.');
            }
            return $connection;
        };
    }
    public function getProfile()
    {
        return $this->profile;
    }
    public function getOptions()
    {
        return $this->options;
    }
    public function getClientFor($connectionID)
    {
        if (!($connection = $this->getConnectionById($connectionID))) {
            throw new \InvalidArgumentException("Invalid connection ID: {$connectionID}.");
        }
        return new static($connection, $this->options);
    }
    public function connect()
    {
        $this->connection->connect();
    }
    public function disconnect()
    {
        $this->connection->disconnect();
    }
    public function quit()
    {
        $this->disconnect();
    }
    public function isConnected()
    {
        return $this->connection->isConnected();
    }
    public function getConnection()
    {
        return $this->connection;
    }
    public function getConnectionById($connectionID)
    {
        if (!$this->connection instanceof AggregateConnectionInterface) {
            throw new NotSupportedException('Retrieving connections by ID is supported only by aggregate connections.');
        }
        return $this->connection->getConnectionById($connectionID);
    }
    public function executeRaw(array $arguments, &$error = null)
    {
        $error = false;
        $response = $this->connection->executeCommand(new RawCommand($arguments));
        if ($response instanceof ResponseInterface) {
            if ($response instanceof ErrorResponseInterface) {
                $error = true;
            }
            return (string) $response;
        }
        return $response;
    }
    public function __call($commandID, $arguments)
    {
        return $this->executeCommand($this->createCommand($commandID, $arguments));
    }
    public function createCommand($commandID, $arguments = array())
    {
        return $this->profile->createCommand($commandID, $arguments);
    }
    public function executeCommand(CommandInterface $command)
    {
        $response = $this->connection->executeCommand($command);
        if ($response instanceof ResponseInterface) {
            if ($response instanceof ErrorResponseInterface) {
                $response = $this->onErrorResponse($command, $response);
            }
            return $response;
        }
        return $command->parseResponse($response);
    }
    protected function onErrorResponse(CommandInterface $command, ErrorResponseInterface $response)
    {
        if ($command instanceof ScriptCommand && $response->getErrorType() === 'NOSCRIPT') {
            $eval = $this->createCommand('EVAL');
            $eval->setRawArguments($command->getEvalArguments());
            $response = $this->executeCommand($eval);
            if (!$response instanceof ResponseInterface) {
                $response = $command->parseResponse($response);
            }
            return $response;
        }
        if ($this->options->exceptions) {
            throw new ServerException($response->getMessage());
        }
        return $response;
    }
    private function sharedContextFactory($initializer, $argv = null)
    {
        switch (count($argv)) {
            case 0:
                return $this->{$initializer}();
            case 1:
                return is_array($argv[0]) ? $this->{$initializer}($argv[0]) : $this->{$initializer}(null, $argv[0]);
            case 2:
                list($arg0, $arg1) = $argv;
                return $this->{$initializer}($arg0, $arg1);
            default:
                return $this->{$initializer}($this, $argv);
        }
    }
    public function pipeline()
    {
        return $this->sharedContextFactory('createPipeline', func_get_args());
    }
    protected function createPipeline(array $options = null, $callable = null)
    {
        if (isset($options['atomic']) && $options['atomic']) {
            $class = 'Predis\\Pipeline\\Atomic';
        } elseif (isset($options['fire-and-forget']) && $options['fire-and-forget']) {
            $class = 'Predis\\Pipeline\\FireAndForget';
        } else {
            $class = 'Predis\\Pipeline\\Pipeline';
        }
        $pipeline = new $class($this);
        if (isset($callable)) {
            return $pipeline->execute($callable);
        }
        return $pipeline;
    }
    public function transaction()
    {
        return $this->sharedContextFactory('createTransaction', func_get_args());
    }
    protected function createTransaction(array $options = null, $callable = null)
    {
        $transaction = new MultiExecTransaction($this, $options);
        if (isset($callable)) {
            return $transaction->execute($callable);
        }
        return $transaction;
    }
    public function pubSubLoop()
    {
        return $this->sharedContextFactory('createPubSub', func_get_args());
    }
    protected function createPubSub(array $options = null, $callable = null)
    {
        $pubsub = new PubSubConsumer($this, $options);
        if (!isset($callable)) {
            return $pubsub;
        }
        foreach ($pubsub as $message) {
            if (call_user_func($callable, $pubsub, $message) === false) {
                $pubsub->stop();
            }
        }
    }
    public function monitor()
    {
        return new MonitorConsumer($this);
    }
}
}

namespace Predis\Configuration {
use Predis\Connection\Factory;
use Predis\Connection\FactoryInterface;
class ConnectionFactoryOption implements OptionInterface
{
    public function filter(OptionsInterface $options, $value)
    {
        if ($value instanceof FactoryInterface) {
            return $value;
        } elseif (is_array($value)) {
            $factory = $this->getDefault($options);
            foreach ($value as $scheme => $initializer) {
                $factory->define($scheme, $initializer);
            }
            return $factory;
        } else {
            throw new \InvalidArgumentException('Invalid value provided for the connections option.');
        }
    }
    public function getDefault(OptionsInterface $options)
    {
        return new Factory();
    }
}
}

namespace Predis\Configuration {
class Options implements OptionsInterface
{
    protected $input;
    protected $options;
    protected $handlers;
    public function __construct(array $options = array())
    {
        $this->input = $options;
        $this->options = array();
        $this->handlers = $this->getHandlers();
    }
    protected function getHandlers()
    {
        return array('cluster' => 'Predis\\Configuration\\ClusterOption', 'connections' => 'Predis\\Configuration\\ConnectionFactoryOption', 'exceptions' => 'Predis\\Configuration\\ExceptionsOption', 'prefix' => 'Predis\\Configuration\\PrefixOption', 'profile' => 'Predis\\Configuration\\ProfileOption', 'replication' => 'Predis\\Configuration\\ReplicationOption');
    }
    public function getDefault($option)
    {
        if (isset($this->handlers[$option])) {
            $handler = $this->handlers[$option];
            $handler = new $handler();
            return $handler->getDefault($this);
        }
    }
    public function defined($option)
    {
        return array_key_exists($option, $this->options) || array_key_exists($option, $this->input);
    }
    public function __isset($option)
    {
        return (array_key_exists($option, $this->options) || array_key_exists($option, $this->input)) && $this->__get($option) !== null;
    }
    public function __get($option)
    {
        if (isset($this->options[$option]) || array_key_exists($option, $this->options)) {
            return $this->options[$option];
        }
        if (isset($this->input[$option]) || array_key_exists($option, $this->input)) {
            $value = $this->input[$option];
            unset($this->input[$option]);
            if (is_object($value) && method_exists($value, '__invoke')) {
                $value = $value($this, $option);
            }
            if (isset($this->handlers[$option])) {
                $handler = $this->handlers[$option];
                $handler = new $handler();
                $value = $handler->filter($this, $value);
            }
            return $this->options[$option] = $value;
        }
        if (isset($this->handlers[$option])) {
            return $this->options[$option] = $this->getDefault($option);
        }
        return;
    }
}
}

namespace Royalcms\Component\Redis\Connections {
use Closure;
abstract class Connection
{
    protected $client;
    public abstract function createSubscription($channels, Closure $callback, $method = 'subscribe');
    public function client()
    {
        return $this->client;
    }
    public function subscribe($channels, Closure $callback)
    {
        return $this->createSubscription($channels, $callback, __FUNCTION__);
    }
    public function psubscribe($channels, Closure $callback)
    {
        return $this->createSubscription($channels, $callback, __FUNCTION__);
    }
    public function command($method, array $parameters = [])
    {
        return call_user_func_array([$this->client, $method], $parameters);
    }
    public function __call($method, $parameters)
    {
        return $this->command($method, $parameters);
    }
}
}

namespace Royalcms\Component\Redis\Connections {
use Closure;
class PredisConnection extends Connection
{
    public function __construct($client)
    {
        $this->client = $client;
    }
    public function createSubscription($channels, Closure $callback, $method = 'subscribe')
    {
        $loop = $this->pubSubLoop();
        call_user_func_array([$loop, $method], (array) $channels);
        foreach ($loop as $message) {
            if ($message->kind === 'message' || $message->kind === 'pmessage') {
                call_user_func($callback, $message->payload, $message->channel);
            }
        }
        unset($loop);
    }
}
}

namespace Royalcms\Component\Redis\Connectors {
use Predis\Client;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Redis\Connections\PredisConnection;
use Royalcms\Component\Redis\Connections\PredisClusterConnection;
class PredisConnector
{
    public function connect(array $config, array $options)
    {
        $formattedOptions = array_merge(['timeout' => 10.0], $options, Arr::pull($config, 'options', []));
        return new PredisConnection(new Client($config, $formattedOptions));
    }
    public function connectToCluster(array $config, array $clusterOptions, array $options)
    {
        $clusterSpecificOptions = Arr::pull($config, 'options', []);
        return new PredisClusterConnection(new Client(array_values($config), array_merge($options, $clusterOptions, $clusterSpecificOptions)));
    }
}
}

namespace Royalcms\Component\Redis\Contracts {
interface Factory
{
    public function connection($name = null);
}
}

namespace Royalcms\Component\Redis {
use Royalcms\Component\Support\Arr;
use InvalidArgumentException;
use Royalcms\Component\Redis\Contracts\Factory;
class RedisManager implements Factory
{
    protected $driver;
    protected $config;
    protected $connections;
    public function __construct($driver, array $config)
    {
        $this->driver = $driver;
        $this->config = $config;
    }
    public function connection($name = null)
    {
        $name = $name ?: 'default';
        if (isset($this->connections[$name])) {
            return $this->connections[$name];
        }
        return $this->connections[$name] = $this->resolve($name);
    }
    public function resolve($name = null)
    {
        $name = $name ?: 'default';
        $options = Arr::get($this->config, 'options', []);
        if (isset($this->config[$name])) {
            return $this->connector()->connect($this->config[$name], $options);
        }
        if (isset($this->config['clusters'][$name])) {
            return $this->resolveCluster($name);
        }
        throw new InvalidArgumentException("Redis connection [{$name}] not configured.");
    }
    protected function resolveCluster($name)
    {
        $clusterOptions = Arr::get($this->config, 'clusters.options', []);
        return $this->connector()->connectToCluster($this->config['clusters'][$name], $clusterOptions, Arr::get($this->config, 'options', []));
    }
    protected function connector()
    {
        switch ($this->driver) {
            case 'predis':
                return new Connectors\PredisConnector();
            case 'phpredis':
                return new Connectors\PhpRedisConnector();
        }
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array([$this->connection(), $method], $parameters);
    }
}
}

namespace Royalcms\Component\Gettext\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Gettext extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'gettext';
    }
}
}

namespace Royalcms\Component\Gettext {
use RC_Hook;
class Locale
{
    private $locale;
    public function getLocale()
    {
        if (isset($this->locale)) {
            return RC_Hook::apply_filters('locale', $this->locale);
        }
        if (royalcms('config')->has('system.locale')) {
            $this->locale = royalcms('config')->get('system.locale');
        }
        if (empty($this->locale)) {
            $this->locale = 'zh_CN';
        }
        return RC_Hook::apply_filters('locale', $this->locale);
    }
}
}

namespace Royalcms\Component\Gettext {
use RC_Hook;
use Royalcms\Component\Foundation\Theme;
use Royalcms\Component\Support\Facades\File;
use Royalcms\Component\Gettext\Translations\NoopTranslations;
class TextdomainManager
{
    protected $l10n = array();
    protected $locale;
    protected $royalcms;
    public function __construct(Locale $locale)
    {
        $this->locale = $locale;
        $this->royalcms = royalcms();
    }
    public function loadDefaultTextdomain()
    {
        $locale = $this->locale->getLocale();
        $this->loadTextdomain('default', \RC_Uri::admin_path() . "languages/{$locale}/system.mo");
    }
    public function isTextdomainLoaded($domain)
    {
        return isset($this->l10n[$domain]);
    }
    public function getTranslationsForDomain($domain)
    {
        if (!isset($this->l10n[$domain])) {
            $this->l10n[$domain] = new NoopTranslations();
        }
        return $this->l10n[$domain];
    }
    public function loadTextdomain($domain, $mofile)
    {
        $plugin_override = RC_Hook::apply_filters('override_load_textdomain', false, $domain, $mofile);
        if (true == $plugin_override) {
            return true;
        }
        RC_Hook::do_action('load_textdomain', $domain, $mofile);
        $mofile = RC_Hook::apply_filters('load_textdomain_mofile', $mofile, $domain);
        if (!is_readable($mofile)) {
            return false;
        }
        $mo = new MachineObject();
        if (!$mo->import_from_file($mofile)) {
            return false;
        }
        if (isset($l10n[$domain])) {
            $mo->merge_with($this->l10n[$domain]);
        }
        $this->l10n[$domain] =& $mo;
        return true;
    }
    public function unloadTextdomain($domain)
    {
        $plugin_override = RC_Hook::apply_filters('override_unload_textdomain', false, $domain);
        if ($plugin_override) {
            return true;
        }
        RC_Hook::do_action('unload_textdomain', $domain);
        if (isset($this->l10n[$domain])) {
            unset($this->l10n[$domain]);
            return true;
        }
        return false;
    }
    public function loadThemeTextdomain($domain, $path = false)
    {
        $locale = $this->locale->getLocale();
        $locale = RC_Hook::apply_filters('theme_locale', $locale, $domain);
        if (!$path) {
            $path = Theme::get_template_directory();
        }
        $path = rtrim($path, '/');
        $mofile = "{$path}/languages/{$locale}/{$domain}.mo";
        $loaded = $this->loadTextdomain($domain, $mofile);
        if ($loaded) {
            return $loaded;
        }
        $mofile = $this->royalcms->langPath() . "themes/{$domain}-{$locale}.mo";
        return $this->loadTextdomain($domain, $mofile);
    }
    public function loadChildThemeTextdomain($domain, $path = false)
    {
        if (!$path) {
            $path = Theme::get_template_directory();
        }
        return $this->loadThemeTextdomain($domain, $path);
    }
    public function loadAppTextdomain($domain, $app_rel_path = false)
    {
        $locale = $this->locale->getLocale();
        $locale = RC_Hook::apply_filters('app_locale', $locale, $domain);
        if (false !== $app_rel_path) {
            $path = $this->royalcms->appPath() . trim($app_rel_path, '/');
        } else {
            $path = rtrim($this->royalcms->appPath(), '/');
        }
        $mofile = "{$domain}/languages/{$locale}/{$domain}.mo";
        $loaded = $this->loadTextdomain($domain, $path . '/' . $mofile);
        if ($loaded) {
            return $loaded;
        }
        $mofile = $this->royalcms->langPath() . '/apps/' . $domain . '-' . $locale . '.mo';
        return $this->loadTextdomain($domain, $mofile);
    }
    public function loadPluginTextdomain($domain, $plugin_rel_path = false)
    {
        $locale = $this->locale->getLocale();
        $locale = RC_Hook::apply_filters('plugin_locale', $locale, $domain);
        if (false !== $plugin_rel_path) {
            $path = $this->royalcms->pluginPath() . trim($plugin_rel_path, '/');
        } else {
            $path = rtrim($this->royalcms->pluginPath(), '/');
        }
        $mofile = "{$domain}/languages/{$locale}/{$domain}.mo";
        $loaded = $this->loadTextdomain($domain, $path . '/' . $mofile);
        if ($loaded) {
            return $loaded;
        }
        $mofile = $this->royalcms->langPath() . '/plugins/' . $domain . '-' . $locale . '.mo';
        return $this->loadTextdomain($domain, $mofile);
    }
    public function getAvailableLanguages($dir = null)
    {
        $languages = array();
        foreach ((array) glob((is_null($dir) ? SITE_LANG_PATH : $dir) . '/*.mo') as $lang_file) {
            $lang_file = basename($lang_file, '.mo');
            if (0 !== strpos($lang_file, 'continents-cities') && 0 !== strpos($lang_file, 'ms-') && 0 !== strpos($lang_file, 'admin-')) {
                $languages[] = $lang_file;
            }
        }
        return $languages;
    }
    public function getInstalledTranslations($type)
    {
        if ($type !== 'themes' && $type !== 'plugins' && $type !== 'core') {
            return array();
        }
        $dir = 'core' === $type ? '' : "/{$type}";
        if (!is_dir(SITE_LANG_PATH)) {
            return array();
        }
        if ($dir && !is_dir(SITE_LANG_PATH . $dir)) {
            return array();
        }
        $files = scandir(SITE_LANG_PATH . $dir);
        if (!$files) {
            return array();
        }
        $language_data = array();
        foreach ($files as $file) {
            if ('.' === $file[0] || is_dir($file)) {
                continue;
            }
            if (substr($file, -3) !== '.po') {
                continue;
            }
            if (!preg_match('/(?:(.+)-)?([A-Za-z_]{2,6}).po/', $file, $match)) {
                continue;
            }
            list(, $textdomain, $language) = $match;
            if ('' === $textdomain) {
                $textdomain = 'default';
            }
            $language_data[$textdomain][$language] = $this->getPomoFileData(SITE_LANG_PATH . "{$dir}/{$file}");
        }
        return $language_data;
    }
    public function getPomoFileData($po_file)
    {
        $headers = File::get_file_data($po_file, array('POT-Creation-Date' => '"POT-Creation-Date', 'PO-Revision-Date' => '"PO-Revision-Date', 'Project-Id-Version' => '"Project-Id-Version', 'X-Generator' => '"X-Generator'));
        foreach ($headers as $header => $value) {
            $headers[$header] = preg_replace('~(\\\\n)?"$~', '', $value);
        }
        return $headers;
    }
}
}

namespace Royalcms\Component\Gettext {
use RC_Hook;
use Royalcms\Component\Foundation\Royalcms;
class Gettext
{
    protected $royalcms;
    protected $textdomain;
    public function __construct(Royalcms $royalcms, TextdomainManager $textdomain)
    {
        $this->royalcms = $royalcms;
        $this->textdomain = $textdomain;
    }
    public function translate($text, $domain = 'default')
    {
        $translations = $this->textdomain->getTranslationsForDomain($domain);
        $translations = $translations->translate($text);
        return RC_Hook::apply_filters('gettext', $translations, $text, $domain);
    }
    public function translateWithGettextContext($text, $context, $domain = 'default')
    {
        $translations = $this->textdomain->getTranslationsForDomain($domain);
        $translations = $translations->translate($text, $context);
        return RC_Hook::apply_filters('gettext_with_context', $translations, $text, $context, $domain);
    }
    public function _n($single, $plural, $number, $domain = 'default')
    {
        $translations = $this->textdomain->getTranslationsForDomain($domain);
        $translation = $translations->translate_plural($single, $plural, $number);
        return RC_Hook::apply_filters('ngettext', $translation, $single, $plural, $number, $domain);
    }
    public function _nx($single, $plural, $number, $context, $domain = 'default')
    {
        $translations = $this->textdomain->getTranslationsForDomain($domain);
        $translation = $translations->translate_plural($single, $plural, $number, $context);
        return RC_Hook::apply_filters('ngettext_with_context', $translation, $single, $plural, $number, $context, $domain);
    }
    public function _n_noop($singular, $plural, $domain = null)
    {
        return array(0 => $singular, 1 => $plural, 'singular' => $singular, 'plural' => $plural, 'context' => null, 'domain' => $domain);
    }
    public function _nx_noop($singular, $plural, $context, $domain = null)
    {
        return array(0 => $singular, 1 => $plural, 2 => $context, 'singular' => $singular, 'plural' => $plural, 'context' => $context, 'domain' => $domain);
    }
    public function translateNoopedPlural($nooped_plural, $count, $domain = 'default')
    {
        if ($nooped_plural['domain']) {
            $domain = $nooped_plural['domain'];
        }
        if ($nooped_plural['context']) {
            return self::_nx($nooped_plural['singular'], $nooped_plural['plural'], $count, $nooped_plural['context'], $domain);
        } else {
            return self::_n($nooped_plural['singular'], $nooped_plural['plural'], $count, $domain);
        }
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array(array($this->textdomain, $method), $parameters);
    }
}
}

namespace Royalcms\Component\Gettext {
use Royalcms\Component\Support\ServiceProvider;
class GettextServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
    }
    public function register()
    {
        $this->royalcms->singleton('gettext', function ($royalcms) {
            $locale = new Locale();
            $textdomain = new TextdomainManager($locale);
            return new Gettext($royalcms, $textdomain);
        });
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Gettext', 'Royalcms\\Component\\Gettext\\Facades\\Gettext');
            $loader->alias('RC_Locale', 'Royalcms\\Component\\Gettext\\Facades\\Gettext');
        });
    }
    public function provides()
    {
        return array('gettext');
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/gettext');
        return [$dir . "/Facades/Gettext.php", $dir . "/Locale.php", $dir . "/TextdomainManager.php", $dir . "/Gettext.php", $dir . "/GettextServiceProvider.php", $dir . "/Translations/NoopTranslations.php"];
    }
}
}

namespace Royalcms\Component\Gettext\Translations {
class NoopTranslations
{
    protected $entries = array();
    protected $headers = array();
    public function add_entry($entry)
    {
        return true;
    }
    public function set_header($header, $value)
    {
    }
    public function set_headers($headers)
    {
    }
    public function get_header($header)
    {
        return false;
    }
    public function translate_entry(&$entry)
    {
        return false;
    }
    public function translate($singular, $context = null)
    {
        return $singular;
    }
    public function select_plural_form($count)
    {
        return 1 == $count ? 0 : 1;
    }
    public function get_plural_forms_count()
    {
        return 2;
    }
    public function translate_plural($singular, $plural, $count, $context = null)
    {
        return 1 == $count ? $singular : $plural;
    }
    public function merge_with(&$other)
    {
    }
}
}

namespace Royalcms\Component\Cache\SpecialStores {
use Royalcms\Component\Support\Facades\Config as RC_Config;
trait AppCache
{
    public static function app_cache_set($name, $data, $app, $expire = null)
    {
        $config = RC_Config::get('cache.stores.file');
        $expire = $expire ?: $config['expire'];
        $key = $app . ':' . $name;
        return static::put($key, $data, $expire);
    }
    public static function app_cache_add($name, $data, $app, $expire = null)
    {
        $config = RC_Config::get('cache.stores.file');
        $expire = $expire ?: $config['expire'];
        $key = $app . ':' . $name;
        return static::add($key, $data, $expire);
    }
    public static function app_cache_get($name, $app)
    {
        $key = $app . ':' . $name;
        return static::get($key);
    }
    public static function app_cache_delete($name, $app)
    {
        $key = $app . ':' . $name;
        return static::forget($key);
    }
}
}

namespace Royalcms\Component\Cache\SpecialStores {
use Royalcms\Component\Support\Facades\Config as RC_Config;
trait UserDataCache
{
    public static function userdata_cache_set($name, $data, $userid, $isadmin = false, $expire = null)
    {
        $config = RC_Config::get('cache.stores.userdata_cache');
        $expire = $expire ?: $config['expire'];
        $key = 'userdata_cache:' . $name . $userid . $isadmin;
        return static::driver('userdata_cache')->put($key, $data, $expire);
    }
    public static function userdata_cache_get($name, $userid, $isadmin = false, $expire = null)
    {
        $key = 'userdata_cache:' . $name . $userid . $isadmin;
        return static::driver('userdata_cache')->get($key);
    }
    public static function userdata_cache_delete($name, $userid, $isadmin = false, $expire = null)
    {
        $key = 'userdata_cache:' . $name . $userid . $isadmin;
        return static::driver('userdata_cache')->forget($key);
    }
}
}

namespace Royalcms\Component\Cache\SpecialStores {
use Royalcms\Component\Support\Facades\Config as RC_Config;
trait TableCache
{
    public static function table_cache_set($name, $data, $expire = null)
    {
        $config = RC_Config::get('cache.stores.table_cache');
        $expire = $expire ?: $config['expire'];
        $key = 'table_cache:' . $name;
        return static::driver('table_cache')->put($key, $data, $expire);
    }
    public static function table_cache_get($name)
    {
        $key = 'table_cache:' . $name;
        return static::driver('table_cache')->get($key);
    }
    public static function table_cache_delete($name)
    {
        $key = 'table_cache:' . $name;
        return static::driver('table_cache')->forget($key);
    }
}
}

namespace Royalcms\Component\Cache\SpecialStores {
use Royalcms\Component\Support\Facades\Config as RC_Config;
trait QueryCache
{
    public static function query_cache_set($name, $data, $expire = null)
    {
        $config = RC_Config::get('cache.stores.query_cache');
        $expire = $expire ?: $config['expire'];
        $key = 'query_cache:' . $name;
        return static::driver('query_cache')->put($key, $data, $expire);
    }
    public static function query_cache_get($name)
    {
        $key = 'query_cache:' . $name;
        return static::driver('query_cache')->get($key);
    }
    public static function query_cache_delete($name)
    {
        $key = 'query_cache:' . $name;
        return static::driver('query_cache')->forget($key);
    }
}
}

namespace Royalcms\Component\Cache\SpecialStores {
use Royalcms\Component\Cache\Memory;
trait MemoryCache
{
    private static $memory_object_cache;
    public static function memory_cache_init()
    {
        self::$memory_object_cache = new Memory();
    }
    public static function memory_cache_add($key, $data, $group = '', $expire = 0)
    {
        return self::$memory_object_cache->add($key, $data, $group, (int) $expire);
    }
    public static function memory_cache_close()
    {
        return true;
    }
    public static function memory_cache_decr($key, $offset = 1, $group = '')
    {
        return self::$memory_object_cache->decr($key, $offset, $group);
    }
    public static function memory_cache_delete($key, $group = '')
    {
        return self::$memory_object_cache->delete($key, $group);
    }
    public static function memory_cache_flush()
    {
        return self::$memory_object_cache->flush();
    }
    public static function memory_cache_get($key, $group = '', $force = false, &$found = null)
    {
        return self::$memory_object_cache->get($key, $group, $force, $found);
    }
    public static function memory_cache_incr($key, $offset = 1, $group = '')
    {
        return self::$memory_object_cache->incr($key, $offset, $group);
    }
    public static function memory_cache_replace($key, $data, $group = '', $expire = 0)
    {
        return self::$memory_object_cache->replace($key, $data, $group, (int) $expire);
    }
    public static function memory_cache_set($key, $data, $group = '', $expire = 0)
    {
        return self::$memory_object_cache->set($key, $data, $group, (int) $expire);
    }
    public static function memory_cache_switch_to_site($site_name)
    {
        return self::$memory_object_cache->switch_to_site($site_name);
    }
    public static function memory_cache_add_global_groups($groups)
    {
        return self::$memory_object_cache->add_global_groups($groups);
    }
    public static function memory_cache_add_non_persistent_groups($groups)
    {
        return;
    }
    public static function memory_cache_reset()
    {
        return self::$memory_object_cache->reset();
    }
}
}

namespace Royalcms\Component\Hook {
class Hooks
{
    var $filters = array();
    var $merged_filters = array();
    var $actions = array();
    var $current_filter = array();
    public function __construct($args = null)
    {
        $this->filters = array();
        $this->merged_filters = array();
        $this->actions = array();
        $this->current_filter = array();
    }
    public function add_filter($tag, $function_to_add, $priority = 10, $accepted_args = 1)
    {
        $idx = $this->_filter_build_unique_id($tag, $function_to_add, $priority);
        $this->filters[$tag][$priority][$idx] = array('function' => $function_to_add, 'accepted_args' => $accepted_args);
        unset($this->merged_filters[$tag]);
        return true;
    }
    public function remove_filter($tag, $function_to_remove, $priority = 10)
    {
        $function_to_remove = $this->_filter_build_unique_id($tag, $function_to_remove, $priority);
        $r = isset($this->filters[$tag][$priority][$function_to_remove]);
        if (true === $r) {
            unset($this->filters[$tag][$priority][$function_to_remove]);
            if (empty($this->filters[$tag][$priority])) {
                unset($this->filters[$tag][$priority]);
            }
            unset($this->merged_filters[$tag]);
        }
        return $r;
    }
    public function remove_all_filters($tag, $priority = false)
    {
        if (isset($this->filters[$tag])) {
            if (false !== $priority && isset($this->filters[$tag][$priority])) {
                unset($this->filters[$tag][$priority]);
            } else {
                unset($this->filters[$tag]);
            }
        }
        if (isset($this->merged_filters[$tag])) {
            unset($this->merged_filters[$tag]);
        }
        return true;
    }
    public function has_filter($tag, $function_to_check = false)
    {
        $has = !empty($this->filters[$tag]);
        if (false === $function_to_check || false == $has) {
            return $has;
        }
        if (!($idx = $this->_filter_build_unique_id($tag, $function_to_check, false))) {
            return false;
        }
        foreach ((array) array_keys($this->filters[$tag]) as $priority) {
            if (isset($this->filters[$tag][$priority][$idx])) {
                return $priority;
            }
        }
        return false;
    }
    public function apply_filters($tag, $value)
    {
        $args = array();
        if (isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
            $args = func_get_args();
            $this->__call_all_hook($args);
        }
        if (!isset($this->filters[$tag])) {
            if (isset($this->filters['all'])) {
                array_pop($this->current_filter);
            }
            return $value;
        }
        if (!isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
        }
        if (!isset($this->merged_filters[$tag])) {
            ksort($this->filters[$tag]);
            $this->merged_filters[$tag] = true;
        }
        reset($this->filters[$tag]);
        if (empty($args)) {
            $args = func_get_args();
        }
        do {
            foreach ((array) current($this->filters[$tag]) as $the_) {
                if (!is_null($the_['function'])) {
                    $args[1] = $value;
                    $value = call_user_func_array($the_['function'], array_slice($args, 1, (int) $the_['accepted_args']));
                }
            }
        } while (next($this->filters[$tag]) !== false);
        array_pop($this->current_filter);
        return $value;
    }
    public function apply_filters_ref_array($tag, $args)
    {
        if (isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
            $all_args = func_get_args();
            $this->__call_all_hook($all_args);
        }
        if (!isset($this->filters[$tag])) {
            if (isset($this->filters['all'])) {
                array_pop($this->current_filter);
            }
            return $args[0];
        }
        if (!isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
        }
        if (!isset($this->merged_filters[$tag])) {
            ksort($this->filters[$tag]);
            $this->merged_filters[$tag] = true;
        }
        reset($this->filters[$tag]);
        do {
            foreach ((array) current($this->filters[$tag]) as $the_) {
                if (!is_null($the_['function'])) {
                    $args[0] = call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));
                }
            }
        } while (next($this->filters[$tag]) !== false);
        array_pop($this->current_filter);
        return $args[0];
    }
    public function add_action($tag, $function_to_add, $priority = 10, $accepted_args = 1)
    {
        return $this->add_filter($tag, $function_to_add, $priority, $accepted_args);
    }
    public function has_action($tag, $function_to_check = false)
    {
        return $this->has_filter($tag, $function_to_check);
    }
    public function remove_action($tag, $function_to_remove, $priority = 10)
    {
        return $this->remove_filter($tag, $function_to_remove, $priority);
    }
    public function remove_all_actions($tag, $priority = false)
    {
        return $this->remove_all_filters($tag, $priority);
    }
    public function do_action($tag, $arg = '')
    {
        if (!isset($this->actions)) {
            $this->actions = array();
        }
        if (!isset($this->actions[$tag])) {
            $this->actions[$tag] = 1;
        } else {
            ++$this->actions[$tag];
        }
        if (isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
            $all_args = func_get_args();
            $this->__call_all_hook($all_args);
        }
        if (!isset($this->filters[$tag])) {
            if (isset($this->filters['all'])) {
                array_pop($this->current_filter);
            }
            return;
        }
        if (!isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
        }
        $args = array();
        if (is_array($arg) && 1 == count($arg) && isset($arg[0]) && is_object($arg[0])) {
            $args[] =& $arg[0];
        } else {
            $args[] = $arg;
        }
        for ($a = 2; $a < func_num_args(); $a++) {
            $args[] = func_get_arg($a);
        }
        if (!isset($this->merged_filters[$tag])) {
            ksort($this->filters[$tag]);
            $this->merged_filters[$tag] = true;
        }
        reset($this->filters[$tag]);
        do {
            foreach ((array) current($this->filters[$tag]) as $the_) {
                if (!is_null($the_['function'])) {
                    call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));
                }
            }
        } while (next($this->filters[$tag]) !== false);
        array_pop($this->current_filter);
    }
    public function do_action_ref_array($tag, $args)
    {
        if (!isset($this->actions)) {
            $this->actions = array();
        }
        if (!isset($this->actions[$tag])) {
            $this->actions[$tag] = 1;
        } else {
            ++$this->actions[$tag];
        }
        if (isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
            $all_args = func_get_args();
            $this->__call_all_hook($all_args);
        }
        if (!isset($this->filters[$tag])) {
            if (isset($this->filters['all'])) {
                array_pop($this->current_filter);
            }
            return;
        }
        if (!isset($this->filters['all'])) {
            $this->current_filter[] = $tag;
        }
        if (!isset($merged_filters[$tag])) {
            ksort($this->filters[$tag]);
            $merged_filters[$tag] = true;
        }
        reset($this->filters[$tag]);
        do {
            foreach ((array) current($this->filters[$tag]) as $the_) {
                if (!is_null($the_['function'])) {
                    call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));
                }
            }
        } while (next($this->filters[$tag]) !== false);
        array_pop($this->current_filter);
    }
    public function did_action($tag)
    {
        if (!isset($this->actions) || !isset($this->actions[$tag])) {
            return 0;
        }
        return $this->actions[$tag];
    }
    public function current_filter()
    {
        return end($this->current_filter);
    }
    public function current_action()
    {
        return $this->current_filter();
    }
    public function doing_filter($filter = null)
    {
        if (null === $filter) {
            return !empty($this->current_filter);
        }
        return in_array($filter, $this->current_filter);
    }
    public function doing_action($action = null)
    {
        return $this->doing_filter($action);
    }
    private function _filter_build_unique_id($tag, $function, $priority)
    {
        static $filter_id_count = 0;
        if (is_string($function)) {
            return $function;
        }
        if (is_object($function)) {
            $function = array($function, '');
        } else {
            $function = (array) $function;
        }
        if (is_object($function[0])) {
            if (function_exists('spl_object_hash')) {
                return spl_object_hash($function[0]) . $function[1];
            } else {
                $obj_idx = get_class($function[0]) . $function[1];
                if (!isset($function[0]->filter_id)) {
                    if (false === $priority) {
                        return false;
                    }
                    $obj_idx .= isset($this->filters[$tag][$priority]) ? count((array) ${$this}->filters[$tag][$priority]) : $filter_id_count;
                    $function[0]->filter_id = $filter_id_count;
                    ++$filter_id_count;
                } else {
                    $obj_idx .= $function[0]->filter_id;
                }
                return $obj_idx;
            }
        } else {
            if (is_string($function[0])) {
                return $function[0] . $function[1];
            }
        }
    }
    public function __call_all_hook($args)
    {
        reset($this->filters['all']);
        do {
            foreach ((array) current($this->filters['all']) as $the_) {
                if (!is_null($the_['function'])) {
                    call_user_func_array($the_['function'], $args);
                }
            }
        } while (next($this->filters['all']) !== false);
    }
}
}

namespace Royalcms\Component\Hook {
use Royalcms\Component\Support\ServiceProvider;
class HookServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerHookService();
    }
    protected function registerHookService()
    {
        $this->royalcms->singleton('hook', function ($royalcms) {
            return new Hooks();
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/hook');
        return [$dir . '/Hooks.php', $dir . '/HookServiceProvider.php', $dir . '/Facades/Hook.php'];
    }
}
}

namespace Royalcms\Component\Hook\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Hook extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'hook';
    }
}
}

namespace Royalcms\Component\Script {
use RC_Hook;
class Script
{
    private static $instance = null;
    public function __construct()
    {
        self::instance();
    }
    public static function instance()
    {
        if (self::$instance === null) {
            self::$instance = new HandleScripts();
        }
        return self::$instance;
    }
    public static function print_scripts($handles = false)
    {
        RC_Hook::do_action('rc_print_scripts');
        if ('' === $handles) {
            $handles = false;
        }
        if (!$handles) {
            return array();
        } else {
            return self::$instance->do_items($handles);
        }
    }
    public static function register_script($handle, $src, $deps = array(), $ver = false, $in_footer = false)
    {
        self::$instance->add($handle, $src, $deps, $ver);
        if ($in_footer) {
            self::$instance->add_data($handle, 'group', 1);
        }
    }
    public static function localize_script($handle, $object_name, $l10n)
    {
        return self::$instance->localize($handle, $object_name, $l10n);
    }
    public static function deregister_script($handle)
    {
        self::$instance->remove($handle);
    }
    public static function enqueue_script($handle, $src = false, $deps = array(), $ver = false, $in_footer = false)
    {
        if ($src) {
            $_handle = explode('?', $handle);
            self::$instance->add($_handle[0], $src, $deps, $ver);
            if ($in_footer) {
                self::$instance->add_data($_handle[0], 'group', 1);
            }
        }
        self::$instance->enqueue($handle);
    }
    public static function dequeue_script($handle)
    {
        self::$instance->dequeue($handle);
    }
    public static function script_is($handle, $list = 'enqueued')
    {
        return (bool) self::$instance->query($handle, $list);
    }
}
}

namespace Royalcms\Component\Script {
use RC_Hook;
use RC_Format;
class HandleScripts extends Dependencies
{
    public $base_url;
    public $content_url;
    public $default_version;
    public $in_footer = array();
    public $concat = '';
    public $concat_version = '';
    public $do_concat = false;
    public $print_html = '';
    public $print_code = '';
    public $ext_handles = '';
    public $ext_version = '';
    public $default_dirs;
    public function __construct()
    {
        $this->init();
        RC_Hook::add_action('init', array($this, 'init'), 0);
    }
    public function init()
    {
        RC_Hook::do_action_ref_array('rc_default_scripts', array(&$this));
    }
    public function print_scripts($handles = false, $group = false)
    {
        return $this->do_items($handles, $group);
    }
    public function print_scripts_l10n($handle, $echo = true)
    {
        _deprecated_function(__FUNCTION__, '3.3.0', 'HandleScripts::print_extra_script()');
        return $this->print_extra_script($handle, $echo);
    }
    public function print_extra_script($handle, $echo = true)
    {
        if (!($output = $this->get_data($handle, 'data'))) {
            return null;
        }
        if (!$echo) {
            return $output;
        }
        echo "<script type='text/javascript'>\n";
        echo "/* <![CDATA[ */\n";
        echo "{$output}\n";
        echo "/* ]]> */\n";
        echo "</script>\n";
        return true;
    }
    public function do_item($handle, $group = false)
    {
        if (!parent::do_item($handle)) {
            return false;
        }
        if (0 === $group && $this->groups[$handle] > 0) {
            $this->in_footer[] = $handle;
            return false;
        }
        if (false === $group && in_array($handle, $this->in_footer, true)) {
            $this->in_footer = array_diff($this->in_footer, (array) $handle);
        }
        $obj = $this->registered[$handle];
        if (null === $obj->ver) {
            $ver = '';
        } else {
            $ver = $obj->ver ? $obj->ver : $this->default_version;
        }
        if (isset($this->args[$handle])) {
            $ver = $ver ? $ver . '&amp;' . $this->args[$handle] : $this->args[$handle];
        }
        $src = $obj->src;
        $cond_before = $cond_after = '';
        $conditional = isset($obj->extra['conditional']) ? $obj->extra['conditional'] : '';
        if ($conditional) {
            $cond_before = "<!--[if {$conditional}]>\n";
            $cond_after = "<![endif]-->\n";
        }
        $before_handle = $this->print_inline_script($handle, 'before', false);
        $after_handle = $this->print_inline_script($handle, 'after', false);
        if ($before_handle) {
            $before_handle = sprintf("<script type='text/javascript'>\n%s\n</script>\n", $before_handle);
        }
        if ($after_handle) {
            $after_handle = sprintf("<script type='text/javascript'>\n%s\n</script>\n", $after_handle);
        }
        if ($before_handle || $after_handle) {
            $inline_script_tag = "{$cond_before}{$before_handle}{$after_handle}{$cond_after}";
        } else {
            $inline_script_tag = '';
        }
        if ($this->do_concat) {
            $srce = RC_Hook::apply_filters('script_loader_src', $src, $handle);
            if ($this->in_default_dir($srce) && ($before_handle || $after_handle)) {
                $this->do_concat = false;
                _print_scripts();
                $this->reset();
            } elseif ($this->in_default_dir($srce) && !$conditional) {
                $this->print_code .= $this->print_extra_script($handle, false);
                $this->concat .= "{$handle},";
                $this->concat_version .= "{$handle}{$ver}";
                return true;
            } else {
                $this->ext_handles .= "{$handle},";
                $this->ext_version .= "{$handle}{$ver}";
            }
        }
        $has_conditional_data = $conditional && $this->get_data($handle, 'data');
        if ($has_conditional_data) {
            echo $cond_before;
        }
        $this->print_extra_script($handle);
        if ($has_conditional_data) {
            echo $cond_after;
        }
        if (!$src) {
            if ($inline_script_tag) {
                if ($this->do_concat) {
                    $this->print_html .= $inline_script_tag;
                } else {
                    echo $inline_script_tag;
                }
            }
            return true;
        }
        $translations = $this->print_translations($handle, false);
        if ($translations) {
            $translations = sprintf("<script type='text/javascript'>\n%s\n</script>\n", $translations);
        }
        if (!preg_match('|^(https?:)?//|', $src) && !($this->content_url && 0 === strpos($src, $this->content_url))) {
            $src = $this->base_url . $src;
        }
        if (!empty($ver)) {
            $src = \RC_Uri::add_query_arg('ver', $ver, $src);
        }
        $src = RC_Hook::apply_filters('script_loader_src', $src, $handle);
        $src = RC_Format::esc_url($src);
        if (!$src) {
            return true;
        }
        $tag = "{$translations}{$cond_before}{$before_handle}<script type='text/javascript' src='{$src}'></script>\n{$after_handle}{$cond_after}";
        $tag = RC_Hook::apply_filters('script_loader_tag', $tag, $handle, $src);
        if ($this->do_concat) {
            $this->print_html .= $tag;
        } else {
            echo $tag;
        }
        return true;
    }
    public function add_inline_script($handle, $data, $position = 'after')
    {
        if (!$data) {
            return false;
        }
        if ('after' !== $position) {
            $position = 'before';
        }
        $script = (array) $this->get_data($handle, $position);
        $script[] = $data;
        return $this->add_data($handle, $position, $script);
    }
    public function print_inline_script($handle, $position = 'after', $echo = true)
    {
        $output = $this->get_data($handle, $position);
        if (empty($output)) {
            return false;
        }
        $output = trim(implode("\n", $output), "\n");
        if ($echo) {
            printf("<script type='text/javascript'>\n%s\n</script>\n", $output);
        }
        return $output;
    }
    public function localize($handle, $object_name, $l10n)
    {
        if (is_array($l10n) && isset($l10n['l10n_print_after'])) {
            $after = $l10n['l10n_print_after'];
            unset($l10n['l10n_print_after']);
        }
        foreach ((array) $l10n as $key => $value) {
            if (!is_scalar($value)) {
                continue;
            }
            $l10n[$key] = html_entity_decode((string) $value, ENT_QUOTES, 'UTF-8');
        }
        $script = "var {$object_name} = " . json_encode($l10n) . ';';
        if (!empty($after)) {
            $script .= "\n{$after};";
        }
        $data = $this->get_data($handle, 'data');
        if (!empty($data)) {
            $script = "{$data}\n{$script}";
        }
        return $this->add_data($handle, 'data', $script);
    }
    public function set_group($handle, $recursion, $group = false)
    {
        if (isset($this->registered[$handle]->args) && $this->registered[$handle]->args === 1) {
            $grp = 1;
        } else {
            $grp = (int) $this->get_data($handle, 'group');
        }
        if (false !== $group && $grp > $group) {
            $grp = $group;
        }
        return parent::set_group($handle, $recursion, $grp);
    }
    public function set_translations($handle, $domain, $path = null)
    {
        if (!isset($this->registered[$handle])) {
            return false;
        }
        $obj = $this->registered[$handle];
        if (!in_array('wp-i18n', $obj->deps, true)) {
            $obj->deps[] = 'wp-i18n';
        }
        return $obj->set_translations($domain, $path);
    }
    public function print_translations($handle, $echo = true)
    {
        if (!isset($this->registered[$handle]) || empty($this->registered[$handle]->textdomain)) {
            return false;
        }
        $domain = $this->registered[$handle]->textdomain;
        $path = $this->registered[$handle]->translations_path;
        $json_translations = load_script_textdomain($handle, $domain, $path);
        if (!$json_translations) {
            $json_translations = '{ "locale_data": { "messages": { "": {} } } }';
        }
        $output = <<<JS
( function( domain, translations ) {
\tvar localeData = translations.locale_data[ domain ] || translations.locale_data.messages;
\tlocaleData[""].domain = domain;
\twp.i18n.setLocaleData( localeData, domain );
} )( "{$domain}", {$json_translations} );
JS;
        if ($echo) {
            printf("<script type='text/javascript'>\n%s\n</script>\n", $output);
        }
        return $output;
    }
    public function all_deps($handles, $recursion = false, $group = false)
    {
        $r = parent::all_deps($handles, $recursion);
        if (!$recursion) {
            $this->to_do = RC_Hook::apply_filters('print_scripts_array', $this->to_do);
        }
        return $r;
    }
    public function do_head_items()
    {
        $this->do_items(false, 0);
        return $this->done;
    }
    public function do_footer_items()
    {
        $this->do_items(false, 1);
        return $this->done;
    }
    public function in_default_dir($src)
    {
        if (!$this->default_dirs) {
            return true;
        }
        if (0 === strpos($src, '/statics/js/l10n')) {
            return false;
        }
        foreach ((array) $this->default_dirs as $test) {
            if (0 === strpos($src, $test)) {
                return true;
            }
        }
        return false;
    }
    public function reset()
    {
        $this->do_concat = false;
        $this->print_code = '';
        $this->concat = '';
        $this->concat_version = '';
        $this->print_html = '';
        $this->ext_version = '';
        $this->ext_handles = '';
    }
}
}

namespace Royalcms\Component\Script {
class Dependency
{
    public $handle;
    public $src;
    public $deps = array();
    public $ver = false;
    public $args = null;
    public $extra = array();
    public $textdomain;
    public $translations_path;
    public function __construct()
    {
        list($this->handle, $this->src, $this->deps, $this->ver, $this->args) = func_get_args();
        if (!is_array($this->deps)) {
            $this->deps = array();
        }
    }
    public function add_data($name, $data)
    {
        if (!is_scalar($name)) {
            return false;
        }
        $this->extra[$name] = $data;
        return true;
    }
    public function set_translations($domain, $path = null)
    {
        if (!is_string($domain)) {
            return false;
        }
        $this->textdomain = $domain;
        $this->translations_path = $path;
        return true;
    }
}
}

namespace Royalcms\Component\Script {
class Dependencies
{
    public $registered = array();
    public $queue = array();
    public $to_do = array();
    public $done = array();
    public $args = array();
    public $groups = array();
    public $group = 0;
    public function do_items($handles = false, $group = false)
    {
        $handles = false === $handles ? $this->queue : (array) $handles;
        $this->all_deps($handles);
        foreach ($this->to_do as $key => $handle) {
            if (!in_array($handle, $this->done, true) && isset($this->registered[$handle])) {
                if (!$this->registered[$handle]->src) {
                    $this->done[] = $handle;
                    continue;
                }
                if ($this->do_item($handle, $group)) {
                    $this->done[] = $handle;
                }
                unset($this->to_do[$key]);
            }
        }
        return $this->done;
    }
    public function do_item($handle, $group = false)
    {
        return isset($this->registered[$handle]);
    }
    public function all_deps($handles, $recursion = false, $group = false)
    {
        if (!($handles = (array) $handles)) {
            return false;
        }
        foreach ($handles as $handle) {
            $handle_parts = explode('?', $handle);
            $handle = $handle_parts[0];
            $queued = in_array($handle, $this->to_do, true);
            if (in_array($handle, $this->done, true)) {
                continue;
            }
            $moved = $this->set_group($handle, $recursion, $group);
            $new_group = $this->groups[$handle];
            if ($queued && !$moved) {
                continue;
            }
            $keep_going = true;
            if (!isset($this->registered[$handle])) {
                $keep_going = false;
            } elseif ($this->registered[$handle]->deps && array_diff($this->registered[$handle]->deps, array_keys($this->registered))) {
                $keep_going = false;
            } elseif ($this->registered[$handle]->deps && !$this->all_deps($this->registered[$handle]->deps, true, $new_group)) {
                $keep_going = false;
            }
            if (!$keep_going) {
                if ($recursion) {
                    return false;
                } else {
                    continue;
                }
            }
            if ($queued) {
                continue;
            }
            if (isset($handle_parts[1])) {
                $this->args[$handle] = $handle_parts[1];
            }
            $this->to_do[] = $handle;
        }
        return true;
    }
    public function add($handle, $src, $deps = array(), $ver = false, $args = null)
    {
        if (isset($this->registered[$handle])) {
            return false;
        }
        $this->registered[$handle] = new Dependency($handle, $src, $deps, $ver, $args);
        return true;
    }
    public function add_data($handle, $key, $value)
    {
        if (!isset($this->registered[$handle])) {
            return false;
        }
        return $this->registered[$handle]->add_data($key, $value);
    }
    public function get_data($handle, $key)
    {
        if (!isset($this->registered[$handle])) {
            return false;
        }
        if (!isset($this->registered[$handle]->extra[$key])) {
            return false;
        }
        return $this->registered[$handle]->extra[$key];
    }
    public function remove($handles)
    {
        foreach ((array) $handles as $handle) {
            unset($this->registered[$handle]);
        }
    }
    public function enqueue($handles)
    {
        foreach ((array) $handles as $handle) {
            $handle = explode('?', $handle);
            if (!in_array($handle[0], $this->queue) && isset($this->registered[$handle[0]])) {
                $this->queue[] = $handle[0];
                if (isset($handle[1])) {
                    $this->args[$handle[0]] = $handle[1];
                }
            }
        }
    }
    public function dequeue($handles)
    {
        foreach ((array) $handles as $handle) {
            $handle = explode('?', $handle);
            $key = array_search($handle[0], $this->queue);
            if (false !== $key) {
                unset($this->queue[$key]);
                unset($this->args[$handle[0]]);
            }
        }
    }
    protected function recurse_deps($queue, $handle)
    {
        foreach ($queue as $queued) {
            if (!isset($this->registered[$queued])) {
                continue;
            }
            if (in_array($handle, $this->registered[$queued]->deps)) {
                return true;
            } elseif ($this->recurse_deps($this->registered[$queued]->deps, $handle)) {
                return true;
            }
        }
        return false;
    }
    public function query($handle, $list = 'registered')
    {
        switch ($list) {
            case 'registered':
            case 'scripts':
                if (isset($this->registered[$handle])) {
                    return $this->registered[$handle];
                }
                return false;
            case 'enqueued':
            case 'queue':
                if (in_array($handle, $this->queue)) {
                    return true;
                }
                return $this->recurse_deps($this->queue, $handle);
            case 'to_do':
            case 'to_print':
                return in_array($handle, $this->to_do);
            case 'done':
            case 'printed':
                return in_array($handle, $this->done);
        }
        return false;
    }
    public function set_group($handle, $recursion, $group)
    {
        $group = (int) $group;
        if ($recursion) {
            $group = min($this->group, $group);
        } else {
            $this->group = $group;
        }
        if (isset($this->groups[$handle]) && $this->groups[$handle] <= $group) {
            return false;
        }
        $this->groups[$handle] = $group;
        return true;
    }
}
}

namespace Royalcms\Component\Script {
use RC_Hook;
class Style
{
    private static $instance = null;
    public function __construct()
    {
        self::instance();
    }
    public static function instance()
    {
        if (self::$instance === null) {
            self::$instance = new HandleStyles();
        }
        return self::$instance;
    }
    public static function print_styles($handles = false)
    {
        if ('' === $handles) {
            $handles = false;
        }
        if (!$handles) {
            RC_Hook::do_action('rc_print_styles');
        }
        if (!$handles) {
            return array();
        } else {
            return self::$instance->do_items($handles);
        }
    }
    public static function add_inline_style($handle, $data)
    {
        if (false !== stripos($data, '</style>')) {
            $data = trim(preg_replace('#<style[^>]*>(.*)</style>#is', '$1', $data));
        }
        return self::$instance->add_inline_style($handle, $data);
    }
    public static function register_style($handle, $src, $deps = array(), $ver = false, $media = 'all')
    {
        self::$instance->add($handle, $src, $deps, $ver, $media);
    }
    public static function deregister_style($handle)
    {
        self::$instance->remove($handle);
    }
    public static function enqueue_style($handle, $src = false, $deps = array(), $ver = false, $media = 'all')
    {
        if ($src) {
            $_handle = explode('?', $handle);
            self::$instance->add($_handle[0], $src, $deps, $ver, $media);
        }
        self::$instance->enqueue($handle);
    }
    public static function dequeue_style($handle)
    {
        self::$instance->dequeue($handle);
    }
    public static function style_is($handle, $list = 'enqueued')
    {
        return (bool) self::$instance->query($handle, $list);
    }
    public static function style_add_data($handle, $key, $value)
    {
        return self::$instance->add_data($handle, $key, $value);
    }
}
}

namespace Royalcms\Component\Script {
use RC_Hook;
use RC_Format;
use RC_Uri;
class HandleStyles extends Dependencies
{
    public $base_url;
    public $content_url;
    public $default_version;
    public $text_direction = 'ltr';
    public $concat = '';
    public $concat_version = '';
    public $do_concat = false;
    public $print_html = '';
    public $print_code = '';
    public $default_dirs;
    public function __construct()
    {
        RC_Hook::do_action_ref_array('rc_default_styles', array(&$this));
    }
    public function do_item($handle, $group = false)
    {
        if (!parent::do_item($handle)) {
            return false;
        }
        $obj = $this->registered[$handle];
        if (null === $obj->ver) {
            $ver = '';
        } else {
            $ver = $obj->ver ? $obj->ver : $this->default_version;
        }
        if (isset($this->args[$handle])) {
            $ver = $ver ? $ver . '&amp;' . $this->args[$handle] : $this->args[$handle];
        }
        if ($this->do_concat) {
            if ($this->in_default_dir($obj->src) && !isset($obj->extra['conditional']) && !isset($obj->extra['alt'])) {
                $this->concat .= "{$handle},";
                $this->concat_version .= "{$handle}{$ver}";
                $this->print_code .= $this->print_inline_style($handle, false);
                return true;
            }
        }
        if (isset($obj->args)) {
            $media = RC_Format::esc_attr($obj->args);
        } else {
            $media = 'all';
        }
        if (!$obj->src) {
            if ($inline_style = $this->print_inline_style($handle, false)) {
                $inline_style = sprintf("<style id='%s-inline-css' type='text/css'>\n%s\n</style>\n", RC_Format::esc_attr($handle), $inline_style);
                if ($this->do_concat) {
                    $this->print_html .= $inline_style;
                } else {
                    echo $inline_style;
                }
            }
            return true;
        }
        $href = $this->_css_href($obj->src, $ver, $handle);
        if (empty($href)) {
            return true;
        }
        $rel = isset($obj->extra['alt']) && $obj->extra['alt'] ? 'alternate stylesheet' : 'stylesheet';
        $title = isset($obj->extra['title']) ? "title='" . RC_Format::esc_attr($obj->extra['title']) . "'" : '';
        $tag = RC_Hook::apply_filters('style_loader_tag', "<link rel='{$rel}' id='{$handle}-css' {$title} href='{$href}' type='text/css' media='{$media}' />\n", $handle, $href, $media);
        if ('rtl' === $this->text_direction && isset($obj->extra['rtl']) && $obj->extra['rtl']) {
            if (is_bool($obj->extra['rtl']) || 'replace' === $obj->extra['rtl']) {
                $suffix = isset($obj->extra['suffix']) ? $obj->extra['suffix'] : '';
                $rtl_href = str_replace("{$suffix}.css", "-rtl{$suffix}.css", $this->_css_href($obj->src, $ver, "{$handle}-rtl"));
            } else {
                $rtl_href = $this->_css_href($obj->extra['rtl'], $ver, "{$handle}-rtl");
            }
            $rtl_tag = RC_Hook::apply_filters('style_loader_tag', "<link rel='{$rel}' id='{$handle}-rtl-css' {$title} href='{$rtl_href}' type='text/css' media='{$media}' />\n", $handle, $rtl_href, $media);
            if ($obj->extra['rtl'] === 'replace') {
                $tag = $rtl_tag;
            } else {
                $tag .= $rtl_tag;
            }
        }
        $conditional_pre = $conditional_post = '';
        if (isset($obj->extra['conditional']) && $obj->extra['conditional']) {
            $conditional_pre = "<!--[if {$obj->extra['conditional']}]>\n";
            $conditional_post = "<![endif]-->\n";
        }
        if ($this->do_concat) {
            $this->print_html .= $conditional_pre;
            $this->print_html .= $tag;
            $inline_style = $this->print_inline_style($handle, false);
            if ($inline_style) {
                $this->print_html .= sprintf("<style id='%s-inline-css' type='text/css'>\n%s\n</style>\n", RC_Format::esc_attr($handle), $inline_style);
            }
            $this->print_html .= $conditional_post;
        } else {
            echo $conditional_pre;
            echo $tag;
            $this->print_inline_style($handle);
            echo $conditional_post;
        }
        return true;
    }
    public function add_inline_style($handle, $code)
    {
        if (!$code) {
            return false;
        }
        $after = $this->get_data($handle, 'after');
        if (!$after) {
            $after = array();
        }
        $after[] = $code;
        return $this->add_data($handle, 'after', $after);
    }
    public function print_inline_style($handle, $echo = true)
    {
        $output = $this->get_data($handle, 'after');
        if (empty($output)) {
            return false;
        }
        $output = implode("\n", $output);
        if (!$echo) {
            return $output;
        }
        echo sprintf("<style id='%s-inline-css' type='text/css'>\n%s\n</style>\n", RC_Format::esc_attr($handle), $output);
        return true;
    }
    public function all_deps($handles, $recursion = false, $group = false)
    {
        $r = parent::all_deps($handles, $recursion);
        if (!$recursion) {
            $this->to_do = RC_Hook::apply_filters('print_styles_array', $this->to_do);
        }
        return $r;
    }
    public function _css_href($src, $ver, $handle)
    {
        if (!is_bool($src) && !preg_match('|^(https?:)?//|', $src) && !($this->content_url && 0 === strpos($src, $this->content_url))) {
            $src = $this->base_url . $src;
        }
        if (!empty($ver)) {
            $src = RC_Uri::add_query_arg('ver', $ver, $src);
        }
        $src = RC_Hook::apply_filters('style_loader_src', $src, $handle);
        $src = RC_Format::esc_url($src);
        return $src;
    }
    public function in_default_dir($src)
    {
        if (!$this->default_dirs) {
            return true;
        }
        foreach ((array) $this->default_dirs as $test) {
            if (0 === strpos($src, $test)) {
                return true;
            }
        }
        return false;
    }
    public function do_footer_items()
    {
        $this->do_items(false, 1);
        return $this->done;
    }
    public function reset()
    {
        $this->do_concat = false;
        $this->concat = '';
        $this->concat_version = '';
        $this->print_html = '';
    }
}
}

namespace Royalcms\Component\Script {
use Royalcms\Component\Support\ServiceProvider;
class ScriptServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->registerScripts();
        $this->registerStyles();
        $this->loadAlias();
    }
    protected function registerScripts()
    {
        $this->royalcms->bindShared('script', function ($royalcms) {
            return new HandleScripts();
        });
    }
    protected function registerStyles()
    {
        $this->royalcms->bindShared('style', function ($royalcms) {
            return new HandleStyles();
        });
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Script', 'Royalcms\\Component\\Script\\Script');
            $loader->alias('RC_Style', 'Royalcms\\Component\\Script\\Style');
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/script');
        return [$dir . '/Script.php', $dir . '/HandleScripts.php', $dir . '/Dependency.php', $dir . '/Dependencies.php', $dir . '/Style.php', $dir . '/HandleStyles.php', $dir . '/ScriptServiceProvider.php'];
    }
}
}

namespace Royalcms\Component\Timer {
class Timer
{
    protected $timers = array();
    public function __construct($startTime = null)
    {
        $this->start('royalcms', $startTime, 'Timer since ROYALCMS_START.');
    }
    public function start($name, $startTime = null, $description = null)
    {
        $start = $startTime ?: microtime(true);
        $this->timers[$name] = array('description' => $description, 'start' => $start, 'end' => null, 'time' => null, 'checkpoints' => array());
    }
    public function stop($name, $endTime = null, $decimals = 6)
    {
        $end = $endTime ?: microtime(true);
        $this->timers[$name] = $this->getTimer($name);
        $this->timers[$name]['end'] = $end;
        $this->timers[$name]['time'] = round(($end - $this->timers[$name]['start']) * 1000, $decimals);
        return $this->timers[$name];
    }
    public function checkpoint($name, $description = null, $decimals = 6)
    {
        $end = microtime(true);
        $this->timers[$name] = $this->getTimer($name);
        $count = count($this->timers[$name]['checkpoints']);
        $this->timers[$name]['checkpoints'][$count] = array('description' => $description, 'end' => $end);
        $this->timers[$name]['checkpoints'][$count]['timeFromStart'] = round($end - $this->timers[$name]['start'], $decimals);
        if ($count > 0) {
            $this->timers[$name]['checkpoints'][$count]['timeFromLastCheckpoint'] = round($end - $this->timers[$name]['checkpoints'][$count - 1]['end'], $decimals);
        }
    }
    public function getTimer($name)
    {
        if (!empty($this->timers[$name])) {
            return $this->timers[$name];
        }
        return array('description' => 'Timer since ROYALCMS_START.', 'start' => defined('ROYALCMS_START') ? ROYALCMS_START : microtime(true), 'end' => null, 'time' => null, 'checkpoints' => array());
    }
    public function getTimers()
    {
        $end = microtime(true);
        $decimals = 6;
        foreach ($this->timers as $name => $timer) {
            if ($this->timers[$name]['end'] == null) {
                $this->timers[$name]['end'] = $end;
                $this->timers[$name]['time'] = round($end - $this->timers[$name]['start'], $decimals);
            }
        }
        return $this->timers;
    }
    public function getLoadTime()
    {
        return $this->stop('royalcms');
    }
    public function formatTimer($timer)
    {
        return number_format($timer['time'] / 1000, 6);
    }
    public function dump($toFile = false)
    {
        if ($toFile) {
            $this->write();
        }
        return $this->getTimers();
    }
    public function write()
    {
        $json = $this->dump();
        $json = json_encode($json);
        $result = '';
        $pos = 0;
        $strLen = strlen($json);
        $indentStr = "\t";
        $newLine = "\n";
        $prevChar = '';
        $outOfQuotes = true;
        for ($i = 0; $i <= $strLen; $i++) {
            $char = substr($json, $i, 1);
            if ($char == '"' && $prevChar != '\\') {
                $outOfQuotes = !$outOfQuotes;
            } else {
                if (($char == '}' || $char == ']') && $outOfQuotes) {
                    $result .= $newLine;
                    $pos--;
                    for ($j = 0; $j < $pos; $j++) {
                        $result .= $indentStr;
                    }
                }
            }
            $result .= $char;
            if (($char == ',' || $char == '{' || $char == '[') && $outOfQuotes) {
                $result .= $newLine;
                if ($char == '{' || $char == '[') {
                    $pos++;
                }
                for ($j = 0; $j < $pos; $j++) {
                    $result .= $indentStr;
                }
            }
            $prevChar = $char;
        }
        \RC_Logger::getLogger('timer')->info($result);
    }
    public function clear()
    {
        $this->timers = array();
    }
}
}

namespace Royalcms\Component\Timer\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Timer extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'timer';
    }
}
}

namespace Royalcms\Component\Timer {
use Royalcms\Component\Support\ServiceProvider;
class TimerServiceProvider extends ServiceProvider
{
    protected $defer = false;
    public function register()
    {
        $this->royalcms->singleton('timer', function () {
            $startTime = defined('ROYALCMS_START') ? ROYALCMS_START : null;
            return new Timer($startTime);
        });
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Timer', 'Royalcms\\Component\\Timer\\Facades\\Timer');
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/timer');
        return [$dir . '/Timer.php', $dir . '/Facades/Timer.php', $dir . '/TimerServiceProvider.php'];
    }
}
}

namespace Royalcms\Component\SmartyView\Cache {
use Smarty;
use Royalcms\Component\Contracts\Config\Repository as ConfigContract;
class Storage
{
    protected $smarty;
    protected $repository;
    public function __construct(Smarty $smarty, ConfigContract $repository)
    {
        $this->smarty = $smarty;
        $this->repository = $repository;
    }
    public function cacheStorageManaged()
    {
        $driver = $this->repository->get('smarty-view::smarty.cache_driver', 'file');
        if ($driver !== 'file') {
            $storage = $driver . "Storage";
            $this->smarty->registerCacheResource($driver, $this->{$storage}());
        }
        $this->smarty->caching_type = $driver;
    }
    protected function redisStorage()
    {
        return new Redis($this->repository->get('smarty-view::smarty.redis'));
    }
    protected function memcachedStorage()
    {
        return new Memcached(new \Memcached(), $this->repository->get('smarty-view::smarty.memcached'));
    }
}
}

namespace Royalcms\Component\SmartyView\Console {
use Smarty;
use Royalcms\Component\Console\Command;
use Symfony\Component\Console\Input\InputOption;
class CacheClearCommand extends Command
{
    protected $smarty;
    public function __construct(Smarty $smarty)
    {
        parent::__construct();
        $this->smarty = $smarty;
    }
    protected $name = 'smarty:clear-cache';
    protected $description = 'Flush the Smarty cache';
    public function fire()
    {
        if (is_null($this->option('file'))) {
            $this->smarty->clearAllCache($this->option('time'));
            $this->info('Smarty cache cleared!');
            return;
        }
        if (!$this->smarty->clearCache($this->option('file'), $this->option('cache_id'), null, $this->option('time'))) {
            $this->error('specified file not be found');
            return;
        }
        $this->info('specified file was cache cleared!');
        return;
    }
    protected function getOptions()
    {
        return array(array('file', 'f', InputOption::VALUE_OPTIONAL, 'specify file'), array('time', 't', InputOption::VALUE_OPTIONAL, 'clear all of the files that are specified duration time'), array('cache_id', 'cache', InputOption::VALUE_OPTIONAL, 'specified cache_id groups'));
    }
}
}

namespace Royalcms\Component\SmartyView\Console {
use Smarty;
use Royalcms\Component\Console\Command;
use Symfony\Component\Console\Input\InputOption;
class ClearCompiledCommand extends Command
{
    protected $smarty;
    public function __construct(Smarty $smarty)
    {
        parent::__construct();
        $this->smarty = $smarty;
    }
    protected $name = 'smarty:clear-compiled';
    protected $description = 'Remove the compiled smarty file';
    public function fire()
    {
        $smartyExtension = $this->smarty->ext;
        $class = $smartyExtension->clearCompiledTemplate;
        if ($class->clearCompiledTemplate($this->smarty, $this->option('file'), $this->option('compile_id'))) {
            $this->info('done.');
            return;
        }
        return;
    }
    protected function getOptions()
    {
        return array(array('file', 'f', InputOption::VALUE_OPTIONAL, 'specify file'), array('compile_id', 'compile', InputOption::VALUE_OPTIONAL, 'specified compile_id'));
    }
}
}

namespace Royalcms\Component\SmartyView\Console {
use Smarty;
use Royalcms\Component\Console\Command;
use Symfony\Component\Console\Input\InputOption;
use Royalcms\Component\Config\Repository as ConfigContract;
class OptimizeCommand extends Command
{
    protected $smarty;
    protected $config;
    public function __construct(Smarty $smarty, ConfigContract $config)
    {
        parent::__construct();
        $this->smarty = $smarty;
        $this->config = $config;
    }
    protected $name = 'smarty:optimize';
    protected $description = 'compiles all known templates';
    public function fire()
    {
        $configureFileExtension = $this->config->get('smarty.extension', 'tpl');
        $fileExtension = is_null($this->option('extension')) ? $configureFileExtension : $this->option('extension');
        ob_start();
        $compileFiles = $this->smarty->compileAllTemplates($fileExtension, $this->forceCompile());
        $contents = ob_get_contents();
        ob_get_clean();
        $this->info("{$compileFiles} template files recompiled");
        $this->comment(str_replace("<br>", "\n", trim($contents)));
        return;
    }
    protected function getOptions()
    {
        return array(array('extension', 'e', InputOption::VALUE_OPTIONAL, 'specified smarty file extension'), array('force', null, InputOption::VALUE_NONE, 'compiles template files found in views directory'));
    }
    protected function forceCompile()
    {
        if ($this->option('force')) {
            return true;
        }
        return false;
    }
}
}

namespace Royalcms\Component\SmartyView {
use Smarty;
use ReflectionClass;
use Royalcms\Component\View\Factory;
use Royalcms\Component\View\ViewFinderInterface;
use Royalcms\Component\View\Engines\EngineResolver;
use Royalcms\Component\SmartyView\Cache\Storage;
use Royalcms\Component\SmartyView\Exception\MethodNotFoundException;
use Royalcms\Component\Contracts\Config\Repository as ConfigContract;
use Royalcms\Component\Events\Dispatcher as DispatcherContract;
class SmartyFactory extends Factory
{
    const VERSION = '3.1.18';
    protected $smarty;
    protected $config;
    protected $configKeys = array('auto_literal', 'error_unassigned', 'use_include_path', 'joined_template_dir', 'joined_config_dir', 'default_template_handler_func', 'default_config_handler_func', 'default_plugin_handler_func', 'force_compile', 'compile_check', 'use_sub_dirs', 'allow_ambiguous_resources', 'merge_compiled_includes', 'inheritance_merge_compiled_includes', 'force_cache', 'left_delimiter', 'right_delimiter', 'security_class', 'php_handling', 'allow_php_templates', 'direct_access_security', 'debugging', 'debugging_ctrl', 'smarty_debug_id', 'debug_tpl', 'get_used_tags', 'config_overwrite', 'config_booleanize', 'config_read_hidden', 'compile_locking', 'cache_locking', 'locking_timeout', 'default_resource_type', 'caching_type', 'properties', 'default_config_type', 'source_objects', 'template_objects', 'resource_caching', 'template_resource_caching', 'cache_modified_check', 'registered_plugins', 'plugin_search_order', 'registered_objects', 'registered_classes', 'registered_filters', 'registered_resources', '_resource_handlers', 'registered_cache_resources', '_cacheresource_handlers', 'autoload_filters', 'default_modifiers', 'escape_html', 'start_time', '_file_perms', '_dir_perms', '_tag_stack', '_current_file', '_parserdebug', '_is_file_cache', 'cache_id', 'compile_id', 'caching', 'cache_lifetime', 'template_class', 'tpl_vars', 'parent', 'config_vars');
    protected $securityPolicyConfigKeys = array('php_handling', 'secure_dir', 'trusted_dir', 'trusted_uri', 'trusted_constants', 'static_classes', 'trusted_static_methods', 'trusted_static_properties', 'php_functions', 'php_modifiers', 'allowed_tags', 'disabled_tags', 'allowed_modifiers', 'disabled_modifiers', 'disabled_special_smarty_vars', 'streams', 'allow_constants', 'allow_super_globals', 'max_template_nesting');
    public function __construct(EngineResolver $engines, ViewFinderInterface $finder, DispatcherContract $events, Smarty $smarty, ConfigContract $config)
    {
        parent::__construct($engines, $finder, $events);
        $this->smarty = $smarty;
        $this->config = $config;
    }
    public function getSmarty()
    {
        return $this->smarty;
    }
    public function getVersion()
    {
        return self::VERSION;
    }
    public function resolveSmartyCache()
    {
        $cacheStorage = new Storage($this->getSmarty(), $this->config);
        $cacheStorage->cacheStorageManaged();
    }
    public function setSmartyConfigure()
    {
        $config = $this->config->get('smarty-view::smarty');
        $smarty = $this->smarty;
        $smarty->setTemplateDir(array_get($config, 'template_path'));
        $smarty->setCompileDir(array_get($config, 'compile_path'));
        $smarty->setCacheDir(array_get($config, 'cache_path'));
        $smarty->setConfigDir(array_get($config, 'config_paths'));
        foreach (array_get($config, 'plugins_paths', array()) as $plugins) {
            $smarty->addPluginsDir($plugins);
        }
        $smarty->error_reporting = array_get($config, 'error_reporting', E_ALL & ~E_NOTICE & ~E_WARNING);
        foreach ($config as $key => $value) {
            if (in_array($key, $this->configKeys)) {
                $this->smarty->{$key} = $value;
            }
        }
        if (array_get($config, 'enable_security')) {
            $smarty->enableSecurity();
            $securityPolicy = $smarty->security_policy;
            $securityConfig = array_get($config, 'security_policy', array());
            foreach ($securityConfig as $key => $value) {
                if (in_array($key, $this->securityPolicyConfigKeys)) {
                    $securityPolicy->{$key} = $value;
                }
            }
        }
    }
    public function __call($name, $arguments)
    {
        $reflectionClass = new ReflectionClass($this->smarty);
        if (!$reflectionClass->hasMethod($name)) {
            throw new MethodNotFoundException("{$name} : Method Not Found");
        }
        return call_user_func_array(array($this->smarty, $name), $arguments);
    }
}
}

namespace Royalcms\Component\SmartyView {
use Royalcms\Component\View\FileViewFinder as ViewFileViewFinder;
class FileViewFinder extends ViewFileViewFinder
{
    protected $extensions = array('php');
    public function find($name)
    {
        if (isset($this->views[$name])) {
            return $this->views[$name];
        }
        if (strpos($name, '::') !== false) {
            return $this->views[$name] = $this->findNamespacedView($name);
        }
        return $this->views[$name] = $this->findInPaths($name, $this->paths);
    }
    protected function findInPaths($name, $paths)
    {
        foreach ((array) $paths as $path) {
            foreach ($this->getPossibleViewFiles($name) as $file) {
                $viewPath = $path . '/' . $file;
                if ($this->files->exists($viewPath)) {
                    return $viewPath;
                }
            }
        }
        throw new \InvalidArgumentException("View [{$name}] not found.");
    }
    protected function getPossibleViewFiles($name)
    {
        return array_map(function ($extension) use($name) {
            return $name . '.' . $extension;
        }, $this->extensions);
    }
    public function flush()
    {
        parent::flush();
    }
    public function replaceNamespace($namespace, $hints)
    {
        parent::replaceNamespace($namespace, $hints);
    }
}
}

namespace Royalcms\Component\SmartyView\Engines {
use Smarty;
use Royalcms\Component\Contracts\View\Engine;
class SmartyEngine implements Engine
{
    protected $smarty;
    public function __construct(Smarty $smarty)
    {
        $this->smarty = $smarty;
    }
    public function get($path, array $data = array())
    {
        return $this->evaluatePath($path, $data);
    }
    protected function evaluatePath($path, array $data = array())
    {
        ob_start();
        try {
            if (!$this->smarty->isCached($path)) {
                foreach ($data as $var => $val) {
                    $this->smarty->assign($var, $val);
                }
            }
            $cacheId = isset($data['smarty.cache_id']) ? $data['smarty.cache_id'] : null;
            $compileId = isset($data['smarty.compile_id']) ? $data['smarty.compile_id'] : null;
            $this->smarty->display($path, $cacheId, $compileId);
        } catch (\Exception $e) {
            $this->handleViewException($e);
        }
        return ob_get_clean();
    }
    protected function handleViewException(\Exception $e)
    {
        ob_get_clean();
        throw $e;
    }
}
}

namespace Royalcms\Component\SmartyView {
use Smarty;
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\View\Engines\EngineResolver;
use Royalcms\Component\SmartyView\Engines\SmartyEngine;
class SmartyServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $extensions = $this->royalcms['config']->get('smarty-view::smarty.extensions', array('tpl'));
        foreach ($extensions as $extension) {
            $this->royalcms['view']->addExtension($extension, 'smarty');
        }
    }
    public function register()
    {
        $this->package('royalcms/smarty-view');
        $this->registerEngineResolver();
        $this->registerViewFinder();
        $this->registerFactory();
    }
    public function registerEngineResolver()
    {
        $me = $this;
        $this->royalcms->singleton('view.engine.resolver', function ($royalcms) use($me) {
            $resolver = new EngineResolver();
            $me->registerSmartyEngine($resolver);
            return $resolver;
        });
    }
    public function registerSmartyEngine($resolver)
    {
        $royalcms = $this->royalcms;
        $resolver->register('smarty', function () use($royalcms) {
            $smarty = $royalcms->make('view');
            return new SmartyEngine($smarty->getSmarty());
        });
    }
    public function registerViewFinder()
    {
        $this->royalcms->bindShared('view.finder', function ($royalcms) {
            $path = $royalcms['config']['smarty-view::smarty.template_path'];
            return new FileViewFinder($royalcms['files'], array($path));
        });
    }
    public function registerFactory()
    {
        require_once $this->royalcms['path.vendor'] . '/smarty/smarty/Smarty.class.php';
        $this->royalcms->singleton('view', function ($royalcms) {
            $factory = new SmartyFactory($royalcms['view.engine.resolver'], $royalcms['view.finder'], $royalcms['events'], new Smarty(), $royalcms['config']);
            $factory->setContainer($royalcms);
            $factory->share('royalcms', $royalcms);
            $factory->resolveSmartyCache();
            $factory->setSmartyConfigure();
            return $factory;
        });
    }
    public function provides()
    {
        return array('smarty', 'view', 'view.finder');
    }
}
}

namespace Royalcms\Component\SmartyView {
use Royalcms\Component\Support\ServiceProvider;
class SmartyConsoleServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function boot()
    {
        $this->registerCommands();
    }
    public function register()
    {
    }
    public function provides()
    {
        return ['command.smarty.clear.compiled', 'command.smarty.clear.cache', 'command.smarty.optimize', 'command.smarty.info'];
    }
    protected function registerCommands()
    {
        $this->royalcms->singleton('command.smarty.info', function () {
            return new Console\PackageInfoCommand();
        });
        $this->royalcms->singleton('command.smarty.clear.cache', function ($royalcms) {
            return new Console\CacheClearCommand($royalcms['smarty.view']->getSmarty());
        });
        $this->royalcms->singleton('command.smarty.clear.compiled', function ($royalcms) {
            return new Console\ClearCompiledCommand($royalcms['smarty.view']->getSmarty());
        });
        $this->royalcms->singleton('command.smarty.optimize', function ($royalcms) {
            return new Console\OptimizeCommand($royalcms['smarty.view']->getSmarty(), $royalcms['config']);
        });
        $this->commands(['command.smarty.clear.compiled', 'command.smarty.clear.cache', 'command.smarty.optimize', 'command.smarty.info']);
    }
}
}

namespace Royalcms\Component\Rewrite\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Rewrite extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'rewrite';
    }
}
}

namespace Royalcms\Component\Rewrite {
use RC_Hook;
use Royalcms\Component\Foundation\Uri;
class RewriteQuery
{
    protected $rc_rewrite;
    public $public_query_vars = array('m', 'c', 'a', 'data', 'lang', 'page');
    public $private_query_vars = array();
    public $extra_query_vars = array();
    public $query_vars;
    public $query_string;
    public $request;
    public $matched_rule;
    public $matched_query;
    public $did_permalink = false;
    public function __construct()
    {
        $this->rc_rewrite = new Rewrite();
    }
    public function instance()
    {
        return $this->rc_rewrite;
    }
    public function add_rewrite_rule($regex, $query, $after = 'bottom')
    {
        $this->rc_rewrite->add_rule($regex, $query, $after);
    }
    public function add_rewrite_tag($tag, $regex, $query = '')
    {
        if (strlen($tag) < 3 || $tag[0] != '%' || $tag[strlen($tag) - 1] != '%') {
            return;
        }
        if (empty($query)) {
            $qv = trim($tag, '%');
            $this->add_query_var($qv);
            $query = $qv . '=';
        }
        $this->rc_rewrite->add_rewrite_tag($tag, $regex, $query);
    }
    public function add_permastruct($name, $struct, $args = array())
    {
        if (!is_array($args)) {
            $args = array('with_front' => $args);
        }
        if (func_num_args() == 4) {
            $args['ep_mask'] = func_get_arg(3);
        }
        $this->rc_rewrite->add_permastruct($name, $struct, $args);
    }
    public function flush_rewrite_rules($hard = true)
    {
        $this->rc_rewrite->flush_rules($hard);
    }
    public function add_rewrite_endpoint($name, $places, $query_var = true)
    {
        $this->rc_rewrite->add_endpoint($name, $places, $query_var);
    }
    public function parse_request($extra_query_vars = '')
    {
        if (!RC_Hook::apply_filters('do_parse_request', true, $this, $extra_query_vars)) {
            return;
        }
        $this->query_vars = array();
        if (is_array($extra_query_vars)) {
            $this->extra_query_vars =& $extra_query_vars;
        } elseif (!empty($extra_query_vars)) {
            parse_str($extra_query_vars, $this->extra_query_vars);
        }
        $rewrite = $this->rc_rewrite->rc_rewrite_rules();
        if (!empty($rewrite)) {
            $error = '404';
            $this->did_permalink = true;
            $pathinfo = isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : '';
            list($pathinfo) = explode('?', $pathinfo);
            $pathinfo = str_replace("%", "%25", $pathinfo);
            if (strpos($_SERVER['REQUEST_URI'], '?')) {
                list($req_uri, $req_str) = explode('?', $_SERVER['REQUEST_URI']);
            } else {
                list($req_uri) = explode('?', $_SERVER['REQUEST_URI']);
                $req_str = '';
            }
            $self = $_SERVER['PHP_SELF'];
            $home_path = trim(parse_url(Uri::home_url(), PHP_URL_PATH), '/');
            $home_path_regex = sprintf('|^%s|i', preg_quote($home_path, '|'));
            $req_uri = str_replace($pathinfo, '', $req_uri);
            $req_uri = trim($req_uri, '/');
            $req_uri = preg_replace($home_path_regex, '', $req_uri);
            $req_uri = trim($req_uri, '/');
            $pathinfo = trim($pathinfo, '/');
            $pathinfo = preg_replace($home_path_regex, '', $pathinfo);
            $pathinfo = trim($pathinfo, '/');
            $self = trim($self, '/');
            $self = preg_replace($home_path_regex, '', $self);
            $self = trim($self, '/');
            if (!empty($pathinfo) && !preg_match('|^.*' . $this->rc_rewrite->index . '$|', $pathinfo)) {
                $request = $pathinfo;
            } else {
                if ($req_uri == $this->rc_rewrite->index) {
                    $req_uri = '';
                }
                $request = $req_uri;
            }
            $this->request = $request;
            $req_str = RC_Hook::apply_filters('rewrite_parse_query_string', $req_str);
            $request_match = $request . '?' . $req_str;
            if (empty($request_match)) {
                if (isset($rewrite['$'])) {
                    $this->matched_rule = '$';
                    $query = $rewrite['$'];
                    $matches = array('');
                }
            } else {
                foreach ((array) $rewrite as $match => $query) {
                    if (!empty($req_uri) && strpos($match, $req_uri) === 0 && $req_uri != $request) {
                        $request_match = $req_uri . '/' . $request;
                    }
                    if (preg_match("#^{$match}#", $request_match, $matches) || preg_match("#^{$match}#", urldecode($request_match), $matches)) {
                        $this->matched_rule = $match;
                        break;
                    }
                }
            }
            if (isset($this->matched_rule)) {
                $query = preg_replace('!^.+\\?!', '', $query);
                $query = addslashes(MatchesMapRegex::apply($query, $matches));
                $this->matched_query = $query;
                parse_str($query, $perma_query_vars);
                if ('404' == $error) {
                    unset($error, $_GET['error']);
                }
            }
            if (empty($request) || $req_uri == $self) {
                unset($error, $_GET['error']);
                $this->did_permalink = false;
            }
        }
        $this->public_query_vars = RC_Hook::apply_filters('query_vars', $this->public_query_vars);
        foreach ($this->public_query_vars as $rcvar) {
            if (isset($this->extra_query_vars[$rcvar])) {
                $this->query_vars[$rcvar] = $this->extra_query_vars[$rcvar];
            } elseif (isset($_POST[$rcvar])) {
                $this->query_vars[$rcvar] = $_POST[$rcvar];
            } elseif (isset($_GET[$rcvar])) {
                $this->query_vars[$rcvar] = $_GET[$rcvar];
            } elseif (isset($perma_query_vars[$rcvar])) {
                $this->query_vars[$rcvar] = $perma_query_vars[$rcvar];
            }
            if (!empty($this->query_vars[$rcvar])) {
                if (!is_array($this->query_vars[$rcvar])) {
                    $this->query_vars[$rcvar] = (string) $this->query_vars[$rcvar];
                } else {
                    foreach ($this->query_vars[$rcvar] as $vkey => $v) {
                        if (!is_object($v)) {
                            $this->query_vars[$rcvar][$vkey] = (string) $v;
                        }
                    }
                }
            }
        }
        foreach ((array) $this->private_query_vars as $var) {
            if (isset($this->extra_query_vars[$var])) {
                $this->query_vars[$var] = $this->extra_query_vars[$var];
            }
        }
        if (isset($error)) {
            $this->query_vars['error'] = $error;
        }
        $this->query_vars = RC_Hook::apply_filters('request', $this->query_vars);
        RC_Hook::do_action_ref_array('parse_request', array(&$this));
    }
    public function add_query_var($qv)
    {
        if (!in_array($qv, $this->public_query_vars)) {
            $this->public_query_vars[] = $qv;
        }
    }
    public function add_query_vars($qvs)
    {
        foreach ($qvs as $key) {
            $this->add_query_var($key);
        }
    }
    public function set_query_var($key, $value)
    {
        $this->query_vars[$key] = $value;
    }
    public function get_query_var()
    {
        return $this->query_vars;
    }
    public function build_query_string()
    {
        $this->query_string = '';
        foreach ((array) array_keys($this->query_vars) as $wpvar) {
            if ('' != $this->query_vars[$wpvar]) {
                $this->query_string .= strlen($this->query_string) < 1 ? '' : '&';
                if (!is_scalar($this->query_vars[$wpvar])) {
                    continue;
                }
                $this->query_string .= $wpvar . '=' . rawurlencode($this->query_vars[$wpvar]);
            }
        }
        if (RC_Hook::has_filter('query_string')) {
            $this->query_string = RC_Hook::apply_filters('query_string', $this->query_string);
            parse_str($this->query_string, $this->query_vars);
        }
    }
}
}

namespace Royalcms\Component\Rewrite {
define('EP_NONE', 0);
define('EP_PERMALINK', 1);
define('EP_ROOT', 64);
class Rewrite
{
    public $permalink_structure;
    public $use_trailing_slashes;
    public $front;
    public $root = '';
    public $index = 'index.php';
    var $matches = '';
    var $rules;
    var $extra_rules = array();
    var $extra_rules_top = array();
    var $non_rc_rules = array();
    var $extra_permastructs = array();
    var $endpoints;
    public $use_verbose_rules = false;
    var $queryreplace = array();
    var $rewritecode = array();
    var $rewritereplace = array();
    public function __construct()
    {
        $this->init();
    }
    public function init()
    {
        $this->extra_rules = $this->non_wp_rules = $this->endpoints = array();
        $this->front = substr($this->permalink_structure, 0, strpos($this->permalink_structure, '%'));
        $this->root = '';
        if ($this->using_index_permalinks()) {
            $this->root = $this->index . '/';
        }
        $this->use_trailing_slashes = '/' == substr($this->permalink_structure, -1, 1);
    }
    public function set_permalink_structure($permalink_structure)
    {
        if ($permalink_structure != $this->permalink_structure) {
            $old_permalink_structure = $this->permalink_structure;
            $this->permalink_structure = $permalink_structure;
            $this->init();
            \RC_Hook::do_action('permalink_structure_changed', $old_permalink_structure, $permalink_structure);
        }
    }
    public function using_permalinks()
    {
        return !empty($this->permalink_structure);
    }
    public function using_index_permalinks()
    {
        if (empty($this->permalink_structure)) {
            return false;
        }
        return preg_match('#^/*' . $this->index . '#', $this->permalink_structure);
    }
    public function using_mod_rewrite_permalinks()
    {
        return $this->using_permalinks() && !$this->using_index_permalinks();
    }
    public function preg_index($number)
    {
        $match_prefix = '$';
        $match_suffix = '';
        if (!empty($this->matches)) {
            $match_prefix = '$' . $this->matches . '[';
            $match_suffix = ']';
        }
        return "{$match_prefix}{$number}{$match_suffix}";
    }
    public function add_rewrite_tag($tag, $regex, $query)
    {
        $position = array_search($tag, $this->rewritecode);
        if (false !== $position && null !== $position) {
            $this->rewritereplace[$position] = $regex;
            $this->queryreplace[$position] = $query;
        } else {
            $this->rewritecode[] = $tag;
            $this->rewritereplace[] = $regex;
            $this->queryreplace[] = $query;
        }
    }
    public function generate_rewrite_rules($permalink_structure, $ep_mask = EP_NONE, $walk_dirs = true, $endpoints = true)
    {
        if ($endpoints) {
            $ep_query_append = array();
            foreach ((array) $this->endpoints as $endpoint) {
                $epmatch = $endpoint[1] . '(/(.*))?/?$';
                $epquery = '&' . $endpoint[2] . '=';
                $ep_query_append[$epmatch] = array($endpoint[0], $epquery);
            }
        }
        $front = substr($permalink_structure, 0, strpos($permalink_structure, '%'));
        preg_match_all('/%.+?%/', $permalink_structure, $tokens);
        $num_tokens = count($tokens[0]);
        $index = $this->index;
        $queries = array();
        for ($i = 0; $i < $num_tokens; ++$i) {
            if (0 < $i) {
                $queries[$i] = $queries[$i - 1] . '&';
            } else {
                $queries[$i] = '';
            }
            $query_token = str_replace($this->rewritecode, $this->queryreplace, $tokens[0][$i]) . $this->preg_index($i + 1);
            $queries[$i] .= $query_token;
        }
        $structure = $permalink_structure;
        if ($front != '/') {
            $structure = str_replace($front, '', $structure);
        }
        $structure = trim($structure, '/');
        $dirs = $walk_dirs ? explode('/', $structure) : array($structure);
        $num_dirs = count($dirs);
        $front = preg_replace('|^/+|', '', $front);
        $struct = $front;
        for ($j = 0; $j < $num_dirs; ++$j) {
            $struct .= $dirs[$j] . '/';
            $struct = ltrim($struct, '/');
            $match = str_replace($this->rewritecode, $this->rewritereplace, $struct);
            $num_toks = preg_match_all('/%.+?%/', $struct, $toks);
            $query = !empty($num_toks) && isset($queries[$num_toks - 1]) ? $queries[$num_toks - 1] : '';
            $ep_mask_specific = EP_NONE;
            $rewrite = array();
            if ($endpoints) {
                foreach ((array) $ep_query_append as $regex => $ep) {
                    if ($ep[0] & $ep_mask || $ep[0] & $ep_mask_specific) {
                        $rewrite[$match . $regex] = $index . '?' . $query . $ep[1] . $this->preg_index($num_toks + 2);
                    }
                }
            }
            if ($num_toks) {
                $match .= '?$';
                $query = $index . '?' . $query;
                $rewrite = array_merge($rewrite, array($match => $query));
            }
        }
        return $rewrite;
    }
    public function generate_rewrite_rule($permalink_structure, $walk_dirs = false)
    {
        return $this->generate_rewrite_rules($permalink_structure, EP_NONE, false, false, false, $walk_dirs);
    }
    public function rewrite_rules()
    {
        $rewrite = array();
        if (empty($this->permalink_structure)) {
            return $rewrite;
        }
        $home_path = parse_url(\RC_Uri::home_url());
        $robots_rewrite = empty($home_path['path']) || '/' == $home_path['path'] ? array('robots\\.txt$' => $this->index . '?robots=1') : array();
        $deprecated_files = array();
        $root_rewrite = $this->generate_rewrite_rules($this->root . '/', EP_ROOT);
        $root_rewrite = \RC_Hook::apply_filters('root_rewrite_rules', $root_rewrite);
        foreach ($this->extra_permastructs as $permastructname => $struct) {
            if (is_array($struct)) {
                if (count($struct) == 2) {
                    $rules = $this->generate_rewrite_rules($struct[0], $struct[1]);
                } else {
                    $rules = $this->generate_rewrite_rules($struct['struct'], $struct['ep_mask'], $struct['paged'], $struct['feed'], $struct['forcomments'], $struct['walk_dirs'], $struct['endpoints']);
                }
            } else {
                $rules = $this->generate_rewrite_rules($struct);
            }
            $rules = \RC_Hook::apply_filters($permastructname . '_rewrite_rules', $rules);
            $this->extra_rules_top = array_merge($this->extra_rules_top, $rules);
        }
        $this->rules = array_merge($this->extra_rules_top, $robots_rewrite, $deprecated_files, $root_rewrite, $this->extra_rules);
        \RC_Hook::do_action_ref_array('generate_rewrite_rules', array(&$this));
        $this->rules = \RC_Hook::apply_filters('rewrite_rules_array', $this->rules);
        return $this->rules;
    }
    public function rc_rewrite_rules()
    {
        $this->rules = \RC_Variable::get('rewrite_rules');
        if (empty($this->rules)) {
            $this->matches = 'matches';
            $this->rewrite_rules();
            \RC_Variable::set('rewrite_rules', $this->rules);
        }
        return $this->rules;
    }
    public function mod_rewrite_rules()
    {
        if (!$this->using_permalinks()) {
            return '';
        }
        $site_root = parse_url(\RC_Uri::site_url());
        if (isset($site_root['path'])) {
            $site_root = \RC_Format::trailingslashit($site_root['path']);
        }
        $home_root = parse_url(\RC_Uri::home_url());
        if (isset($home_root['path'])) {
            $home_root = \RC_Format::trailingslashit($home_root['path']);
        } else {
            $home_root = '/';
        }
        $rules = "<IfModule mod_rewrite.c>\n";
        $rules .= "RewriteEngine On\n";
        $rules .= "RewriteBase {$home_root}\n";
        $rules .= "RewriteRule ^index\\.php\$ - [L]\n";
        foreach ((array) $this->non_rc_rules as $match => $query) {
            $match = str_replace('.+?', '.+', $match);
            $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";
        }
        if ($this->use_verbose_rules) {
            $this->matches = '';
            $rewrite = $this->rewrite_rules();
            $num_rules = count($rewrite);
            $rules .= "RewriteCond %{REQUEST_FILENAME} -f [OR]\n" . "RewriteCond %{REQUEST_FILENAME} -d\n" . "RewriteRule ^.*\$ - [S={$num_rules}]\n";
            foreach ((array) $rewrite as $match => $query) {
                $match = str_replace('.+?', '.+', $match);
                if (strpos($query, $this->index) !== false) {
                    $rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";
                } else {
                    $rules .= 'RewriteRule ^' . $match . ' ' . $site_root . $query . " [QSA,L]\n";
                }
            }
        } else {
            $rules .= "RewriteCond %{REQUEST_FILENAME} !-f\n" . "RewriteCond %{REQUEST_FILENAME} !-d\n" . "RewriteRule . {$home_root}{$this->index} [L]\n";
        }
        $rules .= "</IfModule>\n";
        $rules = \RC_Hook::apply_filters('mod_rewrite_rules', $rules);
        return \RC_Hook::apply_filters('rewrite_rules', $rules);
    }
    public function iis7_url_rewrite_rules($add_parent_tags = false)
    {
        if (!$this->using_permalinks()) {
            return '';
        }
        $rules = '';
        if ($add_parent_tags) {
            $rules .= '<configuration>
	<system.webServer>
		<rewrite>
			<rules>';
        }
        $rules .= '
			<rule name="Royalcms" patternSyntax="Wildcard">
				<match url="*" />
					<conditions>
						<add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
						<add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
					</conditions>
				<action type="Rewrite" url="index.php" />
			</rule>';
        if ($add_parent_tags) {
            $rules .= '
			</rules>
		</rewrite>
	</system.webServer>
</configuration>';
        }
        return \RC_Hook::apply_filters('iis7_url_rewrite_rules', $rules);
    }
    public function add_rule($regex, $query, $after = 'bottom')
    {
        if (is_array($query)) {
            $external = false;
            $query = \RC_Uri::add_query_arg($query, 'index.php');
        } else {
            $index = false === strpos($query, '?') ? strlen($query) : strpos($query, '?');
            $front = substr($query, 0, $index);
            $external = $front != $this->index;
        }
        if ($external) {
            $this->add_external_rule($regex, $query);
        } else {
            if ('bottom' == $after) {
                $this->extra_rules = array_merge($this->extra_rules, array($regex => $query));
            } else {
                $this->extra_rules_top = array_merge($this->extra_rules_top, array($regex => $query));
            }
        }
    }
    public function add_external_rule($regex, $query)
    {
        $this->non_rc_rules[$regex] = $query;
    }
    public function add_endpoint($name, $places, $query_var = true)
    {
        global $wp;
        if (true === $query_var || null === func_get_arg(2)) {
            $query_var = $name;
        }
        $this->endpoints[] = array($places, $name, $query_var);
        if ($query_var) {
            $wp->add_query_var($query_var);
        }
    }
    public function add_permastruct($name, $struct, $args = array())
    {
        if (!is_array($args)) {
            $args = array('with_front' => $args);
        }
        if (func_num_args() == 4) {
            $args['ep_mask'] = func_get_arg(3);
        }
        $defaults = array('with_front' => true, 'ep_mask' => EP_NONE, 'paged' => true, 'feed' => true, 'forcomments' => false, 'walk_dirs' => true, 'endpoints' => true);
        $args = array_intersect_key($args, $defaults);
        $args = rc_parse_args($args, $defaults);
        if ($args['with_front']) {
            $struct = $this->front . $struct;
        } else {
            $struct = $this->root . $struct;
        }
        $args['struct'] = $struct;
        $this->extra_permastructs[$name] = $args;
    }
    public function flush_rules($hard = true)
    {
        static $do_hard_later = null;
        if (!\RC_Hook::did_action('rc_loaded')) {
            \RC_Hook::add_action('rc_loaded', array($this, 'flush_rules'));
            $do_hard_later = isset($do_hard_later) ? $do_hard_later || $hard : $hard;
            return;
        }
        if (isset($do_hard_later)) {
            $hard = $do_hard_later;
            unset($do_hard_later);
        }
        \RC_Variable::delete('rewrite_rules');
        $this->rc_rewrite_rules();
        if (!$hard || !\RC_Hook::apply_filters('flush_rewrite_rules_hard', true)) {
            return;
        }
        if (function_exists('save_mod_rewrite_rules')) {
            save_mod_rewrite_rules();
        }
        if (function_exists('iis7_save_url_rewrite_rules')) {
            iis7_save_url_rewrite_rules();
        }
    }
}
}

namespace Royalcms\Component\Rewrite {
class MatchesMapRegex
{
    private $_matches;
    public $output;
    private $_subject;
    public $_pattern = '(\\$matches\\[[1-9]+[0-9]*\\])';
    public function __construct($subject, $matches)
    {
        $this->_subject = $subject;
        $this->_matches = $matches;
        $this->output = $this->_map();
    }
    public static function apply($subject, $matches)
    {
        $oSelf = new self($subject, $matches);
        return $oSelf->output;
    }
    private function _map()
    {
        $callback = array($this, 'callback');
        return preg_replace_callback($this->_pattern, $callback, $this->_subject);
    }
    public function callback($matches)
    {
        $index = intval(substr($matches[0], 9, -1));
        return isset($this->_matches[$index]) ? urlencode($this->_matches[$index]) : '';
    }
}
}

namespace Royalcms\Component\Rewrite {
use Royalcms\Component\Support\ServiceProvider;
class RewriteServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->bindShared('rewrite', function ($royalcms) {
            return new RewriteQuery();
        });
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Rewrite', 'Royalcms\\Component\\Rewrite\\Facades\\Rewrite');
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/rewrite');
        return [$dir . "/Facades/Rewrite.php", $dir . "/RewriteQuery.php", $dir . "/Rewrite.php", $dir . "/MatchesMapRegex.php", $dir . "/RewriteServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Error {
class Error
{
    private $errors = array();
    private $error_data = array();
    public function __construct($code = '', $message = '', $data = '')
    {
        if (!empty($code)) {
            $this->errors[$code][] = $message;
            if (!empty($data)) {
                $this->error_data[$code] = $data;
            }
        }
    }
    public function get_error_codes()
    {
        if (empty($this->errors)) {
            return array();
        }
        return array_keys($this->errors);
    }
    public function get_error_code()
    {
        $codes = $this->get_error_codes();
        if (empty($codes)) {
            return '';
        }
        return $codes[0];
    }
    public function get_error_messages($code = '')
    {
        if (empty($code)) {
            $all_messages = array();
            foreach ((array) $this->errors as $code => $messages) {
                $all_messages = array_merge($all_messages, $messages);
            }
            return $all_messages;
        }
        if (isset($this->errors[$code])) {
            return $this->errors[$code];
        } else {
            return array();
        }
    }
    public function get_error_message($code = '')
    {
        if (empty($code)) {
            $code = $this->get_error_code();
        }
        $messages = $this->get_error_messages($code);
        if (empty($messages)) {
            return '';
        }
        return $messages[0];
    }
    public function get_error_data($code = '')
    {
        if (empty($code)) {
            $code = $this->get_error_code();
        }
        if (isset($this->error_data[$code])) {
            return $this->error_data[$code];
        }
        return null;
    }
    public function add($code, $message, $data = '')
    {
        $this->errors[$code][] = $message;
        if (!empty($data)) {
            $this->error_data[$code] = $data;
        }
    }
    public function add_data($data, $code = '')
    {
        if (empty($code)) {
            $code = $this->get_error_code();
        }
        $this->error_data[$code] = $data;
    }
    public static function is_error($thing)
    {
        if (is_object($thing) && is_a($thing, '\\Royalcms\\Component\\Error\\Error')) {
            return true;
        }
        return false;
    }
}
}

namespace Royalcms\Component\Error {
class ErrorDisplay
{
    public static function http_error($code, $msg = '')
    {
        _http_status($code);
        if ($code == '404') {
            echo self::error_display('404', 'Not Found', 'You can see this page because the URL you are accessing cannot be
			found.');
        } elseif ($code == '500') {
            echo self::error_display('500', 'Internal Server Error', 'Something has gone horribly wrong.');
        } else {
            echo self::error_display($code, '', $msg);
        }
        exit(0);
    }
    public static function error_display($code, $msg, $desc)
    {
        return <<<ERR
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>{$code} - {$msg}</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    </head>
    <style media="screen">
        body{background-color:#38a7dc;color:#fff;font:100% "Lato",sans-serif;font-size:1.8rem;font-weight:300}a{color:#75c6d9;text-decoration:none}.center{text-align:center}.header{font-size:13rem;font-weight:700;margin:13% 0 0 0;text-shadow:0 3px 0 #7f8c8d}.error{margin:-1rem 0 -0.5rem 0;font-size:6rem;text-shadow:0 3px 0 #7f8c8d;font-weight:100}@media(max-width:800px){html{font-size:60%}}@media(max-width:580px){html{font-size:40%}.header{margin-top:45%}}
    </style>
    <body>
        <section class="center">
            <article>
                <h1 class="header">{$code}</h1>
                <p class="error">{$msg}</p>
            </article>
            <article>
                <p>{$desc}</p>
            </article>
        </section>
    </body>
</html>    
ERR;
    }
    public static function halt($msg)
    {
        rc_die($msg);
    }
}
}

namespace Royalcms\Component\Error {
use Royalcms\Component\Support\ServiceProvider;
class ErrorServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->royalcms->bindShared('error', function ($royalcms) {
            return new Error();
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/error');
        return [$dir . '/Error.php', $dir . '/ErrorDisplay.php', $dir . '/ErrorServiceProvider.php', $dir . '/Facades/Error.php'];
    }
}
}

namespace Royalcms\Component\Error\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Error extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'error';
    }
    public static function make($code = '', $message = '', $data = '')
    {
        return new \Royalcms\Component\Error\Error($code, $message, $data);
    }
    public static function is_error($thing)
    {
        if (is_object($thing) && is_a($thing, '\\Royalcms\\Component\\Error\\Error')) {
            return true;
        }
        return false;
    }
}
}

namespace Royalcms\Component\DefaultRoute {
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
trait DefaultRouteTrait
{
    protected $defaultAction = 'init';
    protected $originalAction;
    protected $originalController;
    public function runAction($action = null)
    {
        $request = royalcms('request');
        $method = $this->resolveActionInCertainController($request, get_class($this), $action);
        list($class, $method) = explode('@', $method);
        $dispatcher = royalcms('royalcms.route.dispatcher');
        $route = royalcms('router')->getCurrentRoute();
        return $dispatcher->dispatch($route, $request, $class, $method);
    }
    public function runControllerAction($controller, $action = null)
    {
        $request = royalcms('request');
        $method = $this->resolveControllerAction($request, $controller, $action);
        list($class, $method) = explode('@', $method);
        $dispatcher = royalcms('royalcms.route.dispatcher');
        $route = royalcms('router')->getCurrentRoute();
        return $dispatcher->dispatch($route, $request, $controller, $method);
    }
    public function runModuleControllerAction($module, $controller, $action = null)
    {
        return $this->runControllerAction($module . '/' . $controller, $action);
    }
    protected function resolveControllerAction(Request $request, $controller, $action = null)
    {
        $this->originalController = $controller;
        $this->originalAction = $action;
        $controllerPrefix = $this->getControllerPrefix();
        $controllerSuffix = $this->getControllerSuffix();
        if (empty($action)) {
            $action = substr(strrchr($controller, '/'), 1);
            $controller = substr($controller, 0, strlen($controller) - strlen($action) + 1);
        }
        $controller = $this->normalizeName($controller);
        $action = $this->normalizeName($action);
        try {
            $controllerClass = $controllerPrefix . $controller . $controllerSuffix;
            return $this->resolveActionInCertainController($request, $controllerClass, $action);
        } catch (NotFoundHttpException $e) {
            $controllerClass = $controllerPrefix . $controller . '\\' . $action . $controllerSuffix;
            return $this->resolveActionInCertainController($request, $controllerClass, $this->defaultAction);
        }
    }
    protected function getControllerPrefix()
    {
        return config('defaultroutes.controller-prefix', '');
    }
    protected function getControllerSuffix()
    {
        return config('defaultroutes.controller-suffix', '');
    }
    protected function resolveActionInCertainController(Request $request, $controllerClass, $action)
    {
        $action = $this->normalizeName($action);
        $action = $action ?: $this->defaultAction;
        $httpMethod = $request->getMethod();
        $classMethod = "action{$httpMethod}{$action}";
        if (preg_match('/^[_]/i', $this->originalAction)) {
            throw new AccessDeniedHttpException("You are visiting the {$this->originalAction} is to protect the private action");
        } else {
            if (!method_exists($controllerClass, $classMethod)) {
                $classMethod = "action{$action}";
                if (!method_exists($controllerClass, $classMethod)) {
                    $classMethod = $this->originalAction;
                    $controllerClass = $this->originalController;
                    if (!method_exists($controllerClass, $classMethod)) {
                        throw new NotFoundHttpException("Action {$controllerClass}@{$classMethod} cannot be found");
                    }
                }
            }
        }
        try {
            $reflectionMethod = new \ReflectionMethod($controllerClass, $classMethod);
            if (!$reflectionMethod->isPublic()) {
                throw new AccessDeniedHttpException("Action {$action} is not allowed");
            }
            return $controllerClass . '@' . $classMethod;
        } catch (\ReflectionException $e) {
            throw new NotFoundHttpException("Action {$action} cannot be found");
        }
    }
    protected function normalizeName($name)
    {
        $name = implode('', array_map('ucfirst', explode('-', $name)));
        $name = implode('', array_map('ucfirst', explode('_', $name)));
        $name = implode('\\', array_map('ucfirst', explode('/', $name)));
        return $name;
    }
}
}

namespace Royalcms\Component\DefaultRoute {
use Royalcms\Component\Http\Request;
use Royalcms\Component\Rewrite\Facades\Rewrite;
class HttpQueryRoute
{
    use DefaultRouteTrait;
    protected $module;
    protected $controller;
    protected $action;
    protected $request;
    protected $defaultRoute;
    public function __construct()
    {
        $this->request = royalcms('request');
        $this->defaultRoute = config('route.' . SITE_HOST, config('route.default'));
        $this->match($this->request);
    }
    public function match(Request $request)
    {
        $moduleName = config('route.module', 'm');
        $controllerName = config('route.controller', 'c');
        $actionName = config('route.action', 'a');
        $routeName = config('route.route', 'r');
        Rewrite::instance()->set_permalink_structure(true);
        $rewrite = royalcms('rewrite');
        $rewrite->add_query_vars(array_keys($_GET));
        $rewrite->parse_request();
        $params = $rewrite->get_query_var();
        $request->merge($params);
        if (($route = $request->input($routeName)) != false) {
            list($module, $controller, $action) = explode('/', $route);
            $this->module = $module ?: $this->matchDefaultRoute($moduleName);
            $this->controller = $controller ?: $this->matchDefaultRoute($controllerName);
            $this->action = $action ?: $this->matchDefaultRoute($actionName);
        } else {
            if ($request->input($moduleName)) {
                $this->module = $request->input($moduleName, $this->matchDefaultRoute($moduleName));
                $this->controller = $request->input($controllerName, $this->matchDefaultRoute($controllerName));
                $this->action = $request->input($actionName, $this->matchDefaultRoute($actionName));
            } elseif (($route = ltrim($request->getPathInfo(), '/')) != false) {
                list($module, $controller, $action) = explode('/', $route);
                $this->module = $module ?: $this->matchDefaultRoute($moduleName);
                $this->controller = $controller ?: $this->matchDefaultRoute($controllerName);
                $this->action = $action ?: $this->matchDefaultRoute($actionName);
            } else {
                $this->module = $this->matchDefaultRoute($moduleName);
                $this->controller = $this->matchDefaultRoute($controllerName);
                $this->action = $this->matchDefaultRoute($actionName);
            }
        }
        $this->module = $this->ksesString($this->module);
        $this->controller = $this->ksesString($this->controller);
        $this->action = $this->ksesString($this->action);
    }
    protected function ksesString($route)
    {
        return safe_remove($route);
    }
    public function matchDefaultRoute($key)
    {
        return array_get($this->defaultRoute, $key);
    }
    public function getModule()
    {
        $moduleName = config('route.module', 'm');
        return $this->module ?: $this->matchDefaultRoute($moduleName);
    }
    public function getController()
    {
        $controllerName = config('route.controller', 'c');
        return $this->controller ?: $this->matchDefaultRoute($controllerName);
    }
    public function getAction()
    {
        $actionName = config('route.action', 'a');
        return $this->action ?: $this->matchDefaultRoute($actionName);
    }
    public function getRule()
    {
        return $rules = config('route.rules', []);
    }
    public function justCurrentRoute($route)
    {
        $route = trim($route, '/');
        $current = $this->module . '/' . $this->controller . '/' . $this->action;
        if ($route == $current) {
            return true;
        } else {
            return false;
        }
    }
}
}

namespace Royalcms\Component\DefaultRoute {
use Royalcms\Component\Support\ServiceProvider;
class DefaultRouteServiceProvider extends ServiceProvider
{
    public function boot()
    {
    }
    public function register()
    {
        $this->royalcms['default-router'] = $this->royalcms->share(function ($royalcms) {
            $route = new HttpQueryRoute();
            define('ROUTE_M', $route->getModule());
            define('ROUTE_C', $route->getController());
            define('ROUTE_A', $route->getAction());
            return $route;
        });
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/default-route');
        return [$dir . '/DefaultRouteTrait.php', $dir . '/HttpQueryRoute.php', $dir . '/DefaultRouteServiceProvider.php'];
    }
}
}

namespace Royalcms\Component\Variable {
use RC_Hook;
class Variable
{
    protected $data = array();
    protected $isLoaded = false;
    public function __construct()
    {
        $this->load();
    }
    public function get($key = '', $default = null)
    {
        if (empty($key)) {
            return $this->data;
        } else {
            return isset($this->data[$key]) ? $this->data[$key] : $default;
        }
    }
    public function set($key, $value)
    {
        $this->data[$key] = $value;
        RC_Hook::do_action('rc_variable_set', $key, $value);
        return $this;
    }
    public function delete($key)
    {
        unset($this->data[$key]);
        RC_Hook::do_action('rc_variable_delete', $key);
        return $this;
    }
    public function setMulti(array $items)
    {
        foreach ($items as $key => $value) {
            $this->set($key, $value);
        }
        return $this;
    }
    public function getMulti(array $keys)
    {
        foreach ($keys as $key) {
            $return[$key] = $this->get($key);
        }
        return $return;
    }
    public function deleteMulti(array $keys)
    {
        foreach ($keys as $key) {
            $this->delete($key);
        }
        return $this;
    }
    public function hasKey($key)
    {
        return isset($this->data[$key]) ? true : false;
    }
    public function load()
    {
        if (!$this->isLoaded) {
            try {
                $this->data = RC_Hook::apply_filters('rc_variable_load', array());
                foreach ($this->data as $k => $v) {
                    $this->data[$k] = unserialize($v);
                }
                $this->isLoaded = true;
            } catch (\Exception $e) {
                throw new \Exception('Struct {variables} is not exists.');
            }
        }
        return $this;
    }
}
}

namespace Royalcms\Component\Variable {
use Royalcms\Component\Support\ServiceProvider;
class VariableServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->bindShared('variable', function ($royalcms) {
            return new Variable();
        });
    }
    public function provides()
    {
        return array('variable');
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/variable');
        return [$dir . '/Variable.php', $dir . '/VariableServiceProvider.php', $dir . '/Facades/Variable.php'];
    }
}
}

namespace Royalcms\Component\Variable\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Variable extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'variable';
    }
}
}

namespace Royalcms\Component\Repository\Repositories {
use Closure;
use BadMethodCallException;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Support\MessageBag;
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Database\Eloquent\Model;
use Royalcms\Component\Database\Eloquent\Builder;
use Royalcms\Component\Repository\Traits\Cacheable;
use Royalcms\Component\Database\Eloquent\ModelNotFoundException;
use Royalcms\Component\Repository\Contracts\RepositoryContract;
use Royalcms\Component\Repository\Exceptions\RepositoryException;
abstract class AbstractRepository implements RepositoryContract
{
    use Cacheable;
    const EXPIRES_END_OF_DAY = 'eod';
    public static $searchOperator = 'LIKE';
    protected $modelInstance;
    protected $errors;
    protected $query;
    protected $scopeQuery = [];
    protected $orderable = [];
    protected $searchable = [];
    protected $orderBy = [];
    public function __construct()
    {
        $this->makeModel();
        $this->scopeReset();
        $this->boot();
    }
    public function boot()
    {
    }
    public function getModel()
    {
        return $this->modelInstance;
    }
    protected function scopeReset()
    {
        $this->scopeQuery = [];
        $this->query = $this->newQuery();
        return $this;
    }
    public function getNew(array $attributes = [])
    {
        $this->errors = new MessageBag();
        return $this->modelInstance->newInstance($attributes);
    }
    public function newQuery($skipOrdering = false)
    {
        $this->query = $this->getNew()->newQuery();
        if ($skipOrdering === false) {
            foreach ($this->orderBy as $column => $dir) {
                $this->query->orderBy($column, $dir);
            }
        }
        $this->applyScope();
        return $this;
    }
    public function find($id, $columns = ['*'])
    {
        $this->newQuery();
        return $this->query->find($id, $columns);
    }
    public function findOrFail($id)
    {
        $this->newQuery();
        $result = $this->query->find($id);
        if ($result) {
            return $result;
        }
        throw with(new ModelNotFoundException())->setModel($this->model);
    }
    public function findBy($field, $value, $columns = ['*'])
    {
        $this->newQuery();
        return $this->query->where($field, '=', $value)->first();
    }
    public function findAllBy($attribute, $value, $columns = ['*'])
    {
        $this->newQuery();
        if (is_array($value)) {
            return $this->query->whereIn($attribute, $value)->get($columns);
        }
        return $this->query->where($attribute, '=', $value)->get($columns);
    }
    public function findWhere(array $where, $columns = ['*'])
    {
        $this->newQuery();
        foreach ($where as $field => $value) {
            if (is_array($value)) {
                list($field, $condition, $val) = $value;
                $this->query->where($field, $condition, $val);
            } else {
                $this->query->where($field, '=', $value);
            }
        }
        return $this->query->get($columns);
    }
    public function orderBy($column, $direction)
    {
        return $this->addScopeQuery(function ($query) use($column, $direction) {
            $direction = in_array(strtolower($direction), ['desc', 'asc']) ? $direction : 'asc';
            if (in_array($column, $this->orderable) === false && array_key_exists($column, $this->orderable) === false) {
                return $query;
            }
            $column = Arr::get($this->orderable, $column, $column);
            return $query->orderBy($this->appendTableName($column), $direction);
        });
    }
    public function search($queries)
    {
        if (is_string($queries)) {
            $queries = ['query' => $queries];
        }
        return $this->addScopeQuery(function ($query) use($queries) {
            foreach ($this->searchable as $param => $columns) {
                $param = is_numeric($param) ? $columns : $param;
                $value = Arr::get($queries, $param, '');
                if ($value === '' || $value === null) {
                    continue;
                }
                $columns = (array) $columns;
                if (count($columns) > 1) {
                    $query->where(function ($q) use($columns, $param, $value) {
                        foreach ($columns as $column) {
                            $this->createSearchClause($q, $param, $column, $value, 'or');
                        }
                    });
                } else {
                    $this->createSearchClause($query, $param, $columns[0], $value);
                }
            }
            return $query;
        });
    }
    public function all($columns = ['*'])
    {
        $this->newQuery();
        return $this->query->get($columns);
    }
    public function pluck($value, $key = null)
    {
        $this->newQuery();
        $lists = $this->query->pluck($value, $key);
        if (is_array($lists)) {
            return $lists;
        }
        return $lists->all();
    }
    public function paginate($limit = null, $columns = ['*'])
    {
        $this->newQuery();
        return $this->query->paginate($limit, $columns);
    }
    public function simplePaginate($limit = null, $columns = ['*'])
    {
        $this->newQuery();
        return $this->query->simplePaginate($limit, $columns);
    }
    public function create(array $attributes)
    {
        $entity = $this->getNew($attributes);
        if ($entity->save()) {
            $this->flushCache();
            return $entity;
        }
        return false;
    }
    public function update(Model $entity, array $attributes)
    {
        if ($entity->update($attributes)) {
            $this->flushCache();
            return true;
        }
        return false;
    }
    public function delete($entity)
    {
        if ($entity instanceof Model === false) {
            $entity = $this->find($entity);
        }
        if ($entity->delete()) {
            $this->flushCache();
            return true;
        }
        return false;
    }
    public function makeModel()
    {
        if (!$this->model) {
            throw new RepositoryException("The model class must be set on the repository.");
        }
        return $this->modelInstance = with(new $this->model());
    }
    public function toSql()
    {
        $this->newQuery();
        return $this->query->toSql();
    }
    public function getScopeQuery()
    {
        return $this->scopeQuery;
    }
    public function addScopeQuery(Closure $scope)
    {
        $this->scopeQuery[] = $scope;
        return $this;
    }
    protected function applyScope()
    {
        foreach ($this->scopeQuery as $callback) {
            if (is_callable($callback)) {
                $this->query = $callback($this->query);
            }
        }
        $this->scopeQuery = [];
        return $this;
    }
    public function addError($message)
    {
        $this->errors->add('message', $message);
        return null;
    }
    public function getErrors()
    {
        return $this->errors;
    }
    public function getErrorMessage($default = '')
    {
        return $this->errors->first('message') ?: $default;
    }
    protected function appendTableName($column)
    {
        return strpos($column, '.') === false ? $this->modelInstance->getTable() . '.' . $column : $column;
    }
    protected function createSearchClause(Builder $query, $param, $column, $value, $boolean = 'and')
    {
        if ($param === 'query') {
            $query->where($this->appendTableName($column), self::$searchOperator, '%' . $value . '%', $boolean);
        } else {
            $query->where($this->appendTableName($column), '=', $value, $boolean);
        }
    }
    public function __call($method, $parameters)
    {
        if (method_exists($this, $scope = 'scope' . ucfirst($method))) {
            return call_user_func_array([$this, $scope], $parameters);
        }
        $className = get_class($this);
        throw new BadMethodCallException("Call to undefined method {$className}::{$method}()");
    }
}
}

namespace Royalcms\Component\Repository\Traits {
use Closure;
use Royalcms\Component\DateTime\Carbon;
use Royalcms\Component\Cache\CacheManager;
use Royalcms\Component\Database\Eloquent\Model;
trait Cacheable
{
    protected static $cache = null;
    protected $eventFlushCache = false;
    protected $cacheMinutes = 60;
    public static function setCacheInstance(CacheManager $cache)
    {
        self::$cache = $cache;
    }
    public static function getCacheInstance()
    {
        if (self::$cache === null) {
            self::$cache = royalcms('cache');
        }
        return self::$cache;
    }
    public function skippedCache()
    {
        return config('repository::repositories.cache_enabled', false) === false || royalcms('request')->has(config('repository::repositories.cache_skip_param', 'skipCache')) === true;
    }
    public function getCacheKey($method, $args = null, $tag)
    {
        foreach ($args as &$a) {
            if ($a instanceof Model) {
                $a = get_class($a) . '|' . $a->getKey();
            }
        }
        $args = serialize($args) . serialize($this->getScopeQuery());
        return sprintf('%s-%s@%s-%s', config('system.locale'), $tag, $method, md5($args));
    }
    public function cacheCallback($method, $args, Closure $callback, $time = null)
    {
        if ($this->skippedCache() === true) {
            return call_user_func($callback);
        }
        $tag = get_called_class();
        return self::getCacheInstance()->tags(['repositories', $tag])->remember($this->getCacheKey($method, $args, $tag), $this->getCacheExpiresTime($time), $callback);
    }
    public function flushCache()
    {
        if ($this->eventFlushCache === false || config('repository::repositories.cache_enabled', false) === false) {
            return false;
        }
        $tag = get_called_class();
        return self::getCacheInstance()->tags(['repositories', $tag])->flush();
    }
    protected function getCacheExpiresTime($time = null)
    {
        if ($time === self::EXPIRES_END_OF_DAY) {
            return class_exists('Royalcms\\Component\\DateTime\\Carbon') ? round(Carbon::now()->secondsUntilEndOfDay() / 60) : $this->cacheMinutes;
        }
        return $time ?: $this->cacheMinutes;
    }
}
}

namespace Royalcms\Component\Repository\Contracts {
use Royalcms\Component\Support\Collection;
use Royalcms\Component\Pagination\Paginator;
use Royalcms\Component\Database\Eloquent\Model;
interface RepositoryContract
{
    public function getModel();
    public function find($id, $columns = ['*']);
    public function findOrFail($id);
    public function findBy($field, $value, $columns = ['*']);
    public function findAllBy($attribute, $value, $columns = ['*']);
    public function findWhere(array $where, $columns = ['*']);
    public function orderBy($column, $direction);
    public function search($queries);
    public function all($columns = ['*']);
    public function pluck($value, $key = null);
    public function paginate($limit = null, $columns = ['*']);
    public function simplePaginate($limit = null, $columns = ['*']);
    public function create(array $attributes);
    public function update(Model $entity, array $attributes);
    public function delete($entity);
    public function toSql();
    public function addError($message);
    public function getErrors();
    public function getErrorMessage($default = '');
}
}

namespace Royalcms\Component\Repository {
use Royalcms\Component\Support\ServiceProvider;
use Royalcms\Component\Repository\Repositories\AbstractRepository;
class RepositoryServiceProvider extends ServiceProvider
{
    public function boot()
    {
        $this->setupConfig();
        AbstractRepository::setCacheInstance($this->royalcms['cache']);
    }
    protected function setupConfig()
    {
        $this->package('royalcms/repository');
    }
    public function register()
    {
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/repository');
        return [$dir . "/Repositories/AbstractRepository.php", $dir . "/Traits/Cacheable.php", $dir . "/Contracts/RepositoryContract.php", $dir . "/RepositoryServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Agent\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Agent extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'agent';
    }
}
}

namespace Royalcms\Component\Agent {
use BadMethodCallException;
use Mobile_Detect;
class Agent extends MobileDetect
{
    protected static $additionalDevices = array('Macintosh' => 'Macintosh');
    protected static $additionalOperatingSystems = array('Windows' => 'Windows', 'Windows NT' => 'Windows NT', 'OS X' => 'Mac OS X', 'Debian' => 'Debian', 'Ubuntu' => 'Ubuntu', 'Macintosh' => 'PPC', 'OpenBSD' => 'OpenBSD', 'Linux' => 'Linux', 'ChromeOS' => 'CrOS');
    protected static $additionalBrowsers = array('Opera' => 'Opera|OPR', 'Edge' => 'Edge', 'Chrome' => 'Chrome', 'Firefox' => 'Firefox', 'Safari' => 'Safari', 'IE' => 'MSIE|IEMobile|MSIEMobile|Trident/[.0-9]+', 'Netscape' => 'Netscape', 'Mozilla' => 'Mozilla');
    protected static $additionalProperties = array('Windows' => 'Windows NT [VER]', 'Windows NT' => 'Windows NT [VER]', 'OS X' => 'OS X [VER]', 'BlackBerryOS' => array('BlackBerry[\\w]+/[VER]', 'BlackBerry.*Version/[VER]', 'Version/[VER]'), 'AndroidOS' => 'Android [VER]', 'ChromeOS' => 'CrOS x86_64 [VER]', 'Opera' => array(' OPR/[VER]', 'Opera Mini/[VER]', 'Version/[VER]', 'Opera [VER]'), 'Netscape' => 'Netscape/[VER]', 'Mozilla' => 'rv:[VER]', 'IE' => array('IEMobile/[VER];', 'IEMobile [VER]', 'MSIE [VER];', 'rv:[VER]'), 'Edge' => 'Edge/[VER]');
    protected static $robots = array('Google' => 'googlebot', 'MSNBot' => 'msnbot', 'Baiduspider' => 'baiduspider', 'Bing' => 'bingbot', 'Yahoo' => 'yahoo', 'Lycos' => 'lycos', 'Facebook' => 'facebookexternalhit', 'Twitter' => 'Twitterbot');
    public function getDetectionRulesExtended()
    {
        static $rules;
        if (!$rules) {
            $rules = $this->mergeRules(static::$additionalDevices, static::$phoneDevices, static::$tabletDevices, static::$operatingSystems, static::$additionalOperatingSystems, static::$browsers, static::$additionalBrowsers, static::$utilities);
        }
        return $rules;
    }
    public function getRules()
    {
        if ($this->detectionType == static::DETECTION_TYPE_EXTENDED) {
            return static::getDetectionRulesExtended();
        } else {
            return static::getMobileDetectionRules();
        }
    }
    public function languages($acceptLanguage = null)
    {
        if (!$acceptLanguage) {
            $acceptLanguage = $this->getHttpHeader('HTTP_ACCEPT_LANGUAGE');
        }
        if ($acceptLanguage) {
            $languages = array();
            foreach (explode(',', $acceptLanguage) as $piece) {
                $parts = explode(';', $piece);
                $language = strtolower($parts[0]);
                $priority = empty($parts[1]) ? 1.0 : floatval(str_replace('q=', '', $parts[1]));
                $languages[$language] = $priority;
            }
            arsort($languages);
            return array_keys($languages);
        }
        return array();
    }
    protected function findDetectionRulesAgainstUA(array $rules, $userAgent = null)
    {
        foreach ($rules as $key => $regex) {
            if (empty($regex)) {
                continue;
            }
            if ($this->match($regex, $userAgent)) {
                return $key ?: reset($this->matchesArray);
            }
        }
        return false;
    }
    public function browser($userAgent = null)
    {
        $rules = $this->mergeRules(static::$additionalBrowsers, static::$browsers);
        return $this->findDetectionRulesAgainstUA($rules, $userAgent);
    }
    public function platform($userAgent = null)
    {
        $rules = $this->mergeRules(static::$operatingSystems, static::$additionalOperatingSystems);
        return $this->findDetectionRulesAgainstUA($rules, $userAgent);
    }
    public function device($userAgent = null)
    {
        $rules = $this->mergeRules(static::$additionalDevices, static::$phoneDevices, static::$tabletDevices, static::$utilities);
        return $this->findDetectionRulesAgainstUA($rules, $userAgent);
    }
    public function isDesktop($userAgent = null, $httpHeaders = null)
    {
        return !$this->isMobile() && !$this->isTablet() && !$this->isRobot();
    }
    public function isPhone($userAgent = null, $httpHeaders = null)
    {
        return $this->isMobile() && !$this->isTablet();
    }
    public function robot($userAgent = null)
    {
        $rules = $this->mergeRules(static::$robots, array(static::$utilities['Bot']), array(static::$utilities['MobileBot']));
        return $this->findDetectionRulesAgainstUA($rules, $userAgent);
    }
    public function isRobot($userAgent = null)
    {
        $rules = $this->mergeRules(array(static::$utilities['Bot']), array(static::$utilities['MobileBot']), static::$robots);
        foreach ($rules as $regex) {
            if ($this->match($regex, $userAgent)) {
                return true;
            }
        }
        return false;
    }
    public function version($propertyName, $type = self::VERSION_TYPE_STRING)
    {
        $check = key(static::$additionalProperties);
        if (!array_key_exists($check, parent::$properties)) {
            parent::$properties = array_merge(parent::$properties, static::$additionalProperties);
        }
        return parent::version($propertyName, $type);
    }
    protected function mergeRules()
    {
        $merged = array();
        foreach (func_get_args() as $rules) {
            foreach ($rules as $key => $value) {
                if (empty($merged[$key])) {
                    $merged[$key] = $value;
                } else {
                    if (is_array($merged[$key])) {
                        $merged[$key][] = $value;
                    } else {
                        $merged[$key] .= '|' . $value;
                    }
                }
            }
        }
        return $merged;
    }
    public function __call($name, $arguments)
    {
        if (substr($name, 0, 2) != 'is') {
            throw new BadMethodCallException("No such method exists: {$name}");
        }
        $this->setDetectionType(self::DETECTION_TYPE_EXTENDED);
        $key = substr($name, 2);
        return $this->matchUAAgainstKey($key);
    }
}
}

namespace Royalcms\Component\Agent {
use BadMethodCallException;
class MobileDetect
{
    const DETECTION_TYPE_MOBILE = 'mobile';
    const DETECTION_TYPE_EXTENDED = 'extended';
    const VER = '([\\w._\\+]+)';
    const MOBILE_GRADE_A = 'A';
    const MOBILE_GRADE_B = 'B';
    const MOBILE_GRADE_C = 'C';
    const VERSION = '2.8.19';
    const VERSION_TYPE_STRING = 'text';
    const VERSION_TYPE_FLOAT = 'float';
    protected $cache = array();
    protected $userAgent = null;
    protected $httpHeaders = array();
    protected $cloudfrontHeaders = array();
    protected $matchingRegex = null;
    protected $matchesArray = null;
    protected $detectionType = self::DETECTION_TYPE_MOBILE;
    protected static $mobileHeaders = array('HTTP_ACCEPT' => array('matches' => array('application/x-obml2d', 'application/vnd.rim.html', 'text/vnd.wap.wml', 'application/vnd.wap.xhtml+xml')), 'HTTP_X_WAP_PROFILE' => null, 'HTTP_X_WAP_CLIENTID' => null, 'HTTP_WAP_CONNECTION' => null, 'HTTP_PROFILE' => null, 'HTTP_X_OPERAMINI_PHONE_UA' => null, 'HTTP_X_NOKIA_GATEWAY_ID' => null, 'HTTP_X_ORANGE_ID' => null, 'HTTP_X_VODAFONE_3GPDPCONTEXT' => null, 'HTTP_X_HUAWEI_USERID' => null, 'HTTP_UA_OS' => null, 'HTTP_X_MOBILE_GATEWAY' => null, 'HTTP_X_ATT_DEVICEID' => null, 'HTTP_UA_CPU' => array('matches' => array('ARM')));
    protected static $phoneDevices = array('iPhone' => '\\biPhone\\b|\\biPod\\b', 'BlackBerry' => 'BlackBerry|\\bBB10\\b|rim[0-9]+', 'HTC' => 'HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m', 'Nexus' => 'Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6', 'Dell' => 'Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b', 'Motorola' => 'Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b', 'Samsung' => 'Samsung|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205', 'LG' => '\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)', 'Sony' => 'SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533', 'Asus' => 'Asus.*Galaxy|PadFone.*Mobile', 'Micromax' => 'Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b', 'Palm' => 'PalmSource|Palm', 'Vertu' => 'Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature', 'Pantech' => 'PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790', 'Fly' => 'IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250', 'Wiko' => 'KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM', 'iMobile' => 'i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)', 'SimValley' => '\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b', 'Wolfgang' => 'AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q', 'Alcatel' => 'Alcatel', 'Nintendo' => 'Nintendo 3DS', 'Amoi' => 'Amoi', 'INQ' => 'INQ', 'GenericPhone' => 'Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser');
    protected static $tabletDevices = array('iPad' => 'iPad|iPad.*Mobile', 'NexusTablet' => 'Android.*Nexus[\\s]+(7|9|10)', 'SamsungTablet' => 'SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715', 'Kindle' => 'Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI)\\b', 'SurfaceTablet' => 'Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)', 'HPTablet' => 'HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10', 'AsusTablet' => '^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K017 |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C', 'BlackBerryTablet' => 'PlayBook|RIM Tablet', 'HTCtablet' => 'HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410', 'MotorolaTablet' => 'xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617', 'NookTablet' => 'Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2', 'AcerTablet' => 'Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b', 'ToshibaTablet' => 'Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO', 'LGTablet' => '\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b', 'FujitsuTablet' => 'Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b', 'PrestigioTablet' => 'PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002', 'LenovoTablet' => 'Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)', 'DellTablet' => 'Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7', 'YarvikTablet' => 'Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b', 'MedionTablet' => 'Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB', 'ArnovaTablet' => 'AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2', 'IntensoTablet' => 'INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004', 'IRUTablet' => 'M702pro', 'MegafonTablet' => 'MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b', 'EbodaTablet' => 'E-Boda (Supreme|Impresspeed|Izzycomm|Essential)', 'AllViewTablet' => 'Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)', 'ArchosTablet' => '\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b', 'AinolTablet' => 'NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark', 'SonyTablet' => 'Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31', 'PhilipsTablet' => '\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b', 'CubeTablet' => 'Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT', 'CobyTablet' => 'MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010', 'MIDTablet' => 'M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733', 'MSITablet' => 'MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b', 'SMiTTablet' => 'Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)', 'RockChipTablet' => 'Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A', 'FlyTablet' => 'IQ310|Fly Vision', 'bqTablet' => 'Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris E10)|Maxwell.*Lite|Maxwell.*Plus', 'HuaweiTablet' => 'MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim', 'NecTablet' => '\\bN-06D|\\bN-08D', 'PantechTablet' => 'Pantech.*P4100', 'BronchoTablet' => 'Broncho.*(N701|N708|N802|a710)', 'VersusTablet' => 'TOUCHPAD.*[78910]|\\bTOUCHTAB\\b', 'ZyncTablet' => 'z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900', 'PositivoTablet' => 'TB07STA|TB10STA|TB07FTA|TB10FTA', 'NabiTablet' => 'Android.*\\bNabi', 'KoboTablet' => 'Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build', 'DanewTablet' => 'DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b', 'TexetTablet' => 'NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE', 'PlaystationTablet' => 'Playstation.*(Portable|Vita)', 'TrekstorTablet' => 'ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab', 'PyleAudioTablet' => '\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b', 'AdvanTablet' => 'Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ', 'DanyTechTablet' => 'Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1', 'GalapadTablet' => 'Android.*\\bG1\\b', 'MicromaxTablet' => 'Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b', 'KarbonnTablet' => 'Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b', 'AllFineTablet' => 'Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide', 'PROSCANTablet' => '\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b', 'YONESTablet' => 'BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026', 'ChangJiaTablet' => 'TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503', 'GUTablet' => 'TX-A1301|TX-M9002|Q702|kf026', 'PointOfViewTablet' => 'TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10', 'OvermaxTablet' => 'OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)', 'HCLTablet' => 'HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync', 'DPSTablet' => 'DPS Dream 9|DPS Dual 7', 'VistureTablet' => 'V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10', 'CrestaTablet' => 'CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989', 'MediatekTablet' => '\\bMT8125|MT8389|MT8135|MT8377\\b', 'ConcordeTablet' => 'Concorde([ ]+)?Tab|ConCorde ReadMan', 'GoCleverTablet' => 'GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042', 'ModecomTablet' => 'FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003', 'VoninoTablet' => '\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b', 'ECSTablet' => 'V07OT2|TM105A|S10OT1|TR10CS1', 'StorexTablet' => 'eZee[_\']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab', 'VodafoneTablet' => 'SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7', 'EssentielBTablet' => 'Smart[ \']?TAB[ ]+?[0-9]+|Family[ \']?TAB2', 'RossMoorTablet' => 'RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711', 'iMobileTablet' => 'i-mobile i-note', 'TolinoTablet' => 'tolino tab [0-9.]+|tolino shine', 'AudioSonicTablet' => '\\bC-22Q|T7-QC|T-17B|T-17P\\b', 'AMPETablet' => 'Android.* A78 ', 'SkkTablet' => 'Android.* (SKYPAD|PHOENIX|CYCLOPS)', 'TecnoTablet' => 'TECNO P9', 'JXDTablet' => 'Android.*\\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b', 'iJoyTablet' => 'Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)', 'FX2Tablet' => 'FX2 PAD7|FX2 PAD10', 'XoroTablet' => 'KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151', 'ViewsonicTablet' => 'ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a', 'OdysTablet' => 'LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10', 'CaptivaTablet' => 'CAPTIVA PAD', 'IconbitTablet' => 'NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S', 'TeclastTablet' => 'T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi', 'OndaTablet' => '\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+', 'JaytechTablet' => 'TPC-PA762', 'BlaupunktTablet' => 'Endeavour 800NG|Endeavour 1010', 'DigmaTablet' => '\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b', 'EvolioTablet' => 'ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b', 'LavaTablet' => 'QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b', 'AocTablet' => 'MW0811|MW0812|MW0922|MTK8382', 'CelkonTablet' => 'CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b', 'WolderTablet' => 'miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b', 'MiTablet' => '\\bMI PAD\\b|\\bHM NOTE 1W\\b', 'NibiruTablet' => 'Nibiru M1|Nibiru Jupiter One', 'NexoTablet' => 'NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI', 'LeaderTablet' => 'TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100', 'UbislateTablet' => 'UbiSlate[\\s]?7C', 'PocketBookTablet' => 'Pocketbook', 'Hudl' => 'Hudl HT7S3|Hudl 2', 'TelstraTablet' => 'T-Hub2', 'GenericTablet' => 'Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bJolla\\b|\\bTP750\\b');
    protected static $operatingSystems = array('AndroidOS' => 'Android', 'BlackBerryOS' => 'blackberry|\\bBB10\\b|rim tablet os', 'PalmOS' => 'PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino', 'SymbianOS' => 'Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b', 'WindowsMobileOS' => 'Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;', 'WindowsPhoneOS' => 'Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;', 'iOS' => '\\biPhone.*Mobile|\\biPod|\\biPad', 'MeeGoOS' => 'MeeGo', 'MaemoOS' => 'Maemo', 'JavaOS' => 'J2ME/|\\bMIDP\\b|\\bCLDC\\b', 'webOS' => 'webOS|hpwOS', 'badaOS' => '\\bBada\\b', 'BREWOS' => 'BREW');
    protected static $browsers = array('Chrome' => '\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?', 'Dolfin' => '\\bDolfin\\b', 'Opera' => 'Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+|Coast/[0-9.]+', 'Skyfire' => 'Skyfire', 'IE' => 'IEMobile|MSIEMobile', 'Firefox' => 'fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile', 'Bolt' => 'bolt', 'TeaShark' => 'teashark', 'Blazer' => 'Blazer', 'Safari' => 'Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari', 'Tizen' => 'Tizen', 'UCBrowser' => 'UC.*Browser|UCWEB', 'baiduboxapp' => 'baiduboxapp', 'baidubrowser' => 'baidubrowser', 'DiigoBrowser' => 'DiigoBrowser', 'Puffin' => 'Puffin', 'Mercury' => '\\bMercury\\b', 'ObigoBrowser' => 'Obigo', 'NetFront' => 'NF-Browser', 'GenericBrowser' => 'NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger');
    protected static $utilities = array('Bot' => 'Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom', 'MobileBot' => 'Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2', 'DesktopMode' => 'WPDesktop', 'TV' => 'SonyDTV|HbbTV', 'WebKit' => '(webkit)[ /]([\\w.]+)', 'Console' => '\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b', 'Watch' => 'SM-V700');
    protected static $uaHttpHeaders = array('HTTP_USER_AGENT', 'HTTP_X_OPERAMINI_PHONE_UA', 'HTTP_X_DEVICE_USER_AGENT', 'HTTP_X_ORIGINAL_USER_AGENT', 'HTTP_X_SKYFIRE_PHONE', 'HTTP_X_BOLT_PHONE_UA', 'HTTP_DEVICE_STOCK_UA', 'HTTP_X_UCBROWSER_DEVICE_UA');
    protected static $properties = array('Mobile' => 'Mobile/[VER]', 'Build' => 'Build/[VER]', 'Version' => 'Version/[VER]', 'VendorID' => 'VendorID/[VER]', 'iPad' => 'iPad.*CPU[a-z ]+[VER]', 'iPhone' => 'iPhone.*CPU[a-z ]+[VER]', 'iPod' => 'iPod.*CPU[a-z ]+[VER]', 'Kindle' => 'Kindle/[VER]', 'Chrome' => array('Chrome/[VER]', 'CriOS/[VER]', 'CrMo/[VER]'), 'Coast' => array('Coast/[VER]'), 'Dolfin' => 'Dolfin/[VER]', 'Firefox' => 'Firefox/[VER]', 'Fennec' => 'Fennec/[VER]', 'IE' => array('IEMobile/[VER];', 'IEMobile [VER]', 'MSIE [VER];', 'Trident/[0-9.]+;.*rv:[VER]'), 'NetFront' => 'NetFront/[VER]', 'NokiaBrowser' => 'NokiaBrowser/[VER]', 'Opera' => array(' OPR/[VER]', 'Opera Mini/[VER]', 'Version/[VER]'), 'Opera Mini' => 'Opera Mini/[VER]', 'Opera Mobi' => 'Version/[VER]', 'UC Browser' => 'UC Browser[VER]', 'MQQBrowser' => 'MQQBrowser/[VER]', 'MicroMessenger' => 'MicroMessenger/[VER]', 'baiduboxapp' => 'baiduboxapp/[VER]', 'baidubrowser' => 'baidubrowser/[VER]', 'Iron' => 'Iron/[VER]', 'Safari' => array('Version/[VER]', 'Safari/[VER]'), 'Skyfire' => 'Skyfire/[VER]', 'Tizen' => 'Tizen/[VER]', 'Webkit' => 'webkit[ /][VER]', 'Gecko' => 'Gecko/[VER]', 'Trident' => 'Trident/[VER]', 'Presto' => 'Presto/[VER]', 'iOS' => ' \\bi?OS\\b [VER][ ;]{1}', 'Android' => 'Android [VER]', 'BlackBerry' => array('BlackBerry[\\w]+/[VER]', 'BlackBerry.*Version/[VER]', 'Version/[VER]'), 'BREW' => 'BREW [VER]', 'Java' => 'Java/[VER]', 'Windows Phone OS' => array('Windows Phone OS [VER]', 'Windows Phone [VER]'), 'Windows Phone' => 'Windows Phone [VER]', 'Windows CE' => 'Windows CE/[VER]', 'Windows NT' => 'Windows NT [VER]', 'Symbian' => array('SymbianOS/[VER]', 'Symbian/[VER]'), 'webOS' => array('webOS/[VER]', 'hpwOS/[VER];'));
    public function __construct(array $headers = null, $userAgent = null)
    {
        $this->setHttpHeaders($headers);
        $this->setUserAgent($userAgent);
    }
    public static function getScriptVersion()
    {
        return self::VERSION;
    }
    public function setHttpHeaders($httpHeaders = null)
    {
        if (!is_array($httpHeaders) || !count($httpHeaders)) {
            $httpHeaders = $_SERVER;
        }
        $this->httpHeaders = array();
        foreach ($httpHeaders as $key => $value) {
            if (substr($key, 0, 5) === 'HTTP_') {
                $this->httpHeaders[$key] = $value;
            }
        }
        $this->setCfHeaders($httpHeaders);
    }
    public function getHttpHeaders()
    {
        return $this->httpHeaders;
    }
    public function getHttpHeader($header)
    {
        if (strpos($header, '_') === false) {
            $header = str_replace('-', '_', $header);
            $header = strtoupper($header);
        }
        $altHeader = 'HTTP_' . $header;
        if (isset($this->httpHeaders[$header])) {
            return $this->httpHeaders[$header];
        } elseif (isset($this->httpHeaders[$altHeader])) {
            return $this->httpHeaders[$altHeader];
        }
        return null;
    }
    public function getMobileHeaders()
    {
        return self::$mobileHeaders;
    }
    public function getUaHttpHeaders()
    {
        return self::$uaHttpHeaders;
    }
    public function setCfHeaders($cfHeaders = null)
    {
        if (!is_array($cfHeaders) || !count($cfHeaders)) {
            $cfHeaders = $_SERVER;
        }
        $this->cloudfrontHeaders = array();
        $response = false;
        foreach ($cfHeaders as $key => $value) {
            if (substr(strtolower($key), 0, 16) === 'http_cloudfront_') {
                $this->cloudfrontHeaders[strtoupper($key)] = $value;
                $response = true;
            }
        }
        return $response;
    }
    public function getCfHeaders()
    {
        return $this->cloudfrontHeaders;
    }
    public function setUserAgent($userAgent = null)
    {
        $this->cache = array();
        if (false === empty($userAgent)) {
            return $this->userAgent = $userAgent;
        } else {
            $this->userAgent = null;
            foreach ($this->getUaHttpHeaders() as $altHeader) {
                if (false === empty($this->httpHeaders[$altHeader])) {
                    $this->userAgent .= $this->httpHeaders[$altHeader] . " ";
                }
            }
            if (!empty($this->userAgent)) {
                return $this->userAgent = trim($this->userAgent);
            }
        }
        if (count($this->getCfHeaders()) > 0) {
            return $this->userAgent = 'Amazon CloudFront';
        }
        return $this->userAgent = null;
    }
    public function getUserAgent()
    {
        return $this->userAgent;
    }
    public function setDetectionType($type = null)
    {
        if ($type === null) {
            $type = self::DETECTION_TYPE_MOBILE;
        }
        if ($type !== self::DETECTION_TYPE_MOBILE && $type !== self::DETECTION_TYPE_EXTENDED) {
            return;
        }
        $this->detectionType = $type;
    }
    public function getMatchingRegex()
    {
        return $this->matchingRegex;
    }
    public function getMatchesArray()
    {
        return $this->matchesArray;
    }
    public static function getPhoneDevices()
    {
        return self::$phoneDevices;
    }
    public static function getTabletDevices()
    {
        return self::$tabletDevices;
    }
    public static function getUserAgents()
    {
        return self::getBrowsers();
    }
    public static function getBrowsers()
    {
        return self::$browsers;
    }
    public static function getUtilities()
    {
        return self::$utilities;
    }
    public static function getMobileDetectionRules()
    {
        static $rules;
        if (!$rules) {
            $rules = array_merge(self::$phoneDevices, self::$tabletDevices, self::$operatingSystems, self::$browsers);
        }
        return $rules;
    }
    public function getMobileDetectionRulesExtended()
    {
        static $rules;
        if (!$rules) {
            $rules = array_merge(self::$phoneDevices, self::$tabletDevices, self::$operatingSystems, self::$browsers, self::$utilities);
        }
        return $rules;
    }
    public function getRules()
    {
        if ($this->detectionType == self::DETECTION_TYPE_EXTENDED) {
            return self::getMobileDetectionRulesExtended();
        } else {
            return self::getMobileDetectionRules();
        }
    }
    public static function getOperatingSystems()
    {
        return self::$operatingSystems;
    }
    public function checkHttpHeadersForMobile()
    {
        foreach ($this->getMobileHeaders() as $mobileHeader => $matchType) {
            if (isset($this->httpHeaders[$mobileHeader])) {
                if (is_array($matchType['matches'])) {
                    foreach ($matchType['matches'] as $_match) {
                        if (strpos($this->httpHeaders[$mobileHeader], $_match) !== false) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    return true;
                }
            }
        }
        return false;
    }
    public function __call($name, $arguments)
    {
        if (substr($name, 0, 2) !== 'is') {
            throw new BadMethodCallException("No such method exists: {$name}");
        }
        $this->setDetectionType(self::DETECTION_TYPE_MOBILE);
        $key = substr($name, 2);
        return $this->matchUAAgainstKey($key);
    }
    protected function matchDetectionRulesAgainstUA($userAgent = null)
    {
        foreach ($this->getRules() as $_regex) {
            if (empty($_regex)) {
                continue;
            }
            if ($this->match($_regex, $userAgent)) {
                return true;
            }
        }
        return false;
    }
    protected function matchUAAgainstKey($key)
    {
        $key = strtolower($key);
        if (false === isset($this->cache[$key])) {
            $_rules = array_change_key_case($this->getRules());
            if (false === empty($_rules[$key])) {
                $this->cache[$key] = $this->match($_rules[$key]);
            }
            if (false === isset($this->cache[$key])) {
                $this->cache[$key] = false;
            }
        }
        return $this->cache[$key];
    }
    public function isMobile($userAgent = null, $httpHeaders = null)
    {
        if ($httpHeaders) {
            $this->setHttpHeaders($httpHeaders);
        }
        if ($userAgent) {
            $this->setUserAgent($userAgent);
        }
        if ($this->getUserAgent() === 'Amazon CloudFront') {
            $cfHeaders = $this->getCfHeaders();
            if (array_key_exists('HTTP_CLOUDFRONT_IS_MOBILE_VIEWER', $cfHeaders) && $cfHeaders['HTTP_CLOUDFRONT_IS_MOBILE_VIEWER'] === 'true') {
                return true;
            }
        }
        $this->setDetectionType(self::DETECTION_TYPE_MOBILE);
        if ($this->checkHttpHeadersForMobile()) {
            return true;
        } else {
            return $this->matchDetectionRulesAgainstUA();
        }
    }
    public function isTablet($userAgent = null, $httpHeaders = null)
    {
        if ($this->getUserAgent() === 'Amazon CloudFront') {
            $cfHeaders = $this->getCfHeaders();
            if (array_key_exists('HTTP_CLOUDFRONT_IS_TABLET_VIEWER', $cfHeaders) && $cfHeaders['HTTP_CLOUDFRONT_IS_TABLET_VIEWER'] === 'true') {
                return true;
            }
        }
        $this->setDetectionType(self::DETECTION_TYPE_MOBILE);
        foreach (self::$tabletDevices as $_regex) {
            if ($this->match($_regex, $userAgent)) {
                return true;
            }
        }
        return false;
    }
    public function is($key, $userAgent = null, $httpHeaders = null)
    {
        if ($httpHeaders) {
            $this->setHttpHeaders($httpHeaders);
        }
        if ($userAgent) {
            $this->setUserAgent($userAgent);
        }
        $this->setDetectionType(self::DETECTION_TYPE_EXTENDED);
        return $this->matchUAAgainstKey($key);
    }
    public function match($regex, $userAgent = null)
    {
        $match = (bool) preg_match(sprintf('#%s#is', $regex), false === empty($userAgent) ? $userAgent : $this->userAgent, $matches);
        if ($match) {
            $this->matchingRegex = $regex;
            $this->matchesArray = $matches;
        }
        return $match;
    }
    public static function getProperties()
    {
        return self::$properties;
    }
    public function prepareVersionNo($ver)
    {
        $ver = str_replace(array('_', ' ', '/'), '.', $ver);
        $arrVer = explode('.', $ver, 2);
        if (isset($arrVer[1])) {
            $arrVer[1] = @str_replace('.', '', $arrVer[1]);
        }
        return (double) implode('.', $arrVer);
    }
    public function version($propertyName, $type = self::VERSION_TYPE_STRING)
    {
        if (empty($propertyName)) {
            return false;
        }
        if ($type !== self::VERSION_TYPE_STRING && $type !== self::VERSION_TYPE_FLOAT) {
            $type = self::VERSION_TYPE_STRING;
        }
        $properties = self::getProperties();
        if (true === isset($properties[$propertyName])) {
            $properties[$propertyName] = (array) $properties[$propertyName];
            foreach ($properties[$propertyName] as $propertyMatchString) {
                $propertyPattern = str_replace('[VER]', self::VER, $propertyMatchString);
                preg_match(sprintf('#%s#is', $propertyPattern), $this->userAgent, $match);
                if (false === empty($match[1])) {
                    $version = $type == self::VERSION_TYPE_FLOAT ? $this->prepareVersionNo($match[1]) : $match[1];
                    return $version;
                }
            }
        }
        return false;
    }
    public function mobileGrade()
    {
        $isMobile = $this->isMobile();
        if ($this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT) >= 4.3 || $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT) >= 4.3 || $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT) >= 4.3 || $this->version('Android', self::VERSION_TYPE_FLOAT) > 2.1 && $this->is('Webkit') || $this->version('Windows Phone OS', self::VERSION_TYPE_FLOAT) >= 7.5 || $this->is('BlackBerry') && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) >= 6.0 || $this->match('Playbook.*Tablet') || $this->version('webOS', self::VERSION_TYPE_FLOAT) >= 1.4 && $this->match('Palm|Pre|Pixi') || $this->match('hp.*TouchPad') || $this->is('Firefox') && $this->version('Firefox', self::VERSION_TYPE_FLOAT) >= 18 || $this->is('Chrome') && $this->is('AndroidOS') && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 4.0 || $this->is('Skyfire') && $this->version('Skyfire', self::VERSION_TYPE_FLOAT) >= 4.1 && $this->is('AndroidOS') && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 || $this->is('Opera') && $this->version('Opera Mobi', self::VERSION_TYPE_FLOAT) >= 11.5 && $this->is('AndroidOS') || $this->is('MeeGoOS') || $this->is('Tizen') || $this->is('Dolfin') && $this->version('Bada', self::VERSION_TYPE_FLOAT) >= 2.0 || ($this->is('UC Browser') || $this->is('Dolfin')) && $this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 || ($this->match('Kindle Fire') || $this->is('Kindle') && $this->version('Kindle', self::VERSION_TYPE_FLOAT) >= 3.0) || $this->is('AndroidOS') && $this->is('NookTablet') || $this->version('Chrome', self::VERSION_TYPE_FLOAT) >= 16 && !$isMobile || $this->version('Safari', self::VERSION_TYPE_FLOAT) >= 5.0 && !$isMobile || $this->version('Firefox', self::VERSION_TYPE_FLOAT) >= 10.0 && !$isMobile || $this->version('IE', self::VERSION_TYPE_FLOAT) >= 7.0 && !$isMobile || $this->version('Opera', self::VERSION_TYPE_FLOAT) >= 10 && !$isMobile) {
            return self::MOBILE_GRADE_A;
        }
        if ($this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT) < 4.3 || $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT) < 4.3 || $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT) < 4.3 || $this->is('Blackberry') && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) >= 5 && $this->version('BlackBerry', self::VERSION_TYPE_FLOAT) < 6 || $this->version('Opera Mini', self::VERSION_TYPE_FLOAT) >= 5.0 && $this->version('Opera Mini', self::VERSION_TYPE_FLOAT) <= 7.0 && ($this->version('Android', self::VERSION_TYPE_FLOAT) >= 2.3 || $this->is('iOS')) || $this->match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') || $this->version('Opera Mobi', self::VERSION_TYPE_FLOAT) >= 11 && $this->is('SymbianOS')) {
            return self::MOBILE_GRADE_B;
        }
        if ($this->version('BlackBerry', self::VERSION_TYPE_FLOAT) <= 5.0 || $this->match('MSIEMobile|Windows CE.*Mobile') || $this->version('Windows Mobile', self::VERSION_TYPE_FLOAT) <= 5.2 || $this->is('iOS') && $this->version('iPad', self::VERSION_TYPE_FLOAT) <= 3.2 || $this->is('iOS') && $this->version('iPhone', self::VERSION_TYPE_FLOAT) <= 3.2 || $this->is('iOS') && $this->version('iPod', self::VERSION_TYPE_FLOAT) <= 3.2 || $this->version('IE', self::VERSION_TYPE_FLOAT) <= 7.0 && !$isMobile) {
            return self::MOBILE_GRADE_C;
        }
        return self::MOBILE_GRADE_C;
    }
}
}

namespace Royalcms\Component\Agent {
use Royalcms\Component\Support\ServiceProvider;
class AgentServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms['agent'] = $this->royalcms->share(function ($royalcms) {
            return new Agent($royalcms['request']->server->all());
        });
        $this->loadAlias();
    }
    protected function loadAlias()
    {
        $this->royalcms->booting(function () {
            $loader = \Royalcms\Component\Foundation\AliasLoader::getInstance();
            $loader->alias('RC_Agent', 'Royalcms\\Component\\Agent\\Facades\\Agent');
        });
    }
    public function provides()
    {
        return array('agent');
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/agent');
        return [$dir . "/Facades/Agent.php", $dir . "/Agent.php", $dir . "/MobileDetect.php", $dir . "/AgentServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Storage\Contracts {
interface StorageInterface
{
    public function chown($file, $owner, $recursive = false);
    public function connect();
    public function move_uploaded_file($filename, $destination);
    public function get_contents($file);
    public function get_contents_array($file);
    public function put_contents($file, $contents, $mode = 0644);
    public function cwd();
    public function chdir($dir);
    public function chgrp($file, $group, $recursive = false);
    public function chmod($file, $mode = 0644, $recursive = false);
    public function owner($file);
    public function group($file);
    public function copy_file($source, $destination, $overwrite = false, $mode = 0644);
    public function move_file($source, $destination, $overwrite = false, $mode = 0644);
    public function delete_all($file, $recursive = false, $type = false);
    public function exists($file);
    public function is_file($file);
    public function is_dir($path);
    public function is_readable($file);
    public function is_writable($file);
    public function atime($file);
    public function mtime($file);
    public function size($file);
    public function touch($file, $time = 0, $atime = 0);
    public function mkdir($path, $chmod = false, $chown = false, $chgrp = false);
    public function rmdir($path, $recursive = false);
    public function dirlist($path, $include_hidden = true, $recursive = false);
    public function filelist($path, $allowFiles, $start, $size);
}
}

namespace Royalcms\Component\Storage\Adapter {
use Royalcms\Component\Storage\Contracts\StorageInterface;
use Royalcms\Component\Storage\FilesystemBaseTrait;
use Royalcms\Component\Support\Format;
use Royalcms\Component\Error\Error;
use Royalcms\Component\Aliyun\OSS\Exceptions\OSSException;
use Royalcms\Component\Aliyun\AliyunOSS as OSS;
use League\Flysystem\Config;
use League\Flysystem\Adapter\AbstractAdapter;
class Aliyunoss extends AbstractAdapter implements StorageInterface
{
    use FilesystemBaseTrait;
    protected $errors;
    protected $options = array();
    private $aliyunClient;
    private $bucket;
    private $acl;
    public function __construct($arg)
    {
        $this->options = $arg;
        $this->method = 'aliyunoss';
        $this->errors = new Error();
        $this->bucket = $this->options['bucket'];
        $this->acl = $this->options['acl'] ? $this->options['acl'] : 'public-read';
        $this->connect();
    }
    public function connect()
    {
        $serverAddress = $this->options['is_internal'] ? $this->options['server_internal'] : $this->options['server'];
        $this->aliyunClient = OSS::boot($serverAddress, $this->options['key'], $this->options['secret']);
        $this->aliyunClient->setBucket($this->options['bucket']);
        return true;
    }
    public function getBucket()
    {
        return $this->bucket;
    }
    public function getUrl($path)
    {
        if ($path) {
            $path = '/' . ltrim($path, '\\/');
        }
        return $this->options['url'] . $path;
    }
    private function getHeader($path)
    {
        try {
            $object = $this->aliyunClient->getObjectMetadata($path);
            $metadata = $object->getMetadata();
            return $metadata;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function write($path, $contents, Config $config)
    {
        try {
            $this->aliyunClient->uploadContent($path, $contents);
            return true;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function writeStream($path, $resource, Config $config)
    {
        $contents = stream_get_contents($resource);
        try {
            $this->aliyunClient->uploadContent($path, $contents);
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
        if (is_resource($resource)) {
            fclose($resource);
        }
        return true;
    }
    public function update($path, $contents, Config $config)
    {
        try {
            $this->aliyunClient->uploadContent($path, $contents);
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
        return true;
    }
    public function updateStream($path, $resource, Config $config)
    {
        $contents = stream_get_contents($resource);
        try {
            $this->aliyunClient->uploadContent($path, $contents);
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
        return true;
    }
    public function rename($path, $newPath)
    {
        try {
            $this->aliyunClient->copyObject($this->bucket, $path, $this->bucket, $newPath);
            $this->aliyunClient->deleteObject($path);
            return true;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function copy($path, $newPath)
    {
        $path = $this->filterOsskey($path);
        $newPath = $this->filterOsskey($newPath);
        try {
            $this->aliyunClient->copyObject($this->bucket, $path, $this->bucket, $newPath);
            return true;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function delete($path)
    {
        $path = $this->filterOsskey($path);
        try {
            $this->aliyunClient->deleteObject($path);
            return true;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function deleteDir($dirname)
    {
        return false;
    }
    public function createDir($dirName, Config $config)
    {
        return true;
    }
    public function setVisibility($path, $visibility)
    {
        return false;
    }
    public function has($path)
    {
        $metadata = $this->getMetadata($path);
        if ($metadata) {
            return true;
        } else {
            return false;
        }
    }
    public function read($path)
    {
        try {
            $res = $this->aliyunClient->getObject($path);
            return ['contents' => $res->getObjectContent()];
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function readStream($path)
    {
        try {
            $res = $this->aliyunClient->getObject($path);
            $url = $res->getHeader('oss-request-url');
            $handle = fopen($url, 'r');
            return ['stream' => $handle];
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function listContents($directory = '', $recursive = false)
    {
        if ($recursive) {
            $delimiter = '';
        } else {
            $delimiter = '/';
        }
        $prefix = $directory . '/';
        $next_marker = '';
        $maxkeys = 100;
        try {
            $object = $this->aliyunClient->listObjects($prefix, $next_marker, $maxkeys, $delimiter);
            $list = $object->getObjectSummarys();
            return $list;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function getMetadata($path)
    {
        $response = $this->getHeader($path);
        return $response;
    }
    public function getSize($path)
    {
        $response = $this->getHeader($path);
        return ['size' => $response['Content-Length']];
    }
    public function getMimetype($path)
    {
        $response = $this->getHeader($path);
        return ['mimetype' => $response['Content-Type']];
    }
    public function getTimestamp($path)
    {
        $response = $this->getHeader($path);
        return ['timestamp' => $response['Last-Modified']];
    }
    public function getVisibility($path)
    {
        return ['visibility' => $this->acl];
    }
    protected function filterOsskey($file)
    {
        $file = str_replace(\RC_Upload::upload_path(), '', $file);
        $file = str_replace(DS, '/', $file);
        return $file;
    }
    public function getBucketAcl()
    {
        try {
            $objectacl = $this->aliyunClient->getBucketAcl();
            return $objectacl;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    protected function getListObjects($path)
    {
        try {
            $path = $this->filterOsskey($path);
            $object = $this->aliyunClient->listObjects($path);
            $list = $object->getObjectSummarys();
            return $list;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function move_uploaded_file($filename, $destination)
    {
        try {
            return $this->aliyunClient->uploadFile($this->filterOsskey($destination), $filename);
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function get_contents($file)
    {
        $file = $this->filterOsskey($file);
        try {
            return $this->aliyunClient->getObject($file)->getObjectContent();
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function get_contents_array($file)
    {
        $file = $this->filterOsskey($file);
        try {
            $object = $this->aliyunClient->getObject($file);
            return $object;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function put_contents($file, $contents, $mode = false)
    {
        $file = $this->filterOsskey($file);
        try {
            return $this->aliyunClient->uploadContent($file, $contents);
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function cwd()
    {
        return getcwd();
    }
    public function chdir($dir)
    {
        return true;
    }
    public function chgrp($file, $group, $recursive = false)
    {
        return true;
    }
    public function chmod($file, $mode = false, $recursive = false)
    {
        return true;
    }
    public function chown($file, $owner, $recursive = false)
    {
        return true;
    }
    public function owner($file)
    {
        $objectacl = $this->getBucketAcl();
        if ($objectacl) {
            $name = $objectacl->getOwner()->getDisplayName();
            return $name;
        } else {
            return false;
        }
    }
    protected function getchmod($file)
    {
        $objectacl = $this->getBucketAcl();
        if ($objectacl) {
            $grants = $objectacl->getGrants();
            if (in_array('public-read', $grants)) {
                return false;
            }
            return 755;
        } else {
            return false;
        }
    }
    public function group($file)
    {
        $objectacl = $this->getBucketAcl();
        if ($objectacl) {
            $name = $objectacl->getOwner()->getDisplayName();
            return $name;
        } else {
            return false;
        }
    }
    public function copy_file($source, $destination, $overwrite = false, $mode = false)
    {
        if (!$overwrite && $this->exists($destination)) {
            return false;
        }
        $source = $this->filterOsskey($source);
        $destination = $this->filterOsskey($destination);
        try {
            if ($this->exists($source)) {
                $rtval = $this->aliyunClient->copyObject(null, $source, null, $destination);
            } else {
                $rtval = $this->aliyunClient->uploadFile($destination, $source);
            }
            return $rtval;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function move_file($source, $destination, $overwrite = false, $mode = false)
    {
        if (!$overwrite && $this->exists($destination)) {
            return false;
        }
        $source = $this->filterOsskey($source);
        $destination = $this->filterOsskey($destination);
        try {
            if ($this->exists($source)) {
                $rtval = $this->aliyunClient->moveObject(null, $source, null, $destination);
            } else {
                $rtval = $this->aliyunClient->uploadFile($destination, $source);
            }
            return $rtval;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function delete_all($file, $recursive = false, $type = false)
    {
        if (empty($file)) {
            return false;
        }
        try {
            if ($this->exists($file)) {
                return $this->aliyunClient->deleteObject($this->filterOsskey($file));
            }
            return false;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function exists($path)
    {
        $path = $this->filterOsskey($path);
        return $this->has($path);
    }
    public function is_file($file)
    {
        $file = $this->filterOsskey($file);
        $metadata = $this->getMetadata($file);
        if ($metadata) {
            return true;
        } else {
            return false;
        }
    }
    public function is_dir($path)
    {
        return true;
    }
    public function is_readable($file)
    {
        return true;
    }
    public function is_writable($file)
    {
        $objectacl = $this->getBucketAcl();
        if ($objectacl) {
            $grants = $objectacl->getGrants();
            if (in_array('private', $grants)) {
                return true;
            }
        }
        return false;
    }
    public function atime($file)
    {
        $file = $this->filterOsskey($file);
        $metadata = $this->getMetadata($file);
        if ($metadata) {
            $datetime = $metadata['Last-Modified'];
            $timestamp = $datetime->getTimestamp();
            return $timestamp;
        } else {
            return false;
        }
    }
    public function mtime($file)
    {
        $file = $this->filterOsskey($file);
        $metadata = $this->getMetadata($file);
        if ($metadata) {
            $datetime = $metadata['Last-Modified'];
            $timestamp = $datetime->getTimestamp();
            return $timestamp;
        } else {
            return false;
        }
    }
    public function size($file)
    {
        $file = $this->filterOsskey($file);
        $metadata = $this->getMetadata($file);
        if ($metadata) {
            $filesize = $metadata['Content-Length'];
            return $filesize;
        } else {
            return false;
        }
    }
    public function touch($file, $time = 0, $atime = 0)
    {
        return true;
    }
    public function mkdir($path, $chmod = false, $chown = false, $chgrp = false)
    {
        return true;
    }
    public function rmdir($path, $recursive = false)
    {
        if (empty($path)) {
            return false;
        }
        $path = $this->filterOsskey($path);
        try {
            $path = Format::trailingslashit($path);
            $list = $this->getListObjects($path);
            $all_keys = array();
            foreach ($list as $object) {
                $all_keys[] = $object->getKey();
                $this->delete_all($object->getKey());
            }
            return true;
        } catch (OSSException $e) {
            $this->errors->add($e->getCode(), $e->getMessage());
            return false;
        }
    }
    public function dirlist($path, $include_hidden = true, $recursive = false)
    {
        $list = $this->getListObjects($path);
        if ($list) {
            $ret = array();
            foreach ($list as $object) {
                $this->_dirlist($ret, $object, $path, $object->getKey(), $recursive);
            }
            return $ret;
        } else {
            return false;
        }
    }
    protected function _dirlist(&$ret, $object, $path, $entry, $recursive = false)
    {
        if (rtrim($path) . '/' == $entry) {
            return false;
        }
        if (strpos($entry, '/') !== false) {
            $path = rtrim($path, '/');
            $entry = str_replace($path . '/', '', $entry);
            $dir = $this->rstrstr($entry, '/');
            $path_f = str_replace($dir . '/', '', $entry);
            $struc['name'] = $dir;
            $struc['perms'] = false;
            $struc['permsn'] = false;
            $struc['number'] = false;
            $struc['owner'] = $object->getOwner()->getDisplayName();
            $struc['group'] = $object->getOwner()->getDisplayName();
            $struc['size'] = $object->getSize();
            $struc['lastmodunix'] = $object->getLastModified()->getTimestamp();
            $struc['lastmod'] = date('M j', $struc['lastmodunix']);
            $struc['time'] = date('h:i:s', $struc['lastmodunix']);
            $struc['type'] = 'd';
            if (strpos($path_f, '/') !== false) {
                if ($recursive) {
                    $sub_dir = $this->rstrstr($path_f, '/');
                    $struc_sub = $this->_dirlist($ret[$dir], $object, $path . '/' . $dir, $path_f);
                    if (!isset($struc['files'][$sub_dir])) {
                        $struc['files'][$sub_dir] = $struc_sub;
                    }
                } else {
                    $struc['files'] = array();
                }
            } else {
                $struc_sub = $this->_fileStruct($object);
                if (!isset($ret[$dir])) {
                    $ret[$dir] = $struc;
                }
                if (!isset($ret[$dir]['files'][$path_f])) {
                    $ret[$dir]['files'][$path_f] = $struc_sub;
                }
            }
        } else {
            $struc = $this->_fileStruct($object);
        }
        if (!isset($ret[$struc['name']])) {
            $ret[$struc['name']] = $struc;
        }
    }
    protected function _fileStruct($object)
    {
        $struc['name'] = basename($object->getKey());
        $struc['perms'] = false;
        $struc['permsn'] = false;
        $struc['number'] = false;
        $struc['owner'] = $object->getOwner()->getDisplayName();
        $struc['group'] = $object->getOwner()->getDisplayName();
        $struc['size'] = $object->getSize();
        $struc['lastmodunix'] = $object->getLastModified()->getTimestamp();
        $struc['lastmod'] = date('M j', $struc['lastmodunix']);
        $struc['time'] = date('h:i:s', $struc['lastmodunix']);
        $struc['type'] = 'f';
        return $struc;
    }
    protected function rstrstr($haystack, $needle, $start = 0)
    {
        return substr($haystack, $start, strpos($haystack, $needle));
    }
    public function filelist($path, $allowFiles, $start, $size)
    {
        $end = $start + $size;
        $files = $this->getListObjects($path);
        if (!count($files)) {
            return array();
        }
        $list = array();
        $len = count($files);
        for ($i = min($end, $len) - 1; $i < $len && $i >= 0 && $i >= $start; $i--) {
            if (preg_match('/\\.(' . $allowFiles . ')$/i', $files[$i]->getKey())) {
                $list[] = array('url' => \RC_Upload::upload_url() . '/' . $files[$i]->getKey(), 'mtime' => $files[$i]->getLastModified()->getTimestamp());
            }
        }
        return $list;
    }
}
}

namespace Royalcms\Component\Storage\Adapter {
use League\Flysystem\Util;
use Royalcms\Component\Storage\Contracts\StorageInterface;
use Royalcms\Component\Storage\FilesystemBaseTrait;
use Royalcms\Component\Support\Format as RC_Format;
use Royalcms\Component\Error\Error as RC_Error;
use League\Flysystem\Adapter\Local as LocalAdapter;
class Direct extends LocalAdapter implements StorageInterface
{
    use FilesystemBaseTrait;
    protected $errors;
    public function __construct($root, $writeFlags = LOCK_EX, $linkHandling = self::DISALLOW_LINKS, array $permissions = [])
    {
        parent::__construct($root, $writeFlags, $linkHandling, $permissions);
        $this->method = 'direct';
        $this->errors = new RC_Error();
        if (!defined('FS_CHMOD_DIR')) {
            define('FS_CHMOD_DIR', fileperms(SITE_ROOT) & 0777 | 0755);
        }
        if (!defined('FS_CHMOD_FILE')) {
            define('FS_CHMOD_FILE', fileperms(SITE_ROOT . 'index.php') & 0777 | 0644);
        }
    }
    public function delete($path)
    {
        $path = str_replace($this->getPathPrefix(), '', $path);
        return parent::delete($path);
    }
    public function copy($path, $newpath)
    {
        $path = str_replace($this->getPathPrefix(), '', $path);
        $newpath = str_replace($this->getPathPrefix(), '', $newpath);
        return parent::copy($path, $newpath);
    }
    public function has($path)
    {
        $path = str_replace($this->getPathPrefix(), '', $path);
        return parent::has($path);
    }
    public function connect()
    {
        return true;
    }
    public function move_uploaded_file($filename, $destination)
    {
        return move_uploaded_file($filename, $destination);
    }
    public function get_contents($file)
    {
        return file_get_contents($file);
    }
    public function get_contents_array($file)
    {
        return file($file);
    }
    public function put_contents($file, $contents, $mode = false)
    {
        $fp = fopen($file, 'wb');
        if (!$fp) {
            return false;
        }
        $this->ensureDirectory(dirname($file));
        mbstring_binary_safe_encoding();
        $data_length = strlen($contents);
        $bytes_written = fwrite($fp, $contents);
        reset_mbstring_encoding();
        fclose($fp);
        if ($data_length !== $bytes_written) {
            return false;
        }
        $this->chmod($file, $mode);
        return true;
    }
    public function cwd()
    {
        return getcwd();
    }
    public function chdir($dir)
    {
        return chdir($dir);
    }
    public function chgrp($file, $group, $recursive = false)
    {
        if (!$this->exists($file)) {
            return false;
        }
        if (!$recursive) {
            return chgrp($file, $group);
        }
        if (!$this->is_dir($file)) {
            return chgrp($file, $group);
        }
        $file = RC_Format::trailingslashit($file);
        $filelist = $this->dirlist($file);
        foreach ($filelist as $filename) {
            $this->chgrp($file . $filename, $group, $recursive);
        }
        return true;
    }
    public function chmod($file, $mode = false, $recursive = false)
    {
        if (!$mode) {
            if ($this->is_file($file)) {
                $mode = FS_CHMOD_FILE;
            } elseif ($this->is_dir($file)) {
                $mode = FS_CHMOD_DIR;
            } else {
                return false;
            }
        }
        if (!$recursive || !$this->is_dir($file)) {
            return chmod($file, $mode);
        }
        $file = RC_Format::trailingslashit($file);
        $filelist = $this->dirlist($file);
        foreach ((array) $filelist as $filename => $filemeta) {
            $this->chmod($file . $filename, $mode, $recursive);
        }
        return true;
    }
    public function chown($file, $owner, $recursive = false)
    {
        if (!$this->exists($file)) {
            return false;
        }
        if (!$recursive) {
            return chown($file, $owner);
        }
        if (!$this->is_dir($file)) {
            return chown($file, $owner);
        }
        $filelist = $this->dirlist($file);
        foreach ($filelist as $filename) {
            $this->chown($file . '/' . $filename, $owner, $recursive);
        }
        return true;
    }
    public function owner($file)
    {
        $owneruid = fileowner($file);
        if (!$owneruid) {
            return false;
        }
        if (!function_exists('posix_getpwuid')) {
            return $owneruid;
        }
        $ownerarray = posix_getpwuid($owneruid);
        return $ownerarray['name'];
    }
    protected function getchmod($file)
    {
        return substr(decoct(fileperms($file)), -3);
    }
    public function group($file)
    {
        $gid = filegroup($file);
        if (!$gid) {
            return false;
        }
        if (!function_exists('posix_getgrgid')) {
            return $gid;
        }
        $grouparray = posix_getgrgid($gid);
        return $grouparray['name'];
    }
    public function copy_file($source, $destination, $overwrite = false, $mode = false)
    {
        if (!$overwrite && $this->has($destination)) {
            return false;
        }
        $rtval = copy($source, $destination);
        if ($mode) {
            $this->chmod($destination, $mode);
        }
        return $rtval;
    }
    public function move_file($source, $destination, $overwrite = false, $mode = false)
    {
        if (!$overwrite && $this->has($destination)) {
            return false;
        }
        if ($this->rename($source, $destination)) {
            if ($mode) {
                $this->chmod($destination, $mode);
            }
            return true;
        }
        if ($this->copy_file($source, $destination, $overwrite, $mode) && $this->has($destination)) {
            $this->delete($source);
            return true;
        } else {
            return false;
        }
    }
    public function delete_all($file, $recursive = false, $type = false)
    {
        if (empty($file)) {
            return false;
        }
        $file = str_replace('\\', '/', $file);
        if ('f' == $type || $this->is_file($file)) {
            return unlink($file);
        }
        if (!$recursive && $this->is_dir($file)) {
            return rmdir($file);
        }
        $file = RC_Format::trailingslashit($file);
        $filelist = $this->dirlist($file, true);
        $retval = true;
        if (is_array($filelist)) {
            foreach ($filelist as $filename => $fileinfo) {
                if (!$this->delete_all($file . $filename, $recursive, $fileinfo['type'])) {
                    $retval = false;
                }
            }
        }
        if (file_exists($file) && !rmdir($file)) {
            $retval = false;
        }
        return $retval;
    }
    public function exists($path)
    {
        return $this->has($path);
    }
    public function is_file($path)
    {
        return is_file($path);
    }
    public function is_dir($path)
    {
        return is_dir($path);
    }
    public function is_readable($path)
    {
        return is_readable($path);
    }
    public function is_writable($path)
    {
        return is_writable($path);
    }
    public function atime($path)
    {
        return fileatime($path);
    }
    public function mtime($path)
    {
        return filemtime($path);
    }
    public function size($path)
    {
        return filesize($path);
    }
    public function touch($path, $time = 0, $atime = 0)
    {
        if ($time == 0) {
            $time = time();
        }
        if ($atime == 0) {
            $atime = time();
        }
        return touch($path, $time, $atime);
    }
    public function mkdir($path, $chmod = false, $chown = false, $chgrp = false)
    {
        $path = RC_Format::untrailingslashit($path);
        if (empty($path)) {
            return false;
        }
        if (!$chmod) {
            $chmod = FS_CHMOD_DIR;
        }
        if (!mkdir($path, $chmod, true)) {
            return false;
        }
        $this->chmod($path, $chmod);
        if ($chown) {
            $this->chown($path, $chown);
        }
        if ($chgrp) {
            $this->chgrp($path, $chgrp);
        }
        return true;
    }
    public function rmdir($path, $recursive = false)
    {
        return $this->delete_all($path, $recursive);
    }
    public function dirlist($path, $include_hidden = true, $recursive = false)
    {
        if ($this->is_file($path)) {
            $limit_file = basename($path);
            $path = dirname($path);
        } else {
            $limit_file = false;
        }
        if (!$this->is_dir($path)) {
            return false;
        }
        $dir = dir($path);
        if (!$dir) {
            return false;
        }
        $ret = array();
        while (false !== ($entry = $dir->read())) {
            $struc = array();
            $struc['name'] = $entry;
            if ('.' == $struc['name'] || '..' == $struc['name']) {
                continue;
            }
            if (!$include_hidden && '.' == $struc['name'][0]) {
                continue;
            }
            if ($limit_file && $struc['name'] != $limit_file) {
                continue;
            }
            $struc['perms'] = $this->gethchmod($path . '/' . $entry);
            $struc['permsn'] = $this->getnumchmodfromh($struc['perms']);
            $struc['number'] = false;
            $struc['owner'] = $this->owner($path . '/' . $entry);
            $struc['group'] = $this->group($path . '/' . $entry);
            $struc['size'] = $this->size($path . '/' . $entry);
            $struc['lastmodunix'] = $this->mtime($path . '/' . $entry);
            $struc['lastmod'] = date('M j', $struc['lastmodunix']);
            $struc['time'] = date('h:i:s', $struc['lastmodunix']);
            $struc['type'] = $this->is_dir($path . '/' . $entry) ? 'd' : 'f';
            if ('d' == $struc['type']) {
                if ($recursive) {
                    $struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);
                } else {
                    $struc['files'] = array();
                }
            }
            $ret[$struc['name']] = $struc;
        }
        $dir->close();
        unset($dir);
        return $ret;
    }
    public function filelist($path, $allowFiles, $start, $size)
    {
        $end = $start + $size;
        $files = $this->_getfiles($path, $allowFiles);
        if (!count($files)) {
            return array();
        }
        $len = count($files);
        for ($i = min($end, $len) - 1, $list = array(); $i < $len && $i >= 0 && $i >= $start; $i--) {
            $list[] = $files[$i];
        }
        return $list;
    }
    protected function _getfiles($path, $allowFiles, &$files = array())
    {
        if (!is_dir($path)) {
            return null;
        }
        if (substr($path, strlen($path) - 1) != '/') {
            $path .= '/';
        }
        $handle = opendir($path);
        while (false !== ($file = readdir($handle))) {
            if ($file != '.' && $file != '..') {
                $path2 = $path . $file;
                if (is_dir($path2)) {
                    $this->_getfiles($path2, $allowFiles, $files);
                } else {
                    if (preg_match('/\\.(' . $allowFiles . ')$/i', $file)) {
                        $files[] = array('url' => \RC_Upload::upload_url() . '/' . substr($path2, strlen(\RC_Upload::upload_path())), 'mtime' => filemtime($path2));
                    }
                }
            }
        }
        return $files;
    }
}
}

namespace Royalcms\Component\Storage\Adapter {
class Local extends Direct
{
}
}

namespace Royalcms\Component\Storage {
use InvalidArgumentException;
use League\Flysystem\Directory;
use League\Flysystem\File;
use League\Flysystem\FileNotFoundException;
use League\Flysystem\Filesystem as BaseFilesystem;
use League\Flysystem\Handler;
use League\Flysystem\RootViolationException;
use League\Flysystem\Util;
use League\Flysystem\Util\ContentListingFormatter;
use RC_Log;
use Royalcms\Component\Storage\Contracts\StorageInterface;
use Royalcms\Component\Storage\Exceptions\AdapterNotStorageInterfaceException;
class Filesystem extends BaseFilesystem
{
    public function has($path)
    {
        return strlen($path) === 0 ? false : (bool) $this->getAdapter()->has($path);
    }
    public function write($path, $contents, array $config = [])
    {
        $this->assertAbsent($path);
        $config = $this->prepareConfig($config);
        return (bool) $this->getAdapter()->write($path, $contents, $config);
    }
    public function writeStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $this->assertAbsent($path);
        $config = $this->prepareConfig($config);
        Util::rewindStream($resource);
        return (bool) $this->getAdapter()->writeStream($path, $resource, $config);
    }
    public function put($path, $contents, array $config = [])
    {
        $config = $this->prepareConfig($config);
        if ($this->has($path)) {
            return (bool) $this->getAdapter()->update($path, $contents, $config);
        }
        return (bool) $this->getAdapter()->write($path, $contents, $config);
    }
    public function putStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $config = $this->prepareConfig($config);
        Util::rewindStream($resource);
        if ($this->has($path)) {
            return (bool) $this->getAdapter()->updateStream($path, $resource, $config);
        }
        return (bool) $this->getAdapter()->writeStream($path, $resource, $config);
    }
    public function readAndDelete($path)
    {
        $this->assertPresent($path);
        $contents = $this->read($path);
        if ($contents === false) {
            return false;
        }
        $this->delete($path);
        return $contents;
    }
    public function update($path, $contents, array $config = [])
    {
        $config = $this->prepareConfig($config);
        $this->assertPresent($path);
        return (bool) $this->getAdapter()->update($path, $contents, $config);
    }
    public function updateStream($path, $resource, array $config = [])
    {
        if (!is_resource($resource)) {
            throw new InvalidArgumentException(__METHOD__ . ' expects argument #2 to be a valid resource.');
        }
        $config = $this->prepareConfig($config);
        $this->assertPresent($path);
        Util::rewindStream($resource);
        return (bool) $this->getAdapter()->updateStream($path, $resource, $config);
    }
    public function read($path)
    {
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->read($path))) {
            return false;
        }
        return $object['contents'];
    }
    public function readStream($path)
    {
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->readStream($path))) {
            return false;
        }
        return $object['stream'];
    }
    public function rename($path, $newpath)
    {
        $this->assertPresent($path);
        $this->assertAbsent($newpath);
        return (bool) $this->getAdapter()->rename($path, $newpath);
    }
    public function copy($path, $newpath)
    {
        $this->assertPresent($path);
        $this->assertAbsent($newpath);
        return $this->getAdapter()->copy($path, $newpath);
    }
    public function delete($path)
    {
        try {
            $this->assertPresent($path);
            return $this->getAdapter()->delete($path);
        } catch (FileNotFoundException $e) {
            RC_Log::warning($e);
        }
    }
    public function deleteDir($dirname)
    {
        if ($dirname === '') {
            throw new RootViolationException('Root directories can not be deleted.');
        }
        return (bool) $this->getAdapter()->deleteDir($dirname);
    }
    public function createDir($dirname, array $config = [])
    {
        $config = $this->prepareConfig($config);
        return (bool) $this->getAdapter()->createDir($dirname, $config);
    }
    public function listContents($directory = '', $recursive = false)
    {
        $contents = $this->getAdapter()->listContents($directory, $recursive);
        return (new ContentListingFormatter($directory, $recursive))->formatListing($contents);
    }
    public function getMimetype($path)
    {
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->getMimetype($path))) {
            return false;
        }
        return $object['mimetype'];
    }
    public function getTimestamp($path)
    {
        $this->assertPresent($path);
        if (!($object = $this->getAdapter()->getTimestamp($path))) {
            return false;
        }
        return $object['timestamp'];
    }
    public function getVisibility($path)
    {
        $this->assertPresent($path);
        if (($object = $this->getAdapter()->getVisibility($path)) === false) {
            return false;
        }
        return $object['visibility'];
    }
    public function getSize($path)
    {
        if (($object = $this->getAdapter()->getSize($path)) === false || !isset($object['size'])) {
            return false;
        }
        return (int) $object['size'];
    }
    public function setVisibility($path, $visibility)
    {
        return (bool) $this->getAdapter()->setVisibility($path, $visibility);
    }
    public function getMetadata($path)
    {
        $this->assertPresent($path);
        return $this->getAdapter()->getMetadata($path);
    }
    public function get($path, Handler $handler = null)
    {
        if (!$handler) {
            $metadata = $this->getMetadata($path);
            $handler = $metadata['type'] === 'file' ? new File($this, $path) : new Directory($this, $path);
        }
        $handler->setPath($path);
        $handler->setFilesystem($this);
        return $handler;
    }
    public function assertStorageInterface()
    {
        if (!$this->getAdapter() instanceof StorageInterface) {
            throw new AdapterNotStorageInterfaceException('This adapter not `StorageInterface` instance.');
        }
    }
    public function move_uploaded_file($filename, $destination)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->move_uploaded_file($filename, $destination);
    }
    public function get_contents($file)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->get_contents($file);
    }
    public function get_contents_array($file)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->get_contents_array($file);
    }
    public function put_contents($file, $contents, $mode = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->put_contents($file, $contents, $mode);
    }
    public function cwd()
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->cwd();
    }
    public function chdir($dir)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->chdir($dir);
    }
    public function chgrp($file, $group, $recursive = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->chgrp($file, $group, $recursive);
    }
    public function chmod($file, $mode = false, $recursive = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->chmod($file, $mode, $recursive);
    }
    public function chown($file, $owner, $recursive = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->chmod($file, $owner, $recursive);
    }
    public function owner($file)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->owner($file);
    }
    public function group($file)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->group($file);
    }
    public function move($source, $destination, $overwrite = false, $mode = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->move($source, $destination, $overwrite, $mode);
    }
    public function exists($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->exists($path);
    }
    public function is_file($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->is_file($path);
    }
    public function is_dir($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->is_dir($path);
    }
    public function is_readable($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->is_readable($path);
    }
    public function is_writable($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->is_writable($path);
    }
    public function atime($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->atime($path);
    }
    public function mtime($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->mtime($path);
    }
    public function size($path)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->size($path);
    }
    public function touch($path, $time = 0, $atime = 0)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->touch($path, $time, $atime);
    }
    public function mkdir($path, $chmod = false, $chown = false, $chgrp = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->mkdir($path, $chmod, $chown, $chgrp);
    }
    public function rmdir($path, $recursive = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->rmdir($path, $recursive);
    }
    public function dirlist($path, $include_hidden = true, $recursive = false)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->dirlist($path, $include_hidden, $recursive);
    }
    public function filelist($path, $allowFiles, $start, $size)
    {
        $this->assertStorageInterface();
        return $this->getAdapter()->filelist($path, $allowFiles, $start, $size);
    }
}
}

namespace Royalcms\Component\Storage {
use Royalcms\Component\Support\Traits\Macroable;
use Royalcms\Component\Filesystem\FilesystemAdapter as BaseFilesystemAdapter;
class FilesystemAdapter extends BaseFilesystemAdapter
{
    use Macroable {
        __call as private __macroableCall;
    }
    public function exists($path)
    {
        return $this->driver->exists($path);
    }
    public function __call($method, array $parameters)
    {
        if (!static::hasMacro($method)) {
            if (method_exists($this->driver, $method)) {
                return call_user_func_array([$this->driver, $method], $parameters);
            } else {
                return parent::__call($method, $parameters);
            }
        }
        return $this->__macroableCall($method, $parameters);
    }
}
}

namespace Royalcms\Component\Storage {
use Royalcms\Component\Support\Format;
use Royalcms\Component\Foundation\Theme;
trait FilesystemBaseTrait
{
    public $verbose = false;
    private $cache = array();
    protected $method = '';
    public function abspath()
    {
        $folder = $this->find_folder(ABSPATH);
        if (!$folder && $this->is_dir('/wp-includes')) {
            $folder = '/';
        }
        return $folder;
    }
    public function rc_content_dir()
    {
        return $this->find_folder(RC_CONTENT_PATH);
    }
    public function rc_plugins_dir()
    {
        return $this->find_folder(RC_PLUGIN_PATH);
    }
    public function rc_themes_dir($theme = false)
    {
        $theme_root = Theme::get_theme_root($theme);
        if ('/themes' == $theme_root || !is_dir($theme_root)) {
            $theme_root = RC_CONTENT_PATH . $theme_root;
        }
        return $this->find_folder($theme_root);
    }
    public function rc_lang_dir()
    {
        return $this->find_folder(RC_LANG_PATH);
    }
    public function find_base_dir($base = '.', $echo = false)
    {
        _deprecated_function(__FUNCTION__, '3.8', '\\Royalcms\\Component\\Storage\\FilesystemBase::abspath() or \\Royalcms\\Component\\Storage\\FilesystemBase::rc_*_dir()');
        $this->verbose = $echo;
        return $this->abspath();
    }
    public function get_base_dir($base = '.', $echo = false)
    {
        _deprecated_function(__FUNCTION__, '3.8', '\\Royalcms\\Component\\Storage::abspath() or \\Royalcms\\Component\\Storage\\FilesystemBase::rc_*_dir()');
        $this->verbose = $echo;
        return $this->abspath();
    }
    public function find_folder($folder)
    {
        if (isset($this->cache[$folder])) {
            return $this->cache[$folder];
        }
        if (stripos($this->method, 'ftp') !== false) {
            $constant_overrides = array('FTP_BASE' => SITE_ROOT, 'FTP_CONTENT_DIR' => RC_CONTENT_PATH, 'FTP_PLUGIN_DIR' => RC_PLUGIN_PATH, 'FTP_LANG_DIR' => RC_LANG_PTAH);
            foreach ($constant_overrides as $constant => $dir) {
                if (!defined($constant)) {
                    continue;
                }
                if ($folder === $dir) {
                    return Format::trailingslashit(constant($constant));
                }
            }
            foreach ($constant_overrides as $constant => $dir) {
                if (!defined($constant)) {
                    continue;
                }
                if (0 === stripos($folder, $dir)) {
                    $potential_folder = preg_replace('#^' . preg_quote($dir, '#') . '/#i', Format::trailingslashit(constant($constant)), $folder);
                    $potential_folder = Format::trailingslashit($potential_folder);
                    if ($this->is_dir($potential_folder)) {
                        $this->cache[$folder] = $potential_folder;
                        return $potential_folder;
                    }
                }
            }
        } elseif ('direct' == $this->method) {
            $folder = str_replace('\\', '/', $folder);
            return Format::trailingslashit($folder);
        }
        $folder = preg_replace('|^([a-z]{1}):|i', '', $folder);
        $folder = str_replace('\\', '/', $folder);
        if (isset($this->cache[$folder])) {
            return $this->cache[$folder];
        }
        if ($this->exists($folder)) {
            $folder = Format::trailingslashit($folder);
            $this->cache[$folder] = $folder;
            return $folder;
        }
        if (($return = $this->search_for_folder($folder)) !== false) {
            $this->cache[$folder] = $return;
        }
        return $return;
    }
    public function search_for_folder($folder, $base = '.', $loop = false)
    {
        if (empty($base) || '.' == $base) {
            $base = Format::trailingslashit($this->cwd());
        }
        $folder = Format::untrailingslashit($folder);
        if ($this->verbose) {
            printf("\n" . __('Looking for %1$s in %2$s') . "<br/>\n", $folder, $base);
        }
        $folder_parts = explode('/', $folder);
        $folder_part_keys = array_keys($folder_parts);
        $last_index = array_pop($folder_part_keys);
        $last_path = $folder_parts[$last_index];
        $files = $this->dirlist($base);
        foreach ($folder_parts as $index => $key) {
            if ($index == $last_index) {
                continue;
            }
            if (isset($files[$key])) {
                $newdir = Format::trailingslashit(Format::path_join($base, $key));
                if ($this->verbose) {
                    printf("\n" . __('Changing to %s') . "<br/>\n", $newdir);
                }
                $newfolder = implode('/', array_slice($folder_parts, $index + 1));
                if (($ret = $this->search_for_folder($newfolder, $newdir, $loop)) !== false) {
                    return $ret;
                }
            }
        }
        if (isset($files[$last_path])) {
            if ($this->verbose) {
                printf("\n" . __('Found %s') . "<br/>\n", $base . $last_path);
            }
            return Format::trailingslashit($base . $last_path);
        }
        if ($loop || '/' == $base) {
            return false;
        }
        return $this->search_for_folder($folder, '/', true);
    }
    public function gethchmod($file)
    {
        $perms = $this->getchmod($file);
        if (($perms & 0xc000) == 0xc000) {
            $info = 's';
        } elseif (($perms & 0xa000) == 0xa000) {
            $info = 'l';
        } elseif (($perms & 0x8000) == 0x8000) {
            $info = '-';
        } elseif (($perms & 0x6000) == 0x6000) {
            $info = 'b';
        } elseif (($perms & 0x4000) == 0x4000) {
            $info = 'd';
        } elseif (($perms & 0x2000) == 0x2000) {
            $info = 'c';
        } elseif (($perms & 0x1000) == 0x1000) {
            $info = 'p';
        } else {
            $info = 'u';
        }
        $info .= $perms & 0x100 ? 'r' : '-';
        $info .= $perms & 0x80 ? 'w' : '-';
        $info .= $perms & 0x40 ? $perms & 0x800 ? 's' : 'x' : ($perms & 0x800 ? 'S' : '-');
        $info .= $perms & 0x20 ? 'r' : '-';
        $info .= $perms & 0x10 ? 'w' : '-';
        $info .= $perms & 0x8 ? $perms & 0x400 ? 's' : 'x' : ($perms & 0x400 ? 'S' : '-');
        $info .= $perms & 0x4 ? 'r' : '-';
        $info .= $perms & 0x2 ? 'w' : '-';
        $info .= $perms & 0x1 ? $perms & 0x200 ? 't' : 'x' : ($perms & 0x200 ? 'T' : '-');
        return $info;
    }
    public function getnumchmodfromh($mode)
    {
        $realmode = '';
        $legal = array('', 'w', 'r', 'x', '-');
        $attarray = preg_split('//', $mode);
        for ($i = 0; $i < count($attarray); $i++) {
            if (($key = array_search($attarray[$i], $legal)) !== false) {
                $realmode .= $legal[$key];
            }
        }
        $mode = str_pad($realmode, 10, '-', STR_PAD_LEFT);
        $trans = array('-' => '0', 'r' => '4', 'w' => '2', 'x' => '1');
        $mode = strtr($mode, $trans);
        $newmode = $mode[0];
        $newmode .= $mode[1] + $mode[2] + $mode[3];
        $newmode .= $mode[4] + $mode[5] + $mode[6];
        $newmode .= $mode[7] + $mode[8] + $mode[9];
        return $newmode;
    }
    private function is_binary($text)
    {
        return (bool) preg_match('|[^\\x20-\\x7E]|', $text);
    }
}
}

namespace Royalcms\Component\Storage {
use Royalcms\Component\Storage\Adapter\Local;
use Royalcms\Component\Storage\Adapter\Direct;
use Royalcms\Component\Storage\Adapter\Aliyunoss;
use League\Flysystem\FilesystemInterface;
use League\Flysystem\Adapter\AbstractAdapter;
use Royalcms\Component\Support\Arr;
use Royalcms\Component\Filesystem\FilesystemManager as BaseFilesystemManager;
class FilesystemManager extends BaseFilesystemManager
{
    public function createDirectDriver(array $config)
    {
        $links = Arr::get($config, 'links') === 'skip' ? Direct::SKIP_LINKS : Direct::DISALLOW_LINKS;
        $permissions = isset($config['permissions']) ? $config['permissions'] : [];
        return $this->adapt($this->createFilesystem(new Direct($config['root'], LOCK_EX, $links, $permissions), $config));
    }
    public function createLocalDriver(array $config)
    {
        $links = Arr::get($config, 'links') === 'skip' ? Local::SKIP_LINKS : Local::DISALLOW_LINKS;
        $permissions = isset($config['permissions']) ? $config['permissions'] : [];
        return $this->adapt($this->createFilesystem(new Local($config['root'], LOCK_EX, $links, $permissions), $config));
    }
    public function createAliyunossDriver(array $config)
    {
        $ossConfig = array_only($config, array('key', 'secret', 'bucket', 'server', 'server_internal', 'is_internal', 'url'));
        return $this->adapt($this->createFilesystem(new Aliyunoss($ossConfig), $ossConfig));
    }
    protected function createFilesystem(AbstractAdapter $adapter, array $config)
    {
        $config = Arr::only($config, ['visibility', 'disable_asserts']);
        return new Filesystem($adapter, count($config) > 0 ? $config : null);
    }
    protected function adapt(FilesystemInterface $filesystem)
    {
        return new FilesystemAdapter($filesystem);
    }
    protected function getConfig($name)
    {
        return $this->royalcms['config']["storage.disks.{$name}"];
    }
    public function getDefaultDriver()
    {
        return $this->royalcms['config']['storage.default'];
    }
}
}

namespace Royalcms\Component\Storage\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Storage extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'storage';
    }
}
}

namespace Royalcms\Component\Storage {
use Royalcms\Component\Support\ServiceProvider;
class StorageServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->mergeConfigFrom($this->guessPackagePath('royalcms/storage') . '/config/storage.php', 'storage');
        $this->registerManager();
        $this->royalcms->bindShared('storage.disk', function ($royalcms) {
            return $royalcms['storage']->disk($this->getDefaultDriver());
        });
        $this->royalcms->bindShared('storage.cloud', function ($royalcms) {
            return $royalcms['storage']->disk($this->getCloudDriver());
        });
    }
    protected function registerManager()
    {
        $this->royalcms->bindShared('storage', function ($royalcms) {
            return new FilesystemManager($royalcms);
        });
    }
    protected function getDefaultDriver()
    {
        return $this->royalcms['config']['filesystems.default'];
    }
    protected function getCloudDriver()
    {
        return $this->royalcms['config']['filesystems.cloud'];
    }
    public function provides()
    {
        return ['storage'];
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/storage');
        return [$dir . "/Contracts/StorageInterface.php", $dir . "/Adapter/Aliyunoss.php", $dir . "/Adapter/Direct.php", $dir . "/Adapter/Local.php", $dir . "/Filesystem.php", $dir . "/FilesystemAdapter.php", $dir . "/FilesystemBaseTrait.php", $dir . "/FilesystemManager.php", $dir . "/Facades/Storage.php", $dir . "/StorageServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Environment\Facades {
use Royalcms\Component\Support\Facades\Facade;
use RC_Hook;
class Environment extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'phpinfo';
    }
    public static function gd_version()
    {
        static $version = -1;
        if ($version >= 0) {
            return $version;
        }
        if (!extension_loaded('gd')) {
            $version = 0;
        } else {
            if (PHP_VERSION >= '4.3') {
                if (function_exists('gd_info')) {
                    $ver_info = gd_info();
                    preg_match('/\\d/', $ver_info['GD Version'], $match);
                    $version = $match[0];
                } else {
                    if (function_exists('imagecreatetruecolor')) {
                        $version = 2;
                    } elseif (function_exists('imagecreate')) {
                        $version = 1;
                    }
                }
            } else {
                if (preg_match('/phpinfo/', ini_get('disable_functions'))) {
                    $version = 1;
                } else {
                    ob_start();
                    phpinfo(8);
                    $info = ob_get_contents();
                    ob_end_clean();
                    $info = stristr($info, 'gd version');
                    preg_match('/\\d/', $info, $match);
                    $version = $match[0];
                }
            }
        }
        return $version;
    }
    public static function get_os()
    {
        if (empty($_SERVER['HTTP_USER_AGENT'])) {
            return 'Unknown';
        }
        $agent = strtolower($_SERVER['HTTP_USER_AGENT']);
        $os = '';
        if (strpos($agent, 'win') !== false) {
            if (strpos($agent, 'nt 5.1') !== false) {
                $os = 'Windows XP';
            } elseif (strpos($agent, 'nt 5.2') !== false) {
                $os = 'Windows 2003';
            } elseif (strpos($agent, 'nt 5.0') !== false) {
                $os = 'Windows 2000';
            } elseif (strpos($agent, 'nt 6.0') !== false) {
                $os = 'Windows Vista';
            } elseif (strpos($agent, 'nt') !== false) {
                $os = 'Windows NT';
            } elseif (strpos($agent, 'win 9x') !== false && strpos($agent, '4.90') !== false) {
                $os = 'Windows ME';
            } elseif (strpos($agent, '98') !== false) {
                $os = 'Windows 98';
            } elseif (strpos($agent, '95') !== false) {
                $os = 'Windows 95';
            } elseif (strpos($agent, '32') !== false) {
                $os = 'Windows 32';
            } elseif (strpos($agent, 'ce') !== false) {
                $os = 'Windows CE';
            }
        } elseif (strpos($agent, 'linux') !== false) {
            $os = 'Linux';
        } elseif (strpos($agent, 'unix') !== false) {
            $os = 'Unix';
        } elseif (strpos($agent, 'sun') !== false && strpos($agent, 'os') !== false) {
            $os = 'SunOS';
        } elseif (strpos($agent, 'ibm') !== false && strpos($agent, 'os') !== false) {
            $os = 'IBM OS/2';
        } elseif (strpos($agent, 'mac') !== false && strpos($agent, 'pc') !== false) {
            $os = 'Macintosh';
        } elseif (strpos($agent, 'powerpc') !== false) {
            $os = 'PowerPC';
        } elseif (strpos($agent, 'aix') !== false) {
            $os = 'AIX';
        } elseif (strpos($agent, 'hpux') !== false) {
            $os = 'HPUX';
        } elseif (strpos($agent, 'netbsd') !== false) {
            $os = 'NetBSD';
        } elseif (strpos($agent, 'bsd') !== false) {
            $os = 'BSD';
        } elseif (strpos($agent, 'osf1') !== false) {
            $os = 'OSF1';
        } elseif (strpos($agent, 'irix') !== false) {
            $os = 'IRIX';
        } elseif (strpos($agent, 'freebsd') !== false) {
            $os = 'FreeBSD';
        } elseif (strpos($agent, 'teleport') !== false) {
            $os = 'teleport';
        } elseif (strpos($agent, 'flashget') !== false) {
            $os = 'flashget';
        } elseif (strpos($agent, 'webzip') !== false) {
            $os = 'webzip';
        } elseif (strpos($agent, 'offline') !== false) {
            $os = 'offline';
        } else {
            $os = 'Unknown';
        }
        return $os;
    }
    public static function gzip_enabled()
    {
        static $enabled_gzip = null;
        if ($enabled_gzip === null) {
            $enabled_gzip = function_exists('ob_gzhandler');
        }
        return RC_Hook::apply_filters('gzip_enabled', $enabled_gzip);
    }
}
}

namespace Royalcms\Component\Environment {
use Royalcms\Component\Support\ServiceProvider;
class EnvironmentServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->royalcms->bindShared('phpinfo', function ($royalcms) {
            return new Phpinfo();
        });
    }
    public function provides()
    {
        return array('phpinfo');
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/environment');
        return [$dir . "/Facades/Environment.php", $dir . "/EnvironmentServiceProvider.php"];
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
use RC_Format;
use RC_Storage;
use Royalcms\Component\Upload\UploaderAbstract;
use Royalcms\Component\Upload\Facades\Upload;
use Royalcms\Component\Upload\Process\UploadProcess;
use Royalcms\Component\Upload\Process\NewUploadProcess;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Royalcms\Component\Http\Request;
class Uploader extends UploaderAbstract
{
    protected $filename_callback;
    protected $sub_dirname_callback;
    protected $upload_success_callback;
    protected $upload_saving_callback;
    protected $default_filetypes = array();
    protected $request;
    public function __construct()
    {
        parent::__construct();
        $this->options['root_path'] = Upload::upload_path();
        $this->options['max_size'] = config('upload.max_size');
        $this->settingUploadConfig();
    }
    public function setRequest(Request $request)
    {
        $this->request = $request;
    }
    public function getRequest()
    {
        if (is_null($this->request)) {
            $this->request = royalcms('request');
        }
        return $this->request;
    }
    protected function settingUploadConfig()
    {
        $default_file_types = config('upload.default_file_types');
        $file_ext = array_keys($default_file_types);
        $this->allowed_type($file_ext);
        $file_mime = array_values($default_file_types);
        $this->allowed_mime($file_mime);
        if (!empty($this->mimes)) {
            $this->mimes = array_map('strtolower', $this->mimes);
        }
        if (!empty($this->exts)) {
            $this->exts = array_map('strtolower', $this->exts);
        }
    }
    public function upload($file, $callback = null)
    {
        if (empty($file)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $file = $this->fixPhpFilesArray($file);
        if (isset($file['name'])) {
            $info = (new UploadProcess($this))->upload($file, $callback);
        } else {
            $info = $this->batchUpload($file, $callback);
        }
        return empty($info) ? false : $info;
    }
    public function batchUpload(array $files, $callback = null)
    {
        if (empty($files)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $info = array();
        $files = $this->fixPhpFilesArray($files);
        foreach ($files as $key => $file) {
            $info[$key] = (new UploadProcess($this))->upload($file, $callback);
        }
        return empty($info) ? false : $info;
    }
    public function checkedUploadFile($upload_file)
    {
        if (!$upload_file instanceof UploadedFile) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        if (!$upload_file->isValid()) {
            $this->add_error('is_uploaded_file_by_tmp_name', __('', 'royalcms-upload'));
            return false;
        }
        if (!$this->check_size($upload_file->getClientSize())) {
            $this->add_error('upload_file_size_not_match', __('', 'royalcms-upload'));
            return false;
        }
        if (!$this->check_mime($upload_file->getClientMimeType())) {
            $this->add_error('upload_file_mime_not_match', __('MIME', 'royalcms-upload'));
            return false;
        }
        if (!$this->check_ext($upload_file->getClientOriginalExtension())) {
            $this->add_error('upload_file_ext_not_match', __('', 'royalcms-upload'));
            return false;
        }
        return true;
    }
    public function multiUpload($files = null, $callback = null)
    {
        if (is_null($files)) {
            $files = $_FILES;
        }
        foreach ($files as $key => $file) {
            $info[$key] = $this->batchUpload($file);
        }
        return empty($info) ? false : $info;
    }
    public function multiUploadByFiles($callback = null)
    {
        $files = $_FILES;
        foreach ($files as $key => $file) {
            $info[$key] = $this->batchUpload($file);
        }
        return empty($info) ? false : $info;
    }
    public function batch_upload($files = null)
    {
        if (is_null($files)) {
            $files = $_FILES;
        }
        $count = count($files);
        $info = array();
        if ($count === 1) {
            foreach ($files as $key => $file) {
                $info = $this->batchUpload($file);
            }
        } else {
            $info = $this->multiUploadByFiles();
        }
        return empty($info) ? false : $info;
    }
    public function check_upload_file($file)
    {
        if ($file instanceof UploadedFile) {
            $upload_file = $file;
        } elseif (is_array($file) && isset($file['name'])) {
            $upload_file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error']);
        } else {
            $upload_file = $this->getRequest()->file($file);
        }
        return $this->checkedUploadFile($upload_file);
    }
    public function get_position($info, $relative = true)
    {
        $position = RC_Format::trailingslashit($info['savepath']) . $info['savename'];
        if (!$relative) {
            return RC_Format::trailingslashit($this->root_path) . $position;
        } else {
            return $position;
        }
    }
    public function remove($file)
    {
        $file_path = RC_Format::path_join(RC_Format::trailingslashit($this->root_path), $file);
        return RC_Storage::disk()->delete($file_path);
    }
    private static $fileKeys = array('error', 'name', 'size', 'tmp_name', 'type');
    protected function fixPhpFilesArray($data)
    {
        if (!is_array($data)) {
            return $data;
        }
        $keys = array_keys($data);
        sort($keys);
        if (self::$fileKeys != $keys || !isset($data['name']) || !is_array($data['name'])) {
            return $data;
        }
        $files = $data;
        foreach (self::$fileKeys as $k) {
            unset($files[$k]);
        }
        foreach ($data['name'] as $key => $name) {
            $files[$key] = $this->fixPhpFilesArray(array('error' => $data['error'][$key], 'name' => $name, 'type' => $data['type'][$key], 'tmp_name' => $data['tmp_name'][$key], 'size' => $data['size'][$key]));
        }
        return $files;
    }
    protected function format_files($files)
    {
        $file_arr = array();
        $n = 0;
        foreach ($files as $key => $file) {
            if (is_array($file['name'])) {
                $keys = array_keys($file);
                $count = count($file['name']);
                for ($i = 0; $i < $count; $i++) {
                    $file_arr[$n]['key'] = $key;
                    foreach ($keys as $_key) {
                        $file_arr[$n][$_key] = $file[$_key][$i];
                    }
                    $n++;
                }
            } else {
                $file_arr = $files;
                break;
            }
        }
        return $file_arr;
    }
    public function add_filename_callback($callback)
    {
        if (is_callable($callback)) {
            $this->filename_callback = $callback;
        }
    }
    public function add_sub_dirname_callback($callback)
    {
        if (is_callable($callback)) {
            $this->sub_dirname_callback = $callback;
        }
    }
    public function add_upload_success_callback($callback)
    {
        if (is_callable($callback)) {
            $this->upload_success_callback = $callback;
        }
    }
    public function add_saving_callback($callback)
    {
        if (is_callable($callback)) {
            $this->upload_saving_callback = $callback;
        }
    }
    public function generateFilename($filename, $extname = null)
    {
        if (is_callable($this->filename_callback)) {
            $savename = call_user_func($this->filename_callback, $filename);
        } else {
            $savename = substr(pathinfo("_{$filename}", PATHINFO_FILENAME), 1);
        }
        $extname = empty($this->save_ext) ? $extname : $this->save_ext;
        if (empty($extname)) {
            return $savename;
        }
        return $savename . '.' . $extname;
    }
    public function generateSubDirname($filename)
    {
        if ($this->auto_sub_dirs && is_callable($this->sub_dirname_callback)) {
            return call_user_func($this->sub_dirname_callback, $filename);
        } else {
            return '';
        }
    }
    public function uploadedSuccessProcess($file)
    {
        if (is_callable($this->upload_success_callback)) {
            return call_user_func($this->upload_success_callback, $file);
        }
        return false;
    }
    public function getUploadSavingCallback()
    {
        return $this->upload_saving_callback;
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
use Royalcms\Component\Upload\Process\NewUploadProcess;
use Symfony\Component\HttpFoundation\File\UploadedFile;
class NewUploader extends Uploader
{
    public function upload($file, $callback = null)
    {
        if (!$this->getRequest()->hasFile($file)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $info = (new NewUploadProcess($this))->upload($file, $callback);
        return empty($info) ? false : $info;
    }
    public function batchUpload(array $files, $callback = null)
    {
        if (empty($files)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $info = array();
        foreach ($files as $key => $file) {
            $info[$key] = (new NewUploadProcess($this))->upload($file, $callback);
        }
        return empty($info) ? false : $info;
    }
    public function batch_upload($files = null)
    {
        $files = array_keys($_FILES);
        return $this->batchUpload($files);
    }
}
}

namespace Royalcms\Component\Upload\Process {
use RC_Format;
use Royalcms\Component\Upload\Uploader\Uploader;
use Royalcms\Component\Upload\UploadProcessAbstract;
use Royalcms\Component\Upload\UploadResult;
class UploadProcess extends UploadProcessAbstract
{
    public function __construct(Uploader $uploader)
    {
        parent::__construct($uploader);
    }
    public function upload($file, $callback = null)
    {
        $upload_file = $this->getUploadFile($file);
        if (!$this->uploader->checkedUploadFile($upload_file)) {
            return false;
        }
        $name = $upload_file->getClientOriginalName();
        $ext = $upload_file->getClientOriginalExtension();
        $tmp_name = $upload_file->getRealPath();
        $savename = $this->uploader->generateFilename($name, '');
        if (false == $savename) {
            return false;
        }
        $subpath = $this->uploader->generateSubDirname($name);
        if (false !== $subpath) {
            $save_path = RC_Format::path_join(ltrim($this->uploader->save_path, '/'), $subpath);
        } else {
            $save_path = $this->uploader->save_path;
        }
        $result = new UploadResult();
        $result->setType($upload_file->getClientMimeType())->setSize($upload_file->getClientSize());
        $result->setName($name)->setSavePath($save_path);
        $result->setTmpName($tmp_name);
        if (!empty($ext)) {
            $result->setExtension($ext)->setSaveName($savename . '.' . $ext);
        }
        if ($this->uploader->hash) {
            $result->setHashMd5(md5_file($tmp_name))->setHashSha1(sha1_file($tmp_name));
        }
        $fileinfo = $result->toCompatibleArray();
        if ($this->save($fileinfo, $this->uploader->replace)) {
            $this->uploader->uploadedSuccessProcess($fileinfo);
            return $fileinfo;
        } else {
            return false;
        }
    }
    protected function getFullFileName($file)
    {
        $filename = RC_Format::path_join(RC_Format::trailingslashit($this->uploader->root_path) . ltrim($file['savepath'], '/'), $file['savename']);
        return $filename;
    }
    protected function save($file, $replace = true)
    {
        $filename = $this->getFullFileName($file);
        if (!$replace) {
            if ($this->uploader->getStorageDisk()->exists($filename)) {
                $this->uploader->add_error('a_file_with_the_same_name', sprintf(__('%s', 'royalcms-upload'), $file['savename']));
                return false;
            }
        }
        if (!$this->uploader->getStorageDisk()->is_dir(dirname($filename))) {
            $this->uploader->getStorageDisk()->mkdir(dirname($filename));
        }
        if (is_callable($this->uploader->getUploadSavingCallback())) {
            $saving_callback = $this->uploader->getUploadSavingCallback();
            return $saving_callback($file, $filename);
        } else {
            if (!$this->uploader->getStorageDisk()->move_uploaded_file($file['tmpname'], $filename)) {
                $this->uploader->add_error('file_upload_saving_error', __('', 'royalcms-upload'));
                return false;
            }
            return true;
        }
    }
}
}

namespace Royalcms\Component\Upload\Process {
use BadMethodCallException;
use RC_Format;
use RC_Uploader;
use Royalcms\Component\Upload\Events\UploadFileSucceeded;
use Royalcms\Component\Upload\UploadProcessAbstract;
use Royalcms\Component\Upload\UploadResult;
use Royalcms\Component\Uploader\InvalidFileException;
use Symfony\Component\HttpFoundation\File\UploadedFile;
class NewUploadProcess extends UploadProcessAbstract
{
    public function upload($file, $callback = null)
    {
        $upload_file = $this->getUploadFile($file);
        if (!$this->uploader->checkedUploadFile($upload_file)) {
            return false;
        }
        $name = $upload_file->getClientOriginalName();
        $ext = $upload_file->getClientOriginalExtension();
        $tmp_name = $upload_file->getRealPath();
        $savename = $this->uploader->generateFilename($name, '');
        if (empty($savename)) {
            return false;
        }
        $subpath = $this->uploader->generateSubDirname($name);
        if (false !== $subpath) {
            $save_path = RC_Format::path_join(ltrim($this->uploader->save_path, '/'), $subpath);
        } else {
            $save_path = $this->uploader->save_path;
        }
        $result = new UploadResult();
        $result->setType($upload_file->getClientMimeType())->setSize($upload_file->getClientSize());
        $result->setName($name)->setSavePath($save_path);
        $result->setTmpName($tmp_name);
        if (!empty($ext)) {
            $result->setExtension($ext)->setSaveName($savename . '.' . $ext);
        }
        if ($this->uploader->hash) {
            $result->setHashMd5(md5_file($tmp_name))->setHashSha1(sha1_file($tmp_name));
        }
        $fileinfo = $result->toCompatibleArray();
        $filename = $this->uploader($result, $upload_file, $callback);
        if ($filename) {
            $this->uploader->uploadedSuccessProcess($fileinfo);
            event(new UploadFileSucceeded($result));
            return $fileinfo;
        } else {
            return false;
        }
    }
    protected function uploader(UploadResult $result, UploadedFile $upload_file, $callback = null)
    {
        $fileinfo = $result->toCompatibleArray();
        $savename = $result->getSaveNameWithOutExtension();
        try {
            $uploader = RC_Uploader::fromUpload()->toFolder($this->uploader->save_path)->setReplace($this->uploader->replace)->renameTo($savename);
            if ($this->uploader->getUploadSavingCallback()) {
                $uploader->setUploadSavingCallback(function ($provider, $filename) use($fileinfo) {
                    $saving_callback = $this->uploader->getUploadSavingCallback();
                    return call_user_func($saving_callback, $fileinfo, $filename);
                });
            }
            $filename = $uploader->upload($upload_file, $callback);
            if ($filename === false) {
                $this->uploader->add_error('file_upload_saving_error', __('', 'royalcms-upload'));
                return false;
            }
            return $filename;
        } catch (InvalidFileException $e) {
            $this->uploader->add_error('file_upload_saving_error', $e->getMessage());
            return false;
        } catch (BadMethodCallException $e) {
            $this->uploader->add_error('file_upload_saving_error', $e->getMessage());
            return false;
        }
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
class CustomUploader extends NewUploader
{
    protected function settingUploadConfig()
    {
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
class ImageUploader extends Uploader
{
    protected $default_filetypes = array('jpg' => 'image/jpg', 'jpeg' => 'image/jpeg', 'png' => 'image/png', 'gif' => 'image/gif', 'bmp' => 'image/bmp', 'wbmp' => 'image/vnd.wap.wbmp', 'svg' => 'image/svg+xml', 'svgz' => 'image/svg+xml');
    protected function settingUploadConfig()
    {
        $file_ext = array_keys($this->default_filetypes);
        $this->allowed_type($file_ext);
        $file_mime = array_values($this->default_filetypes);
        $this->allowed_mime($file_mime);
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
class NewImageUploader extends NewUploader
{
    protected $default_filetypes = array('jpg' => 'image/jpg', 'jpeg' => 'image/jpeg', 'png' => 'image/png', 'gif' => 'image/gif', 'bmp' => 'image/bmp', 'wbmp' => 'image/vnd.wap.wbmp', 'svg' => 'image/svg+xml', 'svgz' => 'image/svg+xml');
    protected function settingUploadConfig()
    {
        $file_ext = array_keys($this->default_filetypes);
        $this->allowed_type($file_ext);
        $file_mime = array_values($this->default_filetypes);
        $this->allowed_mime($file_mime);
    }
}
}

namespace Royalcms\Component\Upload\Uploader {
use Royalcms\Component\Upload\Process\NewUploadProcess;
class TempImageUploader extends NewImageUploader
{
    public function upload($file, $callback = null)
    {
        if (empty($file)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $file['test'] = true;
        $info = (new NewUploadProcess($this))->upload($file, $callback);
        return empty($info) ? false : $info;
    }
    public function batchUpload(array $files, $callback = null)
    {
        if (empty($files)) {
            $this->add_error('not_found_file', __('', 'royalcms-upload'));
            return false;
        }
        $info = array();
        foreach ($files as $key => $file) {
            $file['test'] = true;
            $info[$key] = (new NewUploadProcess($this))->upload($file, $callback);
        }
        return empty($info) ? false : $info;
    }
}
}

namespace Royalcms\Component\Upload {
use Royalcms\Component\Error\Error;
use Royalcms\Component\Contracts\Filesystem\Filesystem as FilesystemContract;
abstract class UploaderAbstract
{
    protected $rc_error;
    protected $error_codes = array(UPLOAD_ERR_INI_SIZE => 'upload_err_ini_size', UPLOAD_ERR_FORM_SIZE => 'upload_err_form_size', UPLOAD_ERR_PARTIAL => 'upload_err_partial', UPLOAD_ERR_NO_FILE => 'upload_err_no_file', UPLOAD_ERR_NO_TMP_DIR => 'upload_err_no_tmp_dir', UPLOAD_ERR_CANT_WRITE => 'upload_err_cant_write', UPLOAD_ERR_EXTENSION => 'upload_err_extension');
    protected $options = array('save_ext' => null, 'replace' => false, 'hash' => true, 'auto_sub_dirs' => true, 'max_size' => 0, 'root_path' => null, 'save_path' => null, 'exts' => array(), 'mimes' => array());
    protected $disk;
    public function __construct()
    {
        $this->rc_error = new Error();
        $this->disk = \RC_Storage::disk();
    }
    public function __get($name)
    {
        return $this->options[$name];
    }
    public function __set($name, $value)
    {
        $this->options[$name] = $value;
    }
    public function __isset($name)
    {
        return isset($this->options[$name]);
    }
    public function setOptions(array $options)
    {
        $this->options = array_merge($this->options, $options);
        return $this;
    }
    public function setStorageDisk(FilesystemContract $disk)
    {
        $this->disk = $disk;
        return $this;
    }
    public function getStorageDisk()
    {
        return $this->disk;
    }
    public function getErrorMessages($error = null)
    {
        $errors_message = array(UPLOAD_ERR_INI_SIZE => __('PHP.ini', 'royalcms-upload'), UPLOAD_ERR_FORM_SIZE => __('', 'royalcms-upload'), UPLOAD_ERR_PARTIAL => __('', 'royalcms-upload'), UPLOAD_ERR_NO_FILE => __('', 'royalcms-upload'), UPLOAD_ERR_NO_TMP_DIR => __('', 'royalcms-upload'), UPLOAD_ERR_CANT_WRITE => __('', 'royalcms-upload'), UPLOAD_ERR_EXTENSION => __('', 'royalcms-upload'));
        if (is_null($error)) {
            return $errors_message;
        }
        return array_get($errors_message, $error);
    }
    public function getErrorCode($error)
    {
        return array_get($this->error_codes, $error);
    }
    public function error()
    {
        return $this->rc_error->get_error_message();
    }
    public function add_error($error_code, $error_message)
    {
        $this->rc_error->add($error_code, $error_message);
    }
    public function errors()
    {
        return $this->rc_error;
    }
    public function allowed_type($type)
    {
        if (is_array($type)) {
            $this->exts = $type;
        } elseif (is_string($type)) {
            $this->exts = explode(',', $type);
        }
    }
    public function allowed_mime($mime)
    {
        if (is_array($mime)) {
            $this->mimes = $mime;
        } elseif (is_string($mime)) {
            $this->mimes = explode(',', $mime);
        }
    }
    public function allowed_size($size)
    {
        $this->max_size = $size;
    }
    public function check_ext($ext)
    {
        return empty($this->exts) ? true : in_array(strtolower($ext), $this->exts);
    }
    public function check_size($size)
    {
        return !($size > $this->max_size) || 0 == $this->max_size;
    }
    public function check_mime($mime)
    {
        return empty($this->mimes) ? true : in_array(strtolower($mime), $this->mimes);
    }
    public abstract function upload($file);
    public abstract function batchUpload(array $files, $callback = null);
    public function multiUploadByFiles($callback = null)
    {
    }
}
}

namespace Royalcms\Component\Upload {
use Symfony\Component\HttpFoundation\File\UploadedFile;
abstract class UploadProcessAbstract
{
    protected $uploader;
    public function __construct($uploader)
    {
        $this->uploader = $uploader;
    }
    public function getUploadFile($file)
    {
        if ($file instanceof UploadedFile) {
            $upload_file = $file;
        } elseif (is_array($file) && isset($file['name'])) {
            $upload_file = new UploadedFile($file['tmp_name'], $file['name'], $file['type'], $file['size'], $file['error'], $file['test']);
        } else {
            $upload_file = $this->uploader->getRequest()->file($file);
        }
        return $upload_file;
    }
    public abstract function upload($file, $callback = null);
}
}

namespace Royalcms\Component\Upload {
class UploadResult
{
    protected $name;
    protected $type;
    protected $size;
    protected $extension;
    protected $save_name;
    protected $save_path;
    protected $tmp_name;
    protected $file_name;
    protected $hash_md5;
    protected $hash_sha1;
    public function getName()
    {
        return $this->name;
    }
    public function getType()
    {
        return $this->type;
    }
    public function setType($type)
    {
        $this->type = $type;
        return $this;
    }
    public function getSize()
    {
        return $this->size;
    }
    public function setSize($size)
    {
        $this->size = $size;
        return $this;
    }
    public function setName($name)
    {
        $this->name = strip_tags($name);
        return $this;
    }
    public function getExtension()
    {
        return $this->extension;
    }
    public function setExtension($extension)
    {
        $this->extension = $extension;
        return $this;
    }
    public function getSaveName()
    {
        return $this->save_name;
    }
    public function setSaveName($save_name)
    {
        $this->save_name = $save_name;
        return $this;
    }
    public function getSaveNameWithOutExtension()
    {
        return str_replace('.' . $this->extension, '', $this->save_name);
    }
    public function getSavePath()
    {
        return $this->save_path;
    }
    public function setSavePath($save_path)
    {
        $this->save_path = $save_path;
        return $this;
    }
    public function getTmpName()
    {
        return $this->tmp_name;
    }
    public function setTmpName($tmp_name)
    {
        $this->tmp_name = $tmp_name;
        return $this;
    }
    public function getFileName()
    {
        if (is_null($this->file_name)) {
            $this->file_name = $this->save_path . $this->save_name;
        }
        return $this->file_name;
    }
    public function setFileName($file_name)
    {
        $this->file_name = $file_name;
        return $this;
    }
    public function getHashMd5()
    {
        return $this->hash_md5;
    }
    public function setHashMd5($hash_md5)
    {
        $this->hash_md5 = $hash_md5;
        return $this;
    }
    public function getHashSha1()
    {
        return $this->hash_sha1;
    }
    public function setHashSha1($hash_sha1)
    {
        $this->hash_sha1 = $hash_sha1;
        return $this;
    }
    public function toCompatibleArray()
    {
        $result = ['name' => $this->getName(), 'ext' => $this->getExtension(), 'type' => $this->getType(), 'size' => $this->getSize(), 'savename' => $this->getSaveName(), 'savepath' => $this->getSavePath(), 'tmpname' => $this->getTmpName(), 'filename' => $this->getFileName(), 'md5' => $this->getHashMd5(), 'sha1' => $this->getHashSha1()];
        $result = array_filter($result, function ($value) {
            return $value == '' || is_null($value) ? false : true;
        });
        return $result;
    }
    public function toArray()
    {
        $result = ['name' => $this->getName(), 'extension' => $this->getExtension(), 'type' => $this->getType(), 'size' => $this->getSize(), 'save_name' => $this->getSaveName(), 'save_path' => $this->getSavePath(), 'tmp_name' => $this->getTmpName(), 'file_name' => $this->getFileName(), 'hash_md5' => $this->getHashMd5(), 'hash_sha1' => $this->getHashSha1()];
        $result = array_filter($result, function ($value) {
            return $value == '' || is_null($value) ? false : true;
        });
        return $result;
    }
}
}

namespace Royalcms\Component\Upload {
use Royalcms\Component\Support\Manager;
use Royalcms\Component\Upload\Uploader\CustomUploader;
use Royalcms\Component\Upload\Uploader\ImageUploader;
use Royalcms\Component\Upload\Uploader\NewImageUploader;
use Royalcms\Component\Upload\Uploader\NewUploader;
use Royalcms\Component\Upload\Uploader\TempImageUploader;
use Royalcms\Component\Upload\Uploader\Uploader;
class UploadManager extends Manager
{
    public function uploader($driver, $options = array())
    {
        $uploader = $this->driver($driver);
        $uploader->setOptions($options);
        return $uploader;
    }
    public function getDefaultDriver()
    {
        return 'default';
    }
    public function createImageDriver()
    {
        return $this->adapt(new ImageUploader());
    }
    public function createCustomDriver()
    {
        return $this->adapt(new CustomUploader());
    }
    public function createNewDriver()
    {
        return $this->adapt(new NewUploader());
    }
    public function createNewimageDriver()
    {
        return $this->adapt(new NewImageUploader());
    }
    public function createTempimageDriver()
    {
        return $this->adapt(new TempImageUploader());
    }
    public function createDefaultDriver()
    {
        return $this->adapt(new Uploader());
    }
    public function createFileDriver()
    {
        return $this->createDefaultDriver();
    }
    protected function adapt($uploader)
    {
        $uploader->add_sub_dirname_callback(array('Royalcms\\Component\\Upload\\Facades\\Upload', 'upload_sub_dir'));
        $uploader->add_filename_callback(array('Royalcms\\Component\\Upload\\Facades\\Upload', 'random_filename'));
        return $uploader;
    }
}
}

namespace Royalcms\Component\Upload\Facades {
use Royalcms\Component\Support\Facades\Facade;
use RC_Hook;
use Royalcms\Component\Foundation\Uri;
use Royalcms\Component\Support\Format;
use Royalcms\Component\DateTime\Time;
use Royalcms\Component\Support\Facades\Config;
use Royalcms\Component\Support\Facades\File;
class Upload extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'upload';
    }
    public static function local_upload_path($path = '')
    {
        return self::upload_path($path, 'local');
    }
    public static function local_upload_url($path = '')
    {
        return self::upload_url($path, 'local');
    }
    public static function upload_path($path = '', $disk = null)
    {
        $upload_root = \RC_Storage::disk($disk)->path('');
        if ($path && is_string($path)) {
            $upload_root = rtrim($upload_root, DIRECTORY_SEPARATOR);
            $upload_root .= DIRECTORY_SEPARATOR . ltrim($path, DIRECTORY_SEPARATOR);
        }
        return RC_Hook::apply_filters('upload_path', $upload_root, $path);
    }
    public static function upload_url($path = '', $disk = null)
    {
        $url = \RC_Storage::disk($disk)->url('');
        $url = rtrim($url, '/');
        if ($path && is_string($path)) {
            $url .= '/' . ltrim($path, '/');
        }
        return RC_Hook::apply_filters('upload_url', $url, $path);
    }
    public static function relative_upload_path($path)
    {
        $new_path = $path;
        $uploads = self::upload_dir();
        if (0 === strpos($new_path, $uploads['basedir'])) {
            $new_path = str_replace($uploads['basedir'], '', $new_path);
            $new_path = ltrim($new_path, '/');
        }
        return RC_Hook::apply_filters('relative_upload_path', $new_path, $path);
    }
    public static function upload_dir($type = '', $time = null)
    {
        $siteurl = Uri::site_url();
        $upload_path = trim(Config::get('upload.path'));
        if (empty($upload_path) || 'content/uploads' == $upload_path) {
            $dir = Format::untrailingslashit(self::upload_path());
        } elseif (0 !== strpos($upload_path, SITE_PATH)) {
            $dir = Format::path_join(SITE_PATH, $upload_path);
        } else {
            $dir = $upload_path;
        }
        if (!($url = Config::get('upload.url_path'))) {
            if (empty($upload_path) || 'content/uploads' == $upload_path || $upload_path == $dir) {
                $url = SITE_UPLOAD_URL;
            } else {
                $url = Format::trailingslashit($siteurl) . $upload_path;
            }
        }
        $basedir = $dir;
        $baseurl = $url;
        if ($type) {
            $type = trim($type, "/\\");
            $basedir = $dir = $dir . DIRECTORY_SEPARATOR . $type;
            $baseurl = $url = $url . "/{$type}";
        }
        $subdir = self::upload_sub_dir($time);
        $dir .= $subdir;
        $url .= $subdir;
        $uploads = RC_Hook::apply_filters('upload_dir', array('path' => $dir, 'url' => $url, 'subdir' => $subdir, 'basedir' => $basedir, 'baseurl' => $baseurl, 'error' => false));
        if (!File::makeDirectory($uploads['path'])) {
            if (0 === strpos($uploads['basedir'], SITE_PATH)) {
                $error_path = str_replace(SITE_PATH, '', $uploads['basedir']) . $uploads['subdir'];
            } else {
                $error_path = basename($uploads['basedir']) . $uploads['subdir'];
            }
            $message = sprintf('Unable to create directory %s. Is its parent directory writable by the server?', $error_path);
            $uploads['error'] = $message;
        }
        return $uploads;
    }
    public static function upload_sub_dir($time = null)
    {
        $subdir = '';
        if (Config::get('upload.use_yearmonth_folders')) {
            if (!$time) {
                $time = Time::local_date('Y-m-d', SYS_TIME);
            }
            $y = substr($time, 0, 4);
            $m = substr($time, 5, 2);
            $subdir = Format::untrailingslashit(DIRECTORY_SEPARATOR . $y . DIRECTORY_SEPARATOR . $m);
        }
        return RC_Hook::apply_filters('upload_sub_dir', $subdir, $time);
    }
    public static function random_filename()
    {
        $value = RC_Hook::apply_filters('upload_default_random_filename', '');
        if (!$value) {
            $seedstr = explode(" ", microtime(), 5);
            $seed = $seedstr[0] * 10000;
            srand($seed);
            $random = rand(1000, 10000);
            $value = date("YmdHis", time()) . $random;
        }
        return $value;
    }
}
}

namespace Royalcms\Component\Upload {
use Royalcms\Component\Support\ServiceProvider;
class UploadServiceProvider extends ServiceProvider
{
    protected $defer = true;
    public function register()
    {
        $this->mergeConfigFrom($this->guessPackagePath('royalcms/upload') . '/config/upload.php', 'upload');
        $this->registerManager();
    }
    protected function registerManager()
    {
        $this->royalcms->bindShared('upload', function ($royalcms) {
            return new UploadManager($royalcms);
        });
    }
    public function provides()
    {
        return ['upload'];
    }
    public static function compiles()
    {
        $dir = static::guessPackageClassPath('royalcms/upload');
        return [$dir . "/Uploader/Uploader.php", $dir . "/Uploader/NewUploader.php", $dir . "/Process/UploadProcess.php", $dir . "/Process/NewUploadProcess.php", $dir . "/Uploader/CustomUploader.php", $dir . "/Uploader/ImageUploader.php", $dir . "/Uploader/NewImageUploader.php", $dir . "/Uploader/TempImageUploader.php", $dir . "/UploaderAbstract.php", $dir . "/UploadProcessAbstract.php", $dir . "/UploadResult.php", $dir . "/UploadManager.php", $dir . "/Facades/Upload.php", $dir . "/UploadServiceProvider.php"];
    }
}
}

namespace Ecjia\System\Http {
use Royalcms\Component\Foundation\Http\Kernel as HttpKernel;
class Kernel extends HttpKernel
{
    protected $middleware = [];
    protected $routeMiddleware = ['verify_csrf_token' => 'Ecjia\\System\\Http\\Middleware\\VerifyCsrfToken'];
}
}

namespace Ecjia\System\Exceptions {
use Exception;
use Royalcms\Component\Exception\Handler as ExceptionHandler;
class Handler extends ExceptionHandler
{
    protected $dontReport = ['Symfony\\Component\\HttpKernel\\Exception\\HttpException'];
    public function report(Exception $e)
    {
        return parent::report($e);
    }
    public function render($request, Exception $e)
    {
        return parent::render($request, $e);
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class Config extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.config';
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class ThemeManager extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.theme.manager';
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class PluginManager extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.plugin.manager';
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class SiteManager extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.site.manager';
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class VersionManager extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.version.manager';
    }
}
}

namespace Ecjia\System\Facades {
use Royalcms\Component\Support\Facades\Facade;
class AdminLog extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.admin.log';
    }
}
}

namespace Ecjia\System\Admins\AdminLog {
class AdminLog
{
    use CompatibleTrait;
    protected $log_action;
    protected $log_object;
    public function __construct(AdminLogAction $log_action, AdminLogObject $log_object)
    {
        $this->log_action = $log_action;
        $this->log_object = $log_object;
    }
    public function getLogAction()
    {
        return $this->log_action;
    }
    public function getLogObject()
    {
        return $this->log_object;
    }
    public function getMessage($sn, $action, $object, $callback = null)
    {
        if (is_callable($callback)) {
            $callback($this);
        } elseif (is_array($callback)) {
            $this->log_action->addActions(array_get($callback, 'action', []));
            $this->log_object->addObjects(array_get($callback, 'object', []));
        }
        if ($this->log_action->hasAction($action) && $this->log_object->hasObject($object)) {
            $log_info = $this->log_action->getAction($action) . ' ' . $this->log_object->getObject($object) . ': ' . addslashes($sn);
        } else {
            $log_info = addslashes($sn);
        }
        return $log_info;
    }
    public static function instance()
    {
        static $instance;
        if (is_null($instance)) {
            $instance = new static(new AdminLogAction(), new AdminLogObject());
        }
        return $instance;
    }
}
}

namespace Ecjia\System\Admins\AdminLog {
trait CompatibleTrait
{
    public static function instance()
    {
        return royalcms('ecjia.admin.log');
    }
    public function add_action($code, $name)
    {
        return $this->log_action->addAction($code, $name);
    }
    public function has_action($code)
    {
        return $this->log_action->hasAction($code);
    }
    public function add_object($code, $name)
    {
        return $this->log_object->addObject($code, $name);
    }
    public function has_object($code)
    {
        return $this->log_object->hasObject($code);
    }
    public function get_message($sn, $action, $content)
    {
        return $this->getMessage($sn, $action, $content);
    }
}
}

namespace Ecjia\System\Admins\AdminLog {
class AdminLogAction
{
    protected $items;
    public function __construct()
    {
        $this->items = ['add' => __(''), 'edit' => __(''), 'use' => __(''), 'stop' => __(''), 'remove' => __(''), 'install' => __(''), 'uninstall' => __(''), 'setup' => __(''), 'trash' => __(''), 'restore' => __(''), 'merge' => __(''), 'batch_remove' => __(''), 'batch_trash' => __(''), 'batch_restore' => __(''), 'batch_upload' => __(''), 'batch_edit' => __(''), 'batch_stop' => __('')];
    }
    public function addAction($code, $name)
    {
        if ($code && $name) {
            $this->items[$code] = $name;
        }
        return $this;
    }
    public function addActions(array $actions)
    {
        foreach ($actions as $code => $name) {
            $this->items[$code] = $name;
        }
        return $this;
    }
    public function hasAction($code)
    {
        return array_has($this->items, $code);
    }
    public function getAction($code, $default = null)
    {
        return array_get($this->items, $code, $default);
    }
}
}

namespace Ecjia\System\Admins\AdminLog {
class AdminLogObject
{
    protected $items;
    public function __construct()
    {
        $this->items = array('privilege' => __(''), 'adminlog' => __(''), 'admin_message' => __(''), 'area' => __(''), 'shop_config' => __(''), 'users' => __(''), 'shipping' => __(''), 'shipping_area' => __(''), 'area_region' => __(''), 'goods' => __(''), 'brand' => __(''), 'category' => __(''), 'pack' => __(''), 'card' => __(''), 'attribute' => __(''), 'goods_type' => __(''), 'articlecat' => __(''), 'article' => __(''), 'shophelp' => __(''), 'shophelpcat' => __(''), 'shopinfo' => __(''), 'user_rank' => __(''), 'snatch' => __(''), 'bonustype' => __(''), 'userbonus' => __(''), 'vote' => __(''), 'friendlink' => __(''), 'payment' => __(''), 'order' => __(''), 'agency' => __(''), 'auction' => __(''), 'favourable' => __(''), 'wholesale' => __(''), 'feedback' => __(''), 'users_comment' => __(''), 'ads_position' => __(''), 'ads' => __(''), 'group_buy' => __(''), 'booking' => __(''), 'tag_manage' => __(''), 'languages' => __(''), 'user_surplus' => __(''), 'message' => __(''), 'fckfile' => __('FCK'), 'db_backup' => __(''), 'package' => __(''), 'exchange_goods' => __(''), 'suppliers' => __(''), 'reg_fields' => __(''), 'license' => __(''), 'issuer' => __(''), 'app' => __(''), 'plugin' => __(''));
    }
    public function addObject($code, $name)
    {
        if ($code && $name) {
            $this->items[$code] = $name;
        }
        return $this;
    }
    public function addObjects(array $objects)
    {
        foreach ($objects as $code => $name) {
            $this->items[$code] = $name;
        }
        return $this;
    }
    public function hasObject($code)
    {
        return array_has($this->items, $code);
    }
    public function getObject($code, $default = null)
    {
        return array_get($this->items, $code, $default);
    }
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface EcjiaSessionInterface
{
    public function deleteSpecSession($userId, $userType);
    public function getUserCount($userType);
    public function getSessionData($sessionId);
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface EcjiaTemplateFileLoader
{
    public function get_template_dir();
    public function get_template_file($file);
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface PaidOrderProcessInterface
{
    public function getOrderInfo();
    public function getPaymentData();
    public function getPrintData();
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface ScriptLoaderInterface
{
    public function print_head_scripts();
    public function print_footer_scripts();
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface StyleLoaderInterface
{
    public function print_head_styles();
    public function print_late_styles();
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface UserAllotPurview
{
    public function getUserId();
    public function save($value);
    public function get();
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface UserInterface
{
    public function getUserName();
    public function getUserId();
    public function getUserType();
    public function getEmail();
    public function getLastLogin();
    public function getLastIp();
    public function getActionList();
    public function setActionList($purview);
    public function getLangType();
    public function getRoleId();
    public function getAddTime();
}
}

namespace Ecjia\System\Frameworks\Contracts {
interface ShopInterface
{
    public function getStoreName();
    public function getSotreId();
}
}

namespace Ecjia\System\Frameworks\ScriptLoader {
use Ecjia\System\Frameworks\Contracts\ScriptLoaderInterface;
use Royalcms\Component\Script\HandleScripts;
use RC_Uri;
use RC_Hook;
class ScriptLoader implements ScriptLoaderInterface
{
    protected $scripts;
    protected $concatenate_scripts;
    protected $compress_scripts;
    public function __construct(HandleScripts $scripts)
    {
        $this->scripts = $scripts;
        $this->scripts->base_url = RC_Uri::system_static_url();
        $this->scripts->content_url = RC_Uri::system_static_url();
        $this->scripts->default_version = \ecjia::VERSION;
        $this->scripts->default_dirs = array('/');
        $this->default_scripts();
        $this->script_concat_settings();
    }
    protected function default_scripts()
    {
        $develop_src = false !== strpos(\ecjia::VERSION, '-src');
        if (!config('system.script_debug')) {
            $suffix = '.min';
        } else {
            $suffix = '';
        }
        $dev_suffix = $develop_src ? '' : '.min';
        $this->scripts->add('ecjia', "/lib/ecjia_js/ecjia{$suffix}.js", array('jquery'));
        $this->scripts->add('ecjia-ui', "/lib/ecjia_js/ecjia.ui{$suffix}.js", array('ecjia'));
        $this->scripts->add('ecjia-collect', "/lib/ecjia_js/ecjia.collect.js", array('ecjia'), false, 1);
        $this->scripts->add('ecjia-hook', "/lib/ecjia_js/ecjia.hook{$suffix}.js", array('ecjia'), false, 1);
        $this->scripts->add('ecjia-utils', "/lib/ecjia_js/ecjia.utils{$suffix}.js", array('ecjia'), false, 1);
        $this->scripts->add('ecjia-region', "/lib/ecjia_js/ecjia.region{$suffix}.js", array('ecjia'), false, 1);
        $this->scripts->add('jquery', "/js/jquery{$suffix}.js", array(), '2.1.0');
        $this->scripts->add('jquery-pjax', "/js/jquery-pjax.js", array('jquery'));
        $this->scripts->add('jquery-peity', "/js/jquery-peity{$suffix}.js", array('jquery'), '0.6.0', 1);
        $this->scripts->add('jquery-mockjax', "/js/jquery-mockjax{$suffix}.js", array('jquery'), '1.5.1', 1);
        $this->scripts->add('jquery-wookmark', "/js/jquery-wookmark{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-migrate', "/js/jquery-migrate{$suffix}.js", array('jquery'), '1.0.0', 1);
        $this->scripts->add('jquery-cookie', "/js/jquery-cookie{$suffix}.js", array('jquery'), true, 1);
        $this->scripts->add('jquery-actual', "/js/jquery-actual{$suffix}.js", array('jquery'), '1.0.6', 1);
        $this->scripts->add('jquery-debouncedresize', "/js/jquery-debouncedresize{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-easing', "/js/jquery-easing{$suffix}.js", array('jquery'), '1.3', 1);
        $this->scripts->add('jquery-mediaTable', "/js/jquery-mediaTable{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-imagesloaded', "/js/jquery-imagesloaded{$suffix}.js", array('jquery'), '2.0.1', 1);
        $this->scripts->add('jquery-gmap3', "/js/jquery-gmap3{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-autosize', "/js/jquery-autosize{$suffix}.js", array('jquery'), '1.7', 1);
        $this->scripts->add('jquery-counter', "/js/jquery-counter{$suffix}.js", array('jquery'), '2.1', 1);
        $this->scripts->add('jquery-inputmask', "/js/jquery-inputmask{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-progressbar', "/js/jquery-anim_progressbar{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('js-json', "/js/json2.js", array(), false, 1);
        $this->scripts->add('js-sprintf', "/lib/sprintf_js/sprintf{$suffix}.js", array(), '1.1.2', 1);
        $this->scripts->add('jquery-ui-touchpunch', "/js/ui/jquery-ui-touchpunch{$suffix}.js", array('jquery-ui'), false, 1);
        $this->scripts->add('jquery-ui-totop', "/js/ui/jquery-ui-totop{$suffix}.js", array(), false, 1);
        $this->scripts->add('ecjia-admin', '/ecjia/ecjia-admin.js', array('ecjia', 'jquery-pjax', 'jquery-cookie', 'jquery-quicksearch', 'jquery-mousewheel', 'jquery-ui-totop'));
        $this->scripts->add('ecjia-front', '/ecjia/ecjia-front.js', array('ecjia'));
        $this->scripts->add('ecjia-admin_cache', '/ecjia/ecjia-admin_cache.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_logs', '/ecjia/ecjia-admin_logs.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_message_list', '/ecjia/ecjia-admin_message_list.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_region', '/ecjia/ecjia-admin_region.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_role', '/ecjia/ecjia-admin_role.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_upgrade', '/ecjia/ecjia-admin_upgrade.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_application', '/ecjia/ecjia-application.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_dashboard', '/ecjia/ecjia-dashboard.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_team', '/ecjia/ecjia-about_team.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_plugin', '/ecjia/ecjia-plugin_list.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_privilege', '/ecjia/ecjia-privilege.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_shop_config', '/ecjia/ecjia-shop_config.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('ecjia-admin_license', '/ecjia/ecjia-admin_license.js', array('ecjia-admin'), false, 1);
        $this->scripts->add('jquery-chosen', "/js/ecjia.chosen.js", array('ecjia-jquery-chosen'), false, 1);
        $this->scripts->add('ecjia-jquery-chosen', "/lib/chosen/chosen.jquery{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('bootstrap', "/lib/bootstrap/js/bootstrap{$suffix}.js");
        $this->scripts->add('jquery-ui', "/lib/jquery-ui/jquery-ui{$suffix}.js", array('jquery'));
        $this->scripts->add('jquery-validate', "/lib/validation/jquery.validate{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-uniform', "/lib/uniform/jquery.uniform{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('smoke', "/lib/smoke/smoke{$suffix}.js", array(), false, 1);
        $this->scripts->add('bootstrap-placeholder', "/lib/jasny-bootstrap/js/bootstrap-placeholder{$suffix}.js", array('bootstrap'), false, 1);
        $this->scripts->add('bootstrap-colorpicker', "/lib/colorpicker/bootstrap-colorpicker{$suffix}.js", array(), false, 1);
        $this->scripts->add('jquery-flot', "/lib/flot/jquery.flot{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-flot-curvedLines', "/lib/flot/jquery.flot.curvedLines{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('jquery-flot-multihighlight', "/lib/flot/jquery.flot.multihighlight{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('jquery-flot-orderBars', "/lib/flot/jquery.flot.orderBars{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('jquery-flot-pie', "/lib/flot/jquery.flot.pie{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('jquery-flot-pyramid', "/lib/flot/jquery.flot.pyramid{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('jquery-flot-resize', "/lib/flot/jquery.flot.resize{$suffix}.js", array('jquery-flot'), false, 1);
        $this->scripts->add('antiscroll', "/lib/antiscroll/antiscroll{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-mousewheel', "/lib/antiscroll/jquery-mousewheel.js", array('jquery', 'antiscroll'), false, 1);
        $this->scripts->add('nicescroll', "/lib/nicescroll/jquery.nicescroll{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-colorbox', "/lib/colorbox/jquery.colorbox{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-qtip', "/lib/qtip2/jquery.qtip{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-sticky', "/lib/sticky/sticky{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-jBreadCrumb', "/lib/jBreadcrumbs/js/jquery.jBreadCrumb{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-form', "/lib/jquery-form/jquery.form{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('ios-orientationchange', "/lib/ios-fix/ios-orientationchange-fix{$suffix}.js", array(), false, 1);
        $this->scripts->add('google-code-prettify', "/lib/google-code-prettify/prettify{$suffix}.js", array(), false, 1);
        $this->scripts->add('selectnav', "/lib/selectnav/selectnav{$suffix}.js", array(), false, 1);
        $this->scripts->add('jquery-dataTables', "/lib/datatables/jquery.dataTables{$suffix}.js", array('jquery'), false, 1);
        $this->scripts->add('jquery-dataTables-sorting', "/lib/datatables/jquery.dataTables.sorting{$suffix}.js", array('jquery-dataTables'), false, 1);
        $this->scripts->add('jquery-dataTables-bootstrap', "/lib/datatables/jquery.dataTables.bootstrap{$suffix}.js", array('jquery-dataTables'), false, 1);
        $this->scripts->add('jquery-stepy', "/lib/stepy/js/jquery.stepy{$suffix}.js", array(), false, 1);
        $this->scripts->add('jquery-quicksearch', "/lib/multi-select/js/jquery.quicksearch.js", array(), false, 1);
        $this->scripts->add('bootstrap-datepicker', "/lib/datepicker/bootstrap-datepicker.min.js", array(), false, 1);
        $this->scripts->add('tinymce', RC_Uri::vendor_url('tinymce/tinymce/tinymce') . "{$suffix}.js", array(), false, 1);
        $this->scripts->localize('ecjia.ui', 'admin_lang', config('system::jslang.loader_page'));
    }
    protected function script_concat_settings()
    {
        $compressed_output = ini_get('zlib.output_compression') || 'ob_gzhandler' == ini_get('output_handler');
        if (is_null($this->concatenate_scripts)) {
            $this->concatenate_scripts = config('system.concatenate_scripts', true);
            if (config('system.script_debug')) {
                $this->concatenate_scripts = false;
            }
        }
        if (is_null($this->compress_scripts)) {
            $this->compress_scripts = config('system.compress_scripts', true);
            if ($this->compress_scripts && (!config('system.can_compress_scripts') || $compressed_output)) {
                $this->compress_scripts = false;
            }
        }
    }
    public function print_head_scripts()
    {
        if (!RC_Hook::did_action('rc_print_scripts')) {
            RC_Hook::do_action('rc_print_scripts');
        }
        $this->scripts->do_concat = $this->concatenate_scripts;
        $this->scripts->do_head_items();
        if (RC_Hook::apply_filters('print_head_scripts', true)) {
            $this->_print_scripts();
        }
        $this->scripts->reset();
        return $this->scripts->done;
    }
    public function print_footer_scripts()
    {
        $this->scripts->do_concat = $this->concatenate_scripts;
        $this->scripts->do_footer_items();
        if (RC_Hook::apply_filters('print_footer_scripts', true)) {
            $this->_print_scripts();
        }
        $this->scripts->reset();
        return $this->scripts->done;
    }
    protected function _print_scripts()
    {
        $zip = $this->compress_scripts ? 1 : 0;
        if ($zip && config('system.enforce_gzip')) {
            $zip = 'gzip';
        }
        if ($concat = trim($this->scripts->concat, ', ')) {
            if (!empty($this->scripts->print_code)) {
                echo "\n<script type='text/javascript'>\n";
                echo "/* <![CDATA[ */\n";
                echo $this->scripts->print_code;
                echo "/* ]]> */\n";
                echo "</script>\n";
            }
            $concat = str_split($concat, 128);
            $concat = 'load%5B%5D=' . implode('&load%5B%5D=', $concat);
            $args = "compress={$zip}&" . $concat . '&ver=' . $this->scripts->default_version;
            $src = RC_Uri::url('@load_scripts/init', $args);
            echo "<script type='text/javascript' src='" . \RC_Format::esc_attr($src) . "'></script>\n";
        }
        if (!empty($this->scripts->print_html)) {
            echo $this->scripts->print_html;
        }
    }
}
}

namespace Ecjia\System\Frameworks\ScriptLoader {
use Ecjia\System\Frameworks\Contracts\StyleLoaderInterface;
use Royalcms\Component\Script\HandleStyles;
use RC_Uri;
use RC_Hook;
class StyleLoader implements StyleLoaderInterface
{
    protected $styles;
    protected $concatenate_styles;
    protected $compress_css;
    public function __construct($styles)
    {
        $this->styles = $styles;
        $this->styles->base_url = RC_Uri::system_static_url();
        $this->styles->content_url = RC_Uri::system_static_url();
        $this->styles->default_version = \ecjia::VERSION;
        $this->styles->text_direction = function_exists('is_rtl') && is_rtl() ? 'rtl' : 'ltr';
        $this->styles->default_dirs = array('/');
        $this->default_styles();
        $this->style_concat_settings();
    }
    protected function default_styles()
    {
        $develop_src = false !== strpos(\ecjia::VERSION, '-src');
        if (!config('system.script_debug')) {
            $suffix = '.min';
        } else {
            $suffix = '';
        }
        $dev_suffix = $develop_src ? '' : '.min';
        $this->styles->add('ecjia', "/styles/ecjia.css");
        $this->styles->add('ecjia-ui', "/styles/ecjia.ui.css");
        $this->styles->add('ecjia-function', "/styles/ecjia.function.css");
        $this->styles->add('ecjia-skin-blue', "/styles/ecjia.skin.blue.css", array('ecjia'));
        $this->styles->add('bootstrap', "/lib/bootstrap/css/bootstrap{$suffix}.css");
        $this->styles->add('bootstrap-responsive', "/lib/bootstrap/css/bootstrap-responsive{$suffix}.css", array('bootstrap'));
        $this->styles->add('bootstrap-responsive-nodeps', "/lib/bootstrap/css/bootstrap-responsive{$suffix}.css");
        $this->styles->add('jquery-ui-aristo', "/lib/jquery-ui/css/Aristo/Aristo.css");
        $this->styles->add('jquery-qtip', "/lib/qtip2/jquery.qtip{$suffix}.css");
        $this->styles->add('jquery-jBreadCrumb', "/lib/jBreadcrumbs/css/BreadCrumb.css");
        $this->styles->add('jquery-colorbox', "/lib/colorbox/colorbox.css");
        $this->styles->add('jquery-sticky', "/lib/sticky/sticky.css");
        $this->styles->add('google-code-prettify', "/lib/google-code-prettify/prettify.css");
        $this->styles->add('splashy', "/images/splashy/splashy.css");
        $this->styles->add('flags', "/images/flags/flags.css");
        $this->styles->add('datatables-TableTools', "/lib/datatables/extras/TableTools/media/css/TableTools.css");
        $this->styles->add('fontello', "/lib/fontello/css/fontello.css");
        $this->styles->add('chosen', "/lib/chosen/chosen.css");
        $this->styles->add('uniform-aristo', "/lib/uniform/Aristo/uniform.aristo.css");
        $this->styles->add('jquery-stepy', "/lib/stepy/css/jquery.stepy.css");
        $this->styles->add('bootstrap-datepicker', "/lib/datepicker/datepicker.css");
    }
    protected function style_concat_settings()
    {
        $compressed_output = ini_get('zlib.output_compression') || 'ob_gzhandler' == ini_get('output_handler');
        if (is_null($this->concatenate_styles)) {
            $this->concatenate_styles = config('system.concatenate_scripts', true);
            if (config('system.script_debug')) {
                $this->concatenate_styles = false;
            }
        }
        if (is_null($this->compress_css)) {
            $this->compress_css = config('system.compress_css', true);
            if ($this->compress_css && (!config('system.can_compress_scripts') || $compressed_output)) {
                $this->compress_css = false;
            }
        }
    }
    public function print_head_styles()
    {
        $this->styles->do_concat = $this->concatenate_styles;
        $this->styles->do_items(false);
        if (RC_Hook::apply_filters('print_admin_styles', true)) {
            $this->_print_styles();
        }
        $this->styles->reset();
        return $this->styles->done;
    }
    public function print_late_styles()
    {
        $this->styles->do_concat = $this->concatenate_styles;
        $this->styles->do_footer_items();
        if (RC_Hook::apply_filters('print_late_styles', true)) {
            $this->_print_styles();
        }
        $this->styles->reset();
        return $this->styles->done;
    }
    protected function _print_styles()
    {
        $zip = $this->compress_css ? 1 : 0;
        if ($zip && config('system.enforce_gzip')) {
            $zip = 'gzip';
        }
        if ($concat = trim($this->styles->concat, ', ')) {
            $dir = $this->styles->text_direction;
            $ver = $this->styles->default_version;
            $concat = str_split($concat, 128);
            $concat = 'load%5B%5D=' . implode('&load%5B%5D=', $concat);
            $args = "compress={$zip}&dir={$dir}&" . $concat . '&ver=' . $ver;
            $href = RC_Uri::url('@load_styles/init', $args);
            echo "<link rel=\"stylesheet\" href=\"" . \RC_Format::esc_attr($href) . "\" type=\"text/css\" media=\"all\" />\n";
            if (!empty($this->styles->print_code)) {
                echo "<style type='text/css'>\n";
                echo $this->styles->print_code;
                echo "\n</style>\n";
            }
        }
        if (!empty($this->styles->print_html)) {
            echo $this->styles->print_html;
        }
    }
}
}

namespace Ecjia\System\Frameworks\Screens {
use RC_Hook;
use RC_Loader;
use RC_Theme;
use ecjia_controller;
use ecjia_license;
use ecjia_app;
use ecjia;
class NotInstallScreen extends AllScreen
{
    public function loading()
    {
        parent::loading();
        if (defined('RC_SITE') && RC_SITE == 'api') {
            RC_Loader::load_app_func('functions', 'api');
        }
        RC_Hook::add_action('init', [__CLASS__, 'load_theme_function']);
        RC_Hook::add_filter('app_scan_bundles', [__CLASS__, 'app_scan_bundles']);
        RC_Hook::add_action('royalcms_default_controller', [__CLASS__, 'royalcms_default_controller']);
        RC_Hook::add_action('ecjia_shop_closed', [__CLASS__, 'custom_shop_closed']);
        RC_Hook::add_action('ecjia_general_info_filter', [__CLASS__, 'ecjia_general_info_filter']);
        RC_Hook::add_action('page_title_suffix', [__CLASS__, 'page_title_suffix']);
        ecjia::loadGlobalPlugins();
    }
    public static function royalcms_default_controller($arg)
    {
        return new ecjia_controller();
    }
    public static function load_theme_function()
    {
        if (config('system.tpl_force_specify')) {
            self::_load_default_style();
        } else {
            $app = config('site.main_app');
            if ($app) {
                RC_Loader::load_app_func('functions', $app);
                self::_load_custom_handle_style();
            } else {
                $request = royalcms('request');
                if ($request->getBasePath() != '') {
                    self::_load_default_style();
                } else {
                    self::_load_custom_handle_style();
                }
            }
        }
        $dir = RC_Theme::get_template_directory();
        if (file_exists($dir . DS . 'functions.php')) {
            include_once $dir . DS . 'functions.php';
        }
    }
    protected static function _load_custom_handle_style()
    {
        RC_Hook::add_filter('template', function () {
            $template_code = RC_Hook::apply_filters('ecjia_theme_template_code', 'template');
            return ecjia::config($template_code);
        });
    }
    protected static function _load_default_style()
    {
        RC_Hook::add_filter('template', function () {
            return config('system.tpl_style');
        });
    }
    public static function app_scan_bundles()
    {
        $builtin_bundles = ecjia_app::builtin_bundles();
        if (defined('ROUTE_M') && ROUTE_M != 'installer') {
            $extend_bundles = ecjia_app::extend_bundles();
            return array_merge($builtin_bundles, $extend_bundles);
        }
        return $builtin_bundles;
    }
    public static function custom_shop_closed()
    {
        header('Content-type: text/html; charset=' . RC_CHARSET);
        die('<div style="margin: 150px; text-align: center; font-size: 14px"><p>' . __('...') . '</p><p>' . ecjia::config('close_comment') . '</p></div>');
    }
    public static function ecjia_general_info_filter($data)
    {
        if (!ecjia_license::instance()->license_check()) {
            $data['powered'] = ecjia::powerByLink();
        } else {
            $data['powered'] = '';
        }
        return $data;
    }
    public static function page_title_suffix($title)
    {
        if (defined('ROUTE_M') && ROUTE_M != 'installer') {
            if (ecjia_license::instance()->license_check()) {
                return '';
            }
        }
        $suffix = ' - ' . ecjia::powerByText();
        return $suffix;
    }
}
}

namespace Ecjia\System\Frameworks\Screens {
use RC_Hook;
class AllScreen
{
    public function __construct()
    {
    }
    public function loading()
    {
        RC_Hook::add_filter('pretty_page_table_data', [__CLASS__, 'remove_env_pretty_page_table_data']);
        RC_Hook::add_action('reset_mail_config', ['Ecjia\\System\\Frameworks\\Component\\Mailer', 'ecjia_mail_config']);
    }
    public static function remove_env_pretty_page_table_data($tables)
    {
        $env = collect($tables['Environment Variables']);
        $server = collect($tables['Server/Request Data']);
        $col = collect(['AUTH_KEY', 'DB_HOST', 'DB_PORT', 'DB_DATABASE', 'DB_USERNAME', 'DB_PASSWORD', 'DB_PREFIX']);
        $col->map(function ($item) use($env, $server) {
            $env->pull($item);
            $server->pull($item);
        });
        $tables['Environment Variables'] = $env->all();
        $tables['Server/Request Data'] = $server->all();
        return $tables;
    }
}
}

namespace Ecjia\System\Frameworks\Model {
use Royalcms\Component\Rememberable\Rememberable;
use Royalcms\Component\Database\Eloquent\Model as Eloquent;
abstract class Model extends Eloquent
{
    use Rememberable;
    use InsertOnDuplicateKey;
}
}

namespace Ecjia\System\Frameworks\Model {
trait InsertOnDuplicateKey
{
    public static function insertOnDuplicateKey(array $data, array $updateColumns = null)
    {
        if (empty($data)) {
            return false;
        }
        if (!isset($data[0])) {
            $data = [$data];
        }
        $sql = static::buildInsertOnDuplicateSql($data, $updateColumns);
        $data = static::inLineArray($data);
        return self::getModelConnectionName()->affectingStatement($sql, $data);
    }
    public static function insertIgnore(array $data)
    {
        if (empty($data)) {
            return false;
        }
        if (!isset($data[0])) {
            $data = [$data];
        }
        $sql = static::buildInsertIgnoreSql($data);
        $data = static::inLineArray($data);
        return self::getModelConnectionName()->affectingStatement($sql, $data);
    }
    public static function replace(array $data)
    {
        if (empty($data)) {
            return false;
        }
        if (!isset($data[0])) {
            $data = [$data];
        }
        $sql = static::buildReplaceSql($data);
        $data = static::inLineArray($data);
        return self::getModelConnectionName()->affectingStatement($sql, $data);
    }
    public static function getTableName()
    {
        $class = get_called_class();
        return (new $class())->getTable();
    }
    public static function getModelConnectionName()
    {
        $class = get_called_class();
        return (new $class())->getConnection();
    }
    public static function getTablePrefix()
    {
        return self::getModelConnectionName()->getTablePrefix();
    }
    public static function getPrimaryKey()
    {
        $class = get_called_class();
        return (new $class())->getKeyName();
    }
    protected static function buildQuestionMarks($data)
    {
        $lines = [];
        foreach ($data as $row) {
            $count = count($row);
            $questions = [];
            for ($i = 0; $i < $count; ++$i) {
                $questions[] = '?';
            }
            $lines[] = '(' . implode(',', $questions) . ')';
        }
        return implode(', ', $lines);
    }
    protected static function getFirstRow(array $data)
    {
        if (empty($data)) {
            throw new \InvalidArgumentException('Empty data.');
        }
        list($first) = $data;
        if (!is_array($first)) {
            throw new \InvalidArgumentException('$data is not an array of array.');
        }
        return $first;
    }
    protected static function getColumnList(array $first)
    {
        if (empty($first)) {
            throw new \InvalidArgumentException('Empty array.');
        }
        return '`' . implode('`,`', array_keys($first)) . '`';
    }
    protected static function buildValuesList(array $updatedColumns)
    {
        $out = [];
        foreach ($updatedColumns as $key => $value) {
            if (is_numeric($key)) {
                $out[] = sprintf('`%s` = VALUES(`%s`)', $value, $value);
            } else {
                if (is_string($value)) {
                    $out[] = sprintf("`%s` = '%s'", $key, $value);
                } else {
                    $out[] = sprintf("`%s` = %s", $key, $value);
                }
            }
        }
        return implode(', ', $out);
    }
    protected static function inLineArray(array $data)
    {
        return call_user_func_array('array_merge', array_map('array_values', $data));
    }
    protected static function buildInsertOnDuplicateSql(array $data, array $updateColumns = null)
    {
        $first = static::getFirstRow($data);
        $sql = 'INSERT INTO `' . static::getTablePrefix() . static::getTableName() . '`(' . static::getColumnList($first) . ') VALUES' . PHP_EOL;
        $sql .= static::buildQuestionMarks($data) . PHP_EOL;
        $sql .= 'ON DUPLICATE KEY UPDATE ';
        if (empty($updateColumns)) {
            $sql .= static::buildValuesList(array_keys($first));
        } else {
            $sql .= static::buildValuesList($updateColumns);
        }
        return $sql;
    }
    protected static function buildInsertIgnoreSql(array $data)
    {
        $first = static::getFirstRow($data);
        $sql = 'INSERT IGNORE INTO `' . static::getTablePrefix() . static::getTableName() . '`(' . static::getColumnList($first) . ') VALUES' . PHP_EOL;
        $sql .= static::buildQuestionMarks($data);
        return $sql;
    }
    protected static function buildReplaceSql(array $data)
    {
        $first = static::getFirstRow($data);
        $sql = 'REPLACE INTO `' . static::getTablePrefix() . static::getTableName() . '`(' . static::getColumnList($first) . ') VALUES' . PHP_EOL;
        $sql .= static::buildQuestionMarks($data);
        return $sql;
    }
}
}

namespace Ecjia\System\Frameworks\Sessions\Traits {
use Ecjia\System\Admins\SessionLogins\AdminSessionLogins;
use Ecjia\System\Admins\SessionLogins\MerchantSessionLogins;
use Ecjia\System\Admins\SessionLogins\UserSessionLogins;
use Royalcms\Component\NativeSession\Serialize;
trait EcjiaSessionSpecTrait
{
    public function deleteSpecSession($userId, $userType)
    {
        if ($userType == 'admin') {
            $session_login = new AdminSessionLogins(null, $userId);
        } else {
            if ($userType == 'merchant') {
                $session_login = new MerchantSessionLogins(null, $userId);
            } else {
                $session_login = new UserSessionLogins(null, $userId);
            }
        }
        $sessions = $session_login->getByUserId();
        $result = $sessions->map(function ($model) {
            return $this->destroy($model->id);
        });
        return $result;
    }
    public function getUserCount($userType)
    {
        if ($userType == 'admin') {
            $session_login = new AdminSessionLogins(null, null);
        } else {
            if ($userType == 'merchant') {
                $session_login = new MerchantSessionLogins(null, null);
            } else {
                $session_login = new UserSessionLogins(null, null);
            }
        }
        $count = $session_login->getUserCount();
        return $count;
    }
    public function getSessionData($sessionId)
    {
        try {
            $data = $this->read($sessionId);
            $sessionData = Serialize::unserialize($data);
            return $sessionData;
        } catch (\Exception $e) {
            ecjia_log_error($e->getMessage());
            return [];
        }
    }
}
}

namespace Ecjia\System\Frameworks\Sessions\Handler {
use Ecjia\System\Frameworks\Contracts\EcjiaSessionInterface;
use Ecjia\System\Frameworks\Sessions\Traits\EcjiaSessionSpecTrait;
use Royalcms\Component\NativeSession\Serialize;
class MysqlSessionHandler implements \SessionHandlerInterface, EcjiaSessionInterface
{
    use EcjiaSessionSpecTrait;
    private $pdo;
    private $table;
    private $idCol;
    private $dataCol;
    private $timeCol;
    private $useridCol;
    private $usertypeCol;
    public function __construct(\PDO $pdo, array $dbOptions = array())
    {
        if (!array_key_exists('db_table', $dbOptions)) {
            throw new \InvalidArgumentException('You must provide the "db_table" option for a PdoSessionStorage.');
        }
        if (\PDO::ERRMODE_EXCEPTION !== $pdo->getAttribute(\PDO::ATTR_ERRMODE)) {
            throw new \InvalidArgumentException(sprintf('"%s" requires PDO error mode attribute be set to throw Exceptions (i.e. $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION))', __CLASS__));
        }
        $this->pdo = $pdo;
        $dbOptions = array_merge(array('db_id_col' => 'sess_id', 'db_data_col' => 'sess_data', 'db_time_col' => 'sess_time', 'db_userid_col' => 'user_id', 'db_usertype_col' => 'user_type'), $dbOptions);
        $this->table = $dbOptions['db_table'];
        $this->idCol = $dbOptions['db_id_col'];
        $this->dataCol = $dbOptions['db_data_col'];
        $this->timeCol = $dbOptions['db_time_col'];
        $this->useridCol = $dbOptions['db_userid_col'];
        $this->usertypeCol = $dbOptions['db_usertype_col'];
    }
    public function open($savePath, $sessionName)
    {
        return true;
    }
    public function close()
    {
        return true;
    }
    public function destroy($sessionId)
    {
        $sql = "DELETE FROM {$this->table} WHERE {$this->idCol} = :id";
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->bindParam(':id', $sessionId, \PDO::PARAM_STR);
            $stmt->execute();
        } catch (\PDOException $e) {
            throw new \RuntimeException(sprintf('PDOException was thrown when trying to delete a session: %s', $e->getMessage()), 0, $e);
        }
        return true;
    }
    public function gc($maxlifetime)
    {
        $sql = "DELETE FROM {$this->table} WHERE {$this->timeCol} < :time";
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->bindValue(':time', time() - $maxlifetime, \PDO::PARAM_INT);
            $stmt->execute();
        } catch (\PDOException $e) {
            throw new \RuntimeException(sprintf('PDOException was thrown when trying to delete expired sessions: %s', $e->getMessage()), 0, $e);
        }
        return true;
    }
    public function read($sessionId)
    {
        $sql = "SELECT {$this->dataCol} FROM {$this->table} WHERE {$this->idCol} = :id";
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->bindParam(':id', $sessionId, \PDO::PARAM_STR);
            $stmt->execute();
            $sessionRows = $stmt->fetchAll(\PDO::FETCH_NUM);
            if ($sessionRows) {
                return $sessionRows[0][0];
            }
            return '';
        } catch (\PDOException $e) {
            throw new \RuntimeException(sprintf('PDOException was thrown when trying to read the session data: %s', $e->getMessage()), 0, $e);
        }
    }
    public function write($sessionId, $data)
    {
        $encoded = $data;
        $sessionData = Serialize::unserialize($data);
        if (!isset($sessionData['session_user_id'])) {
            $sessionData['session_user_id'] = '';
        }
        if (!isset($sessionData['session_user_type'])) {
            $sessionData['session_user_type'] = '';
        }
        try {
            $mergeSql = $this->getMergeSql();
            if (null !== $mergeSql) {
                $mergeStmt = $this->pdo->prepare($mergeSql);
                $mergeStmt->bindParam(':id', $sessionId, \PDO::PARAM_STR);
                $mergeStmt->bindParam(':data', $encoded, \PDO::PARAM_STR);
                $mergeStmt->bindValue(':time', time(), \PDO::PARAM_INT);
                $mergeStmt->bindValue(':user_id', $sessionData['session_user_id'], \PDO::PARAM_INT);
                $mergeStmt->bindValue(':user_type', $sessionData['session_user_type'], \PDO::PARAM_STR);
                $mergeStmt->execute();
                return true;
            }
            $updateStmt = $this->pdo->prepare("UPDATE {$this->table} SET {$this->dataCol} = :data, {$this->timeCol} = :time, {$this->useridCol} = :user_id, {$this->usertypeCol} = :user_type WHERE {$this->idCol} = :id");
            $updateStmt->bindParam(':id', $sessionId, \PDO::PARAM_STR);
            $updateStmt->bindParam(':data', $encoded, \PDO::PARAM_STR);
            $updateStmt->bindValue(':time', time(), \PDO::PARAM_INT);
            $updateStmt->bindValue(':user_id', $sessionData['session_user_id'], \PDO::PARAM_INT);
            $updateStmt->bindValue(':user_type', $sessionData['session_user_type'], \PDO::PARAM_STR);
            $updateStmt->execute();
            if (!$updateStmt->rowCount()) {
                try {
                    $insertStmt = $this->pdo->prepare("INSERT INTO {$this->table} ({$this->idCol}, {$this->dataCol}, {$this->timeCol}, {$this->useridCol}, {$this->usertypeCol}) VALUES (:id, :data, :time, :user_id, :user_type)");
                    $insertStmt->bindParam(':id', $sessionId, \PDO::PARAM_STR);
                    $insertStmt->bindParam(':data', $encoded, \PDO::PARAM_STR);
                    $insertStmt->bindValue(':time', time(), \PDO::PARAM_INT);
                    $insertStmt->bindValue(':user_id', $sessionData['session_user_id'], \PDO::PARAM_INT);
                    $insertStmt->bindValue(':user_type', $sessionData['session_user_type'], \PDO::PARAM_STR);
                    $insertStmt->execute();
                } catch (\PDOException $e) {
                    if (0 === strpos($e->getCode(), '23')) {
                        $updateStmt->execute();
                    } else {
                        throw $e;
                    }
                }
            }
        } catch (\PDOException $e) {
            throw new \RuntimeException(sprintf('PDOException was thrown when trying to write the session data: %s', $e->getMessage()), 0, $e);
        }
        return true;
    }
    private function getMergeSql()
    {
        return "INSERT INTO {$this->table} ({$this->idCol}, {$this->dataCol}, {$this->timeCol}, {$this->useridCol}, {$this->usertypeCol}) VALUES (:id, :data, :time, :user_id, :user_type) " . "ON DUPLICATE KEY UPDATE {$this->dataCol} = VALUES({$this->dataCol}), {$this->timeCol} = VALUES({$this->timeCol}), {$this->useridCol} = VALUES({$this->useridCol}), {$this->usertypeCol} = VALUES({$this->usertypeCol})";
    }
    protected function getConnection()
    {
        return $this->pdo;
    }
}
}

namespace Ecjia\System\Frameworks\Sessions\Handler {
use Ecjia\System\Frameworks\Contracts\EcjiaSessionInterface;
use Ecjia\System\Frameworks\Sessions\Traits\EcjiaSessionSpecTrait;
class RedisSessionHandler implements \SessionHandlerInterface, EcjiaSessionInterface
{
    use EcjiaSessionSpecTrait;
    private $redis;
    private $ttl;
    private $prefix;
    public function __construct($redis, array $options = array())
    {
        $diff = array_diff(array_keys($options), array('prefix', 'expiretime'));
        if ($diff) {
            throw new \InvalidArgumentException(sprintf('The following options are not supported "%s"', implode(', ', $diff)));
        }
        $this->redis = $redis;
        $this->ttl = isset($options['expiretime']) ? (int) $options['expiretime'] : 86400;
        $this->prefix = isset($options['prefix']) ? $options['prefix'] : 'sf2s';
    }
    public function open($savePath, $sessionName)
    {
        return true;
    }
    public function close()
    {
        return true;
    }
    public function read($sessionId)
    {
        return $this->redis->get($this->sessionId($sessionId)) ?: '';
    }
    public function write($sessionId, $data)
    {
        $result = $this->redis->setex($this->sessionId($sessionId), $this->ttl, $data);
        return $result ? 0 : 1;
    }
    public function destroy($sessionId)
    {
        return $this->redis->del($this->sessionId($sessionId));
    }
    public function gc($maxlifetime)
    {
        return true;
    }
    public function getDriver()
    {
        return $this->redis;
    }
    protected function sessionId($sessionId)
    {
        return $this->prefix . 'session:' . $sessionId;
    }
}
}

namespace Ecjia\System\Config {
use Closure;
use ArrayAccess;
use ecjia;
use Ecjia\System\Config\Exceptions\ConfigGroupRepeatException;
class DatabaseConfigRepository implements ConfigRepositoryInterface, ArrayAccess
{
    protected $defaultGroup = 'shop';
    protected $items = array();
    protected $afterLoad = array();
    protected $tableModel;
    protected $parsed = array();
    public function __construct($tableModel)
    {
        $this->tableModel = $tableModel;
    }
    public function allKeys()
    {
        $itemKeys = array_keys($this->all());
        $groupKeys = array_keys($this->getGroups());
        return array_merge($groupKeys, $itemKeys);
    }
    public function all()
    {
        $this->load('shop');
        $collection = array_get($this->items, 'shop');
        return $collection->toArray();
    }
    public function has($key)
    {
        $default = microtime(true);
        return $this->get($key, $default) !== $default;
    }
    public function get($key, $default = null)
    {
        list($group, $item) = $this->parseKey($key);
        $collection = $this->getCollection($group);
        $this->load($collection);
        return array_get($this->items[$collection], $item, $default);
    }
    public function set($key, $value)
    {
        list($group, $item) = $this->parseKey($key);
        $collection = $this->getCollection($group);
        $this->load($collection);
        if (is_null($item)) {
            $this->items[$collection] = $value;
        } else {
            $this->items[$collection]->set($item, $value);
        }
    }
    public function write($key, $value)
    {
        list($group, $item) = $this->parseKey($key);
        $this->tableModel->writeItem($item, $value);
        $this->set($key, $value);
    }
    public function add($group, $key, $value, $options = [])
    {
        list($agroup, $item) = $this->parseKey($key);
        if ($this->has($item)) {
            return false;
        }
        if (!$this->hasGroup($group)) {
            $group_id = $this->addGroup($group);
        } else {
            $group_id = $this->getGroup($group);
        }
        $collection = $this->getCollection($agroup);
        $this->items[$collection]->put($item, $value);
        return $this->tableModel->addItem($group_id, $item, $value, $options);
    }
    public function change($group, $key, $value, $options = [])
    {
        list($agroup, $item) = $this->parseKey($key);
        if (!$this->has($item)) {
            return false;
        }
        if (!$this->hasGroup($group)) {
            $group_id = $this->addGroup($group);
        } else {
            $group_id = $this->getGroup($group);
        }
        $collection = $this->getCollection($agroup);
        $this->items[$collection]->set($item, $value);
        return $this->tableModel->changeItem($group_id, $item, $value, $options);
    }
    public function delete($key)
    {
        list($group, $item) = $this->parseKey($key);
        $collection = $this->getCollection($group);
        $this->load($collection);
        if ($item) {
            $this->items[$collection]->forget($item);
            $result = $this->tableModel->deleteItem($item);
        }
        return $result;
    }
    public function getGroups()
    {
        $this->load('group');
        $collection = array_get($this->items, 'group');
        return $collection->toArray();
    }
    public function hasGroup($group)
    {
        $groups = $this->getGroups();
        if (empty($groups)) {
            return false;
        }
        $default = microtime(true);
        return array_get($groups, $group, $default) !== $default;
    }
    public function getGroup($group, $default = null)
    {
        $groups = $this->getGroups();
        if (empty($groups)) {
            return 0;
        }
        return array_get($groups, $group, $default);
    }
    public function deleteGroup($group)
    {
        $this->tableModel->deleteGroup($group);
        $this->items['group']->forget('group');
    }
    public function addGroup($group, $id = null)
    {
        $allKeys = $this->allKeys();
        if (array_get($allKeys, $group)) {
            throw new ConfigGroupRepeatException("Config group [{$group}] already exists.");
        }
        $id = $this->tableModel->addGroup($group, $id);
        $this->items['group']->put($group, $id);
        return $id;
    }
    public function getAddonConfig($code, $unserialize = false, $use_platform = false)
    {
        if ($use_platform) {
            $code = 'addon_' . ecjia::current_platform() . '_' . $code;
        } else {
            $code = 'addon_' . $code;
        }
        if ($this->has($code)) {
            $value = $this->get($code);
        } else {
            $this->add('addon', $code, null, ['type' => 'hidden']);
            $value = null;
        }
        if ($unserialize) {
            $value or $value = serialize(array());
            $value = unserialize($value);
        }
        return $value;
    }
    public function writeAddonConfig($code, $value, $serialize = false, $use_platform = false)
    {
        if ($use_platform) {
            $code = 'addon_' . ecjia::current_platform() . '_' . $code;
        } else {
            $code = 'addon_' . $code;
        }
        if ($serialize) {
            $value or $value = array();
            $value = serialize($value);
        }
        if ($this->has($code)) {
            $result = $this->write($code, $value);
        } else {
            $result = $this->add('addon', $code, $value, ['type' => 'hidden']);
        }
        return $result;
    }
    public function clearCache()
    {
        return $this->tableModel->clearCache();
    }
    protected function parseKey($key)
    {
        if (isset($this->parsed[$key])) {
            return $this->parsed[$key];
        }
        $segments = explode('.', $key);
        if (strpos($key, '.') === false) {
            $parsed = $this->parseBasicSegments($segments);
        }
        return $this->parsed[$key] = $parsed;
    }
    protected function parseBasicSegments(array $segments)
    {
        $group = $segments[0];
        if (count($segments) == 1) {
            return array(null, $group);
        } else {
            $item = implode('.', array_slice($segments, 1));
            return array($group, $item);
        }
    }
    protected function getCollection($group = null)
    {
        $group = $group ?: $this->defaultGroup;
        return $group;
    }
    protected function load($group)
    {
        if (isset($this->items[$group])) {
            return;
        }
        $items = $this->tableModel->load($group);
        if (isset($this->afterLoad[$group])) {
            $items = $this->callAfterLoad($group, $items);
        }
        $this->items[$group] = $items;
    }
    protected function callAfterLoad($group, $items)
    {
        $callback = $this->afterLoad[$group];
        return call_user_func($callback, $this, $items);
    }
    public function afterLoading($group, Closure $callback)
    {
        $this->afterLoad[$group] = $callback;
    }
    public function getAfterLoadCallbacks()
    {
        return $this->afterLoad;
    }
    public function getItems()
    {
        return $this->items;
    }
    public function offsetExists($key)
    {
        return $this->has($key);
    }
    public function offsetGet($key)
    {
        return $this->get($key);
    }
    public function offsetSet($key, $value)
    {
        $this->set($key, $value);
    }
    public function offsetUnset($key)
    {
        $this->set($key, null);
    }
}
}

namespace Ecjia\System\Config {
interface ConfigRepositoryInterface
{
    public function allKeys();
    public function has($key);
    public function get($key, $default = null);
    public function set($key, $value);
    public function write($key, $value);
    public function delete($key);
    public function add($group, $key, $value, $options = []);
    public function change($group, $key, $value, $options = []);
    public function hasGroup($key);
    public function getGroups();
    public function getGroup($group, $default = null);
    public function deleteGroup($group);
    public function addGroup($group, $id = null);
}
}

namespace Ecjia\System\Config {
use Royalcms\Component\Database\Eloquent\Model;
use RC_Cache;
use RC_Hook;
class ConfigModel extends Model
{
    const CACHE_KEY = 'shop_config';
    protected $table = 'shop_config';
    public $timestamps = false;
    public function load($group)
    {
        if ($group == 'shop') {
            return $this->loadItems();
        } else {
            if ($group == 'group') {
                return $this->loadGroups();
            } else {
                return null;
            }
        }
    }
    public function writeItem($key, $value)
    {
        $this->where('code', $key)->update(['value' => $value]);
        $this->clearCache();
    }
    public function changeItem($group_id, $key, $value = null, $options = [])
    {
        $data = ['parent_id' => $group_id, 'type' => array_get($options, 'type', 'text'), 'store_range' => array_get($options, 'store_range', ''), 'store_dir' => array_get($options, 'store_dir', ''), 'sort_order' => array_get($options, 'sort_order', 0)];
        if (!is_null($value)) {
            $data['value'] = $value;
        }
        $result = $this->where('code', $key)->update($data);
        $this->clearCache();
        return $result;
    }
    public function addItem($group_id, $key, $value, $options = [])
    {
        $data = ['id' => $this->getNextItemIdByGroupId($group_id), 'parent_id' => $group_id, 'code' => $key, 'value' => $value, 'type' => array_get($options, 'type', 'text'), 'store_range' => array_get($options, 'store_range', ''), 'store_dir' => array_get($options, 'store_dir', ''), 'sort_order' => array_get($options, 'sort_order', 0)];
        $result = $this->insert($data);
        $this->clearCache();
        return $result;
    }
    public function deleteItem($key)
    {
        $result = $this->where('parent_id', '>', 0)->where('code', $key)->delete();
        $this->clearCache();
        return $result;
    }
    public function loadItems()
    {
        $items = $this->getCache();
        if (empty($items)) {
            $data = $this->select('code', 'value')->where('parent_id', '>', 0)->get();
            $items = $data->mapWithKeys(function ($item) {
                return [$item['code'] => $item['value']];
            });
            $this->setCache($items);
        }
        return RC_Hook::apply_filters('ecjia_config_item_filter', $items);
    }
    public function loadGroups()
    {
        $data = $this->select('code', 'id')->where('parent_id', 0)->where('type', 'group')->get();
        $groups = $data->mapWithKeys(function ($group) {
            return [$group['code'] => $group['id']];
        });
        return RC_Hook::apply_filters('ecjia_config_group_filter', $groups);
    }
    public function addGroup($group, $id = null)
    {
        $data = ['parent_id' => 0, 'code' => $group, 'type' => 'group'];
        if ($id) {
            $data['id'] = intval($id);
        } else {
            $data['id'] = $this->getNextGroupId();
        }
        return $this->insertGetId($data);
    }
    public function deleteGroup($group)
    {
        return $this->where('parent_id', 0)->where('code', $group)->delete();
    }
    public function getNextGroupId()
    {
        return $this->getLastGroupId() + 1;
    }
    protected function getLastGroupId()
    {
        $groups = $this->loadGroups();
        $max = $groups->values()->max();
        return $max;
    }
    protected function getLastItemIdByGroupId($group_id)
    {
        $id = $this->where('parent_id', $group_id)->max('id');
        $id = $id ?: '00';
        return substr($id, -2);
    }
    public function getNextItemIdByGroupId($group_id)
    {
        return intval($group_id . $this->getLastItemIdByGroupId($group_id) + 1);
    }
    protected function setCache($items)
    {
        $items = $items->toArray();
        return RC_Cache::app_cache_set(self::CACHE_KEY, $items, 'system');
    }
    protected function getCache()
    {
        $items = RC_Cache::app_cache_get(self::CACHE_KEY, 'system');
        if (!empty($items) && is_array($items)) {
            return collect($items);
        }
        return null;
    }
    public function clearCache()
    {
        return RC_Cache::app_cache_delete(self::CACHE_KEY, 'system');
    }
}
}

namespace Ecjia\System\Config {
use Royalcms\Component\Foundation\Royalcms;
class Config
{
    use CompatibleTrait;
    protected $repository;
    public function __construct(ConfigRepositoryInterface $repository)
    {
        $this->repository = $repository;
    }
    public function getRepository()
    {
        return $this->repository;
    }
    public function allKeys()
    {
        return $this->getRepository()->allKeys();
    }
    public function all()
    {
        return $this->getRepository()->all();
    }
    public function get($key, $default = null)
    {
        return $this->getRepository()->get($key, $default);
    }
    public function set($key, $value)
    {
        return $this->getRepository()->set($key, $value);
    }
    public function write($key, $value)
    {
        return $this->getRepository()->write($key, $value);
    }
    public function has($key)
    {
        return $this->getRepository()->has($key);
    }
    public function add($group, $key, $value, $options = [])
    {
        return $this->getRepository()->add($group, $key, $value, $options);
    }
    public function change($group, $key, $value, $options = [])
    {
        return $this->getRepository()->change($group, $key, $value, $options);
    }
    public function delete($key)
    {
        return $this->getRepository()->delete($key);
    }
    public function getGroups()
    {
        return $this->getRepository()->getGroups();
    }
    public function hasGroup($group)
    {
        return $this->getRepository()->hasGroup($group);
    }
    public function getGroup($group, $default = null)
    {
        return $this->getRepository()->getGroup($group, $default);
    }
    public function deleteGroup($group)
    {
        return $this->getRepository()->deleteGroup($group);
    }
    public function addGroup($group, $id = null)
    {
        return $this->getRepository()->addGroup($group, $id);
    }
    public function clearCache()
    {
        return $this->getRepository()->clearCache();
    }
    public function getAddonConfig($code, $unserialize = false, $use_platform = false)
    {
        return $this->getRepository()->getAddonConfig($code, $unserialize, $use_platform);
    }
    public function writeAddonConfig($code, $value, $serialize = false, $use_platform = false)
    {
        return $this->getRepository()->writeAddonConfig($code, $value, $serialize, $use_platform);
    }
}
}

namespace Ecjia\System\Config {
use ecjia;
trait CompatibleTrait
{
    public static function instance()
    {
        return royalcms('ecjia.config');
    }
    public function reload_config()
    {
        return true;
    }
    public function load_config()
    {
        return $this->all();
    }
    public function clear_cache()
    {
        return $this->clearCache();
    }
    public function check_config($code)
    {
        return $this->has($code);
    }
    public function check_exists($code)
    {
        return $this->has($code);
    }
    public function read_config($code)
    {
        return $this->get($code);
    }
    public function write_config($code, $value)
    {
        return $this->write($code, $value);
    }
    public function insert_config($parent, $code, $value, $options = array())
    {
        return $this->add($parent, $code, $value, $options);
    }
    public function delete_config($code)
    {
        return $this->delete($code);
    }
    public function add_group($code, $id = null)
    {
        return $this->addGroup($code, $id);
    }
    public function check_group($code)
    {
        return $this->hasGroup($code);
    }
    public function load_group()
    {
        return $this->getGroups()->toArray();
    }
    public function read_group($code)
    {
        return $this->getGroup($code);
    }
    public function delete_group($code)
    {
        return $this->deleteGroup($code);
    }
    public function get_addon_config($code, $unserialize = false, $use_platform = false)
    {
        return $this->getAddonConfig($code, $unserialize, $use_platform);
    }
    public function set_addon_config($code, $value, $serialize = false, $use_platform = false)
    {
        return $this->writeAddonConfig($code, $value, $serialize, $use_platform);
    }
}
}

namespace Ecjia\System\Theme {
use ecjia;
use RC_Hook;
use Royalcms\Component\Support\Manager;
class ThemeManager extends Manager
{
    private $availableThemes = array();
    private $defaultThemeName = 'default';
    public function __construct($royalcms)
    {
        parent::__construct($royalcms);
        $this->loadAvailableThemes();
    }
    public function hasDriver($driver)
    {
        return isset($this->drivers[$driver]) ? true : false;
    }
    public function getDefaultDriver()
    {
        if (in_array($this->getTemplateName(), $this->availableThemes)) {
            return $this->getTemplateName();
        } else {
            return $this->defaultThemeName;
        }
    }
    public function getAvailableThemes()
    {
        $availableThemes = array();
        foreach ($this->availableThemes as $theme) {
            $availableThemes[$theme] = new Theme($theme);
        }
        return $availableThemes;
    }
    public function createDefaultDriver()
    {
        return new Theme($this->defaultThemeName);
    }
    protected function loadAvailableThemes()
    {
        if (is_dir(SITE_THEME_PATH)) {
            $theme_dir = opendir(SITE_THEME_PATH);
            while (false != ($file = readdir($theme_dir))) {
                if ($file != '.' && $file != '..' && $file != '.svn' && $file != '.git' && $file != 'index.htm' && $file != 'index.html' && is_dir(SITE_THEME_PATH . $file)) {
                    $this->availableThemes[] = $file;
                    $this->extend($file, function ($royalcms) use($file) {
                        return new Theme($file);
                    });
                }
            }
            closedir($theme_dir);
        }
    }
    public function getTemplateCode()
    {
        return RC_Hook::apply_filters('ecjia_theme_template_code', 'template');
    }
    public function getTemplateName()
    {
        return ecjia::config($this->getTemplateCode());
    }
    public function getStyleCode()
    {
        return RC_Hook::apply_filters('ecjia_theme_stylename_code', 'stylename');
    }
    public function getStyleName()
    {
        return ecjia::config($this->getStyleCode());
    }
}
}

namespace Ecjia\System\Theme {
class Theme
{
    protected $theme_code;
    protected $theme_styles = array();
    protected $theme_dir;
    protected $library_dir;
    protected $library_bak_dir;
    protected $default_style;
    protected $theme_url;
    public function __construct($themeCode)
    {
        $this->theme_code = $themeCode;
        $this->theme_dir = SITE_THEME_PATH . $this->theme_code . DIRECTORY_SEPARATOR;
        $this->library_dir = $this->theme_dir . 'library' . DIRECTORY_SEPARATOR;
        $this->theme_url = \RC_Theme::get_theme_root_uri() . '/' . $this->theme_code . '/';
        $this->theme_styles = $this->loadThemeStyles();
        $this->library_bak_dir = SITE_CACHE_PATH . 'backup' . DIRECTORY_SEPARATOR . 'library' . DIRECTORY_SEPARATOR;
        $this->createLibraryBakDir();
    }
    protected function createLibraryBakDir()
    {
        if (!is_dir($this->library_bak_dir)) {
            royalcms('files')->makeDirectory($this->library_bak_dir, 0755, true, true);
        }
    }
    protected function loadThemeStyles()
    {
        $available_styles = $this->findAvailableStyles();
        $themes = array();
        $themes[] = $this->loadDefaultStyle()->process();
        foreach ($available_styles as $key => $value) {
            $themes[] = $this->loadSpecifyStyle($value)->process();
        }
        return $themes;
    }
    public function getThemeStyles()
    {
        return $this->theme_styles;
    }
    public function findAvailableStyles()
    {
        $available_styles = array();
        if (file_exists($this->theme_dir)) {
            $tpl_style_dir = opendir($this->theme_dir);
            while (false != ($file = readdir($tpl_style_dir))) {
                if ($file != '.' && $file != '..' && $file != '.svn' && $file != 'git' && $file != 'index.htm' && $file != 'index.html' && is_file($this->theme_dir . $file)) {
                    if ($this->matchStyleFile($file)) {
                        $this->findStyleName($file, $available_styles);
                    }
                }
            }
            closedir($tpl_style_dir);
        }
        return $available_styles;
    }
    private function matchStyleFile($file)
    {
        if (preg_match("/^(style|style_)(.*)*/i", $file)) {
            return true;
        } else {
            return false;
        }
    }
    private function findStyleName($file, array &$styles)
    {
        $start = strpos($file, '.');
        $temp = substr($file, 0, $start);
        $temp = explode('_', $temp);
        if (count($temp) == 2) {
            $styles[] = $temp[1];
        }
    }
    protected function loadTemplateFiles()
    {
        $files = array();
        if (file_exists($this->theme_dir)) {
            $template_handle = opendir($this->theme_dir);
            while (false != ($file = readdir($template_handle))) {
                if (substr($file, -7) == 'dwt.php') {
                    $filename = substr($file, 0, -8);
                    $files[$filename] = with(new ThemeTemplate($this, $file))->getFileinfo();
                }
            }
            closedir($template_handle);
        }
        return $files;
    }
    public function getAllowSettingTemplates()
    {
        $files = $this->loadTemplateFiles();
        foreach ($files as $key => &$file) {
            if (!$file['Libraries']) {
                unset($files[$key]);
            }
        }
        return $files;
    }
    public function getLibraryFiles()
    {
        $files = $this->loadLibraryFiles();
        foreach ($files as $key => $file) {
            if (!$file['Name'] || !$file['Description']) {
                unset($files[$key]);
            }
        }
        return $files;
    }
    public function getAllLibraryFiles()
    {
        return $this->loadLibraryFiles();
    }
    protected function loadLibraryFiles()
    {
        $files = array();
        if (is_dir($this->library_dir)) {
            $library_handle = opendir($this->library_dir);
            while (false != ($file = readdir($library_handle))) {
                if (substr($file, -7) == 'lbi.php') {
                    $filename = substr($file, 0, -8);
                    $files[$filename] = with(new ThemeLibrary($this, $file))->getFileinfo();
                }
            }
            closedir($library_handle);
        }
        return $files;
    }
    public function getDefaultStyle()
    {
        return $this->default_style;
    }
    protected function loadDefaultStyle()
    {
        $this->default_style = new ParseThemeStyle($this);
        return $this->default_style;
    }
    public function loadSpecifyStyle($stylename)
    {
        return new ParseThemeStyle($this, $stylename);
    }
    public function getThemeDir()
    {
        return $this->theme_dir;
    }
    public function getThemeUrl()
    {
        return $this->theme_url;
    }
    public function getThemeCode()
    {
        return $this->theme_code;
    }
    public function getLibraryDir()
    {
        return $this->library_dir;
    }
    public function getLibraryBakDir()
    {
        return $this->library_bak_dir;
    }
}
}

namespace Ecjia\System\Theme {
class ParseThemeStyle
{
    private $template_name;
    private $template_uri;
    private $template_desc;
    private $template_version;
    private $template_author;
    private $author_uri;
    private $logo_filename;
    private $template_type;
    private $template_color;
    private $stylename;
    private $screenshot;
    private $style;
    private $style_path;
    private $theme;
    public function __construct(Theme $theme, $stylename = null)
    {
        $this->theme = $theme;
        $this->stylename = $stylename;
        $this->parseScreenshot();
        $this->parseStyle();
    }
    protected function parseScreenshot()
    {
        $ext = array('png', 'gif', 'jpg', 'jpeg');
        if ($this->stylename) {
            foreach ($ext as $val) {
                if (file_exists($this->theme->getThemeDir() . 'images/screenshot_' . $this->stylename . '.' . $val)) {
                    $this->screenshot = $this->theme->getThemeUrl() . 'images/screenshot_' . $this->stylename . '.' . $val;
                    break;
                }
            }
        } else {
            $this->screenshot = null;
        }
        if (!$this->screenshot) {
            foreach ($ext as $val) {
                if (file_exists($this->theme->getThemeDir() . 'images/screenshot.' . $val)) {
                    $this->screenshot = $this->theme->getThemeUrl() . 'images/screenshot.' . $val;
                    break;
                }
            }
        }
    }
    protected function parseStyle()
    {
        $this->style = $this->theme->getThemeUrl() . 'style.css';
        $this->style_path = $this->theme->getThemeDir() . 'style.css';
        if ($this->stylename) {
            $css_stylename_path = $this->theme->getThemeDir() . 'style_' . $this->stylename . '.css';
            $css_stylename_url = $this->theme->getThemeUrl() . 'style_' . $this->stylename . '.css';
        } else {
            $css_stylename_path = null;
        }
        if (file_exists($css_stylename_path)) {
            $this->style = $css_stylename_url;
            $this->style_path = $css_stylename_path;
        }
        if (file_exists($this->style_path)) {
            $theme_data = \RC_Theme::get_theme_data($this->style_path, false, false);
            $this->template_name = $theme_data['Name'];
            $this->template_uri = $theme_data['TemplateURI'];
            $this->template_desc = $theme_data['Description'];
            $this->template_version = $theme_data['Version'];
            $this->template_author = $theme_data['Author'];
            $this->author_uri = $theme_data['AuthorURI'];
            $this->logo_filename = $theme_data['Logo'];
            $this->template_type = $theme_data['TemplateType'];
            $this->template_color = $theme_data['Color'];
        }
    }
    public function process()
    {
        return array('name' => $this->template_name, 'uri' => $this->template_uri, 'desc' => $this->template_desc, 'version' => $this->template_version, 'author' => $this->template_author, 'author_uri' => $this->author_uri, 'logo' => $this->logo_filename, 'type' => $this->template_type, 'color' => $this->template_color, 'screenshot' => $this->screenshot, 'style' => $this->style, 'stylename' => $this->stylename, 'code' => $this->theme->getThemeCode());
    }
    public function __toString()
    {
        return var_export($this->process(), true);
    }
    public function getName()
    {
        return $this->template_name;
    }
    public function getUri()
    {
        return $this->template_uri;
    }
    public function getDesc()
    {
        return $this->template_desc;
    }
    public function getVersion()
    {
        return $this->template_version;
    }
    public function getAuthor()
    {
        return $this->template_author;
    }
    public function getAuthorUri()
    {
        return $this->author_uri;
    }
    public function getLogo()
    {
        return $this->logo_filename;
    }
    public function getType()
    {
        return $this->template_type;
    }
    public function getColor()
    {
        return $this->template_color;
    }
    public function getScreenshot()
    {
        return $this->screenshot;
    }
    public function getStyle()
    {
        return $this->style;
    }
}
}

namespace Ecjia\System\BaseController {
use RC_Hook;
use ecjia_loader;
use Royalcms\Component\Routing\Controller as RoyalcmsController;
abstract class BasicController extends RoyalcmsController
{
    public function __construct()
    {
        $this->load_default_script_style();
        RC_Hook::do_action('ecjia_basic_finish_launching');
    }
    protected function session_start()
    {
    }
    protected function load_hooks()
    {
        RC_Hook::add_action('front_enqueue_scripts', array($this, 'front_enqueue_scripts'), 1);
        RC_Hook::add_action('front_print_styles', array($this, 'front_print_head_styles'), 8);
        RC_Hook::add_action('front_print_scripts', array($this, 'front_print_head_scripts'), 9);
        RC_Hook::add_action('front_print_footer_scripts', array($this, 'print_front_footer_scripts'), 20);
    }
    protected function load_default_script_style()
    {
    }
    public function front_enqueue_scripts()
    {
    }
    public final function print_front_footer_scripts()
    {
        $this->front_print_late_styles();
        $this->front_print_footer_scripts();
    }
    public function front_print_head_styles()
    {
        ecjia_loader::print_head_styles();
    }
    public function front_print_head_scripts()
    {
        ecjia_loader::print_head_scripts();
    }
    public function front_print_footer_scripts()
    {
        ecjia_loader::print_footer_scripts();
    }
    public function front_print_late_styles()
    {
        ecjia_loader::print_late_styles();
    }
}
}

namespace Ecjia\System\BaseController {
use ecjia;
use Ecjia\System\Frameworks\Component\ShowMessage\Options\JsonShowMessageOption;
use Ecjia\System\Frameworks\Component\ShowMessage\Options\PjaxShowMessageOption;
use Ecjia\System\Frameworks\Component\ShowMessage\ShowMessage;
use ecjia_utility;
use RC_DB;
use RC_Redirect;
use RC_Response;
use RC_Package;
use Royalcms\Component\Routing\Controller as RoyalcmsController;
defined('IN_ECJIA') or exit('No permission resources.');
abstract class EcjiaController extends RoyalcmsController
{
    protected $view;
    protected $view_method = ['display', 'fetch', 'fetch_string', 'is_cached', 'clear_cache', 'clear_all_cache', 'assign', 'assign_lang', 'clear_compiled_files', 'clear_cache_files'];
    protected $request;
    public static $view_object;
    public static $controller;
    protected $public_route = [];
    public function __construct()
    {
        $this->request = royalcms('request');
        $this->session_start();
        $this->registerServiceProvider();
        $this->registerViewServiceProvider();
        static::$controller =& $this;
        static::$view_object =& $this->view;
        if (ecjia::is_debug_display() && config('system.debug_display_query') === true) {
            RC_DB::enableQueryLog();
        }
        $this->load_hooks();
        RC_Response::header('X-XSS-Protection', '1; mode=block');
        RC_Response::header('X-Frame-Options', 'SAMEORIGIN');
    }
    public function __call($method, $parameters)
    {
        if (in_array($method, $this->view_method)) {
            return call_user_func_array(array($this->view, $method), $parameters);
        }
        return parent::__call($method, $parameters);
    }
    public function getRequest()
    {
        return $this->request;
    }
    protected function registerServiceProvider()
    {
    }
    protected function registerViewServiceProvider()
    {
        royalcms()->forgeRegister('Royalcms\\Component\\SmartyView\\SmartyServiceProvider');
        $this->view = $this->create_view();
    }
    public function isVerificationPublicRoute()
    {
        $route_m = ROUTE_M == config('system.admin_entrance') ? 'system' : ROUTE_M;
        $route_controller = $route_m . '/' . ROUTE_C . '/' . ROUTE_A;
        if (in_array($route_controller, $this->public_route)) {
            return true;
        } else {
            return false;
        }
    }
    protected function ajax($data, $type = ecjia::DATATYPE_JSON)
    {
        $type = strtoupper($type);
        switch ($type) {
            case ecjia::DATATYPE_HTML:
            case ecjia::DATATYPE_TEXT:
                return royalcms('response')->setContent($data);
                break;
            case ecjia::DATATYPE_XML:
                return $this->xml($data);
                break;
            case ecjia::DATATYPE_JSON:
            default:
                return $this->json($data);
        }
    }
    protected function xml($data)
    {
        $cookies = royalcms('response')->headers->getCookies();
        $response = RC_Response::xml($data);
        foreach ($cookies as $cookie) {
            $response->withCookie($cookie);
        }
        royalcms()->instance('response', $response);
        return $response;
    }
    protected function json($data)
    {
        $cookies = royalcms('response')->headers->getCookies();
        $response = RC_Response::json($data);
        foreach ($cookies as $cookie) {
            $response->withCookie($cookie);
        }
        royalcms()->instance('response', $response);
        return $response;
    }
    public function redirect($url, $code = 302)
    {
        $cookies = royalcms('response')->headers->getCookies();
        $response = RC_Redirect::away($url, $code);
        foreach ($cookies as $cookie) {
            $response->withCookie($cookie);
        }
        royalcms()->instance('response', $response);
        return $response;
    }
    public function exited()
    {
        royalcms('response')->send();
        exit(0);
    }
    public function redirectWithExited($url, $code = 302)
    {
        $this->redirect($url, $code);
        $this->exited();
    }
    protected function header($key, $value, $replace = true)
    {
        RC_Response::header($key, $value, $replace);
    }
    protected function alert($msg, $url = null, $parent = false)
    {
        header("Content-type: text/html; charset=utf-8");
        $alert_msg = "alert('{$msg}');";
        if (empty($url)) {
            $gourl = 'history.go(-1);';
        } else {
            $gourl = ($parent ? 'parent' : 'window') . ".location.href = '{$url}'";
        }
        $script = "<script>" . PHP_EOL;
        $script .= $alert_msg . PHP_EOL;
        $script .= $gourl . PHP_EOL;
        $script .= "</script>" . PHP_EOL;
        $cookies = royalcms('response')->headers->getCookies();
        $response = RC_Response::make($script);
        foreach ($cookies as $cookie) {
            $response->withCookie($cookie);
        }
        royalcms()->instance('response', $response);
        return $response;
    }
    protected function message($msg = '', $url = null, $time = 2, $tpl = null)
    {
        $url = $url ? "window.location.href='" . $url . "'" : "window.history.back(-1);";
        $content = ecjia_utility::message_template($msg, $url);
        $cookies = royalcms('response')->headers->getCookies();
        $response = RC_Response::make($content);
        foreach ($cookies as $cookie) {
            $response->withCookie($cookie);
        }
        royalcms()->instance('response', $response);
        return $response;
    }
    protected function displayContent($content, $content_type = null)
    {
        $response = royalcms('response');
        if ($content_type) {
            $response->header('Content-Type', $content_type);
        }
        $response->setContent($content);
        royalcms()->instance('response', $response);
        return $response;
    }
    public function displayAppTemplate($app, $resource_name, $cache_id = null, $show = true, $options = array())
    {
        $resource_name = RC_Package::package('app::' . $app)->loadTemplate($resource_name, true);
        return $this->display($resource_name, $cache_id, $show, $options);
    }
    public function load_constants()
    {
    }
    public function showmessage($message, $msgtype = ecjia::MSGTYPE_HTML, $options = array())
    {
        $state = $msgtype & 0xf;
        $type = $msgtype & 0xf0;
        if ($type === ecjia::MSGTYPE_JSON && !is_ajax()) {
            $type = ecjia::MSGTYPE_ALERT;
        }
        if ($type === ecjia::MSGTYPE_HTML) {
            switch ($state) {
                case 1:
                    $this->assign('page_state', array('icon' => 'fontello-icon-ok-circled', 'msg' => __(''), 'class' => 'alert-success'));
                    break;
                case 2:
                    $this->assign('page_state', array('icon' => 'fontello-icon-info-circled', 'msg' => __(''), 'class' => 'alert-info'));
                    break;
                case 3:
                    $this->assign('page_state', array('icon' => 'fontello-icon-attention-circled', 'msg' => __(''), 'class' => ''));
                    break;
                default:
                    $this->assign('page_state', array('icon' => 'fontello-icon-cancel-circled', 'msg' => __(''), 'class' => 'alert-danger'));
            }
            $this->assign('ur_here', __(''));
            $this->assign('msg_detail', $message);
            $this->assign('msg_type', $state);
            if (!empty($options)) {
                foreach ($options as $key => $val) {
                    $this->assign($key, $val);
                }
            }
            return $this->message($message, null, 3);
        } elseif ($type === ecjia::MSGTYPE_ALERT) {
            $url = '';
            if (!empty($options) && !empty($options['pjaxurl'])) {
                $url = $options['pjaxurl'];
            }
            return $this->alert($message, $url);
        } elseif ($type === ecjia::MSGTYPE_JSON) {
            if ($options instanceof PjaxShowMessageOption) {
                $options->setMessage($message);
                $options->setState($state);
                return (new ShowMessage($message, $msgtype, $options))->getResponse();
            }
            $jsonOption = (new JsonShowMessageOption())->setMessage($message)->setState($state)->setOptions($options);
            return (new ShowMessage($message, $msgtype, $jsonOption))->getResponse();
        } elseif ($type === ecjia::MSGTYPE_XML) {
            return $this->ajax($message, 'xml');
        }
        return royalcms('response');
    }
    public abstract function create_view();
    protected abstract function load_hooks();
    protected abstract function session_start();
}
}

namespace Ecjia\System\BaseController {
use Ecjia\System\Frameworks\Contracts\EcjiaTemplateFileLoader;
use ecjia_view;
use RC_File;
use RC_Config;
use RC_Loader;
use Smarty;
use RC_Uri;
use RC_Response;
use RC_Hook;
use RC_Theme;
use RC_Api;
use ecjia_app;
use ecjia_loader;
abstract class SimpleController extends EcjiaController implements EcjiaTemplateFileLoader
{
    public function __construct()
    {
        parent::__construct();
        self::$controller = static::$controller;
        self::$view_object = static::$view_object;
        RC_Response::header('Cache-control', 'private');
        $this->assign_title();
        if (RC_Config::get('system.debug')) {
            error_reporting(E_ALL);
        } else {
            error_reporting(E_ALL ^ (E_NOTICE | E_WARNING));
        }
        $this->load_default_script_style();
        RC_Hook::do_action('ecjia_simple_finish_launching');
    }
    protected function session_start()
    {
    }
    public function create_view()
    {
        $view = new ecjia_view($this);
        $view->setTemplateDir($this->get_template_dir());
        $view->setCompileDir(TEMPLATE_COMPILE_PATH . 'simple' . DIRECTORY_SEPARATOR);
        if (RC_Config::get('system.debug')) {
            $view->caching = Smarty::CACHING_OFF;
            $view->cache_lifetime = 0;
            $view->debugging = true;
            $view->force_compile = true;
        } else {
            $view->caching = Smarty::CACHING_LIFETIME_CURRENT;
            $view->cache_lifetime = 1800;
            $view->debugging = false;
            $view->force_compile = false;
        }
        $view->assign('ecjia_charset', RC_CHARSET);
        $view->assign('system_static_url', RC_Uri::system_static_url() . '/');
        return $view;
    }
    public function get_template_dir()
    {
        if (RC_Loader::exists_site_app(ROUTE_M)) {
            $dir = SITE_APP_PATH . ROUTE_M . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . 'front' . DIRECTORY_SEPARATOR;
        } else {
            $dir = RC_APP_PATH . ROUTE_M . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . 'front' . DIRECTORY_SEPARATOR;
        }
        return $dir;
    }
    public function get_template_file($file)
    {
        $style = RC_Theme::get_template();
        if (is_null($file)) {
            $file = SITE_THEME_PATH . $style . DIRECTORY_SEPARATOR . ROUTE_M . DIRECTORY_SEPARATOR . ROUTE_C . '_' . ROUTE_A;
        } elseif (!RC_File::is_absolute_path($file)) {
            $file = SITE_THEME_PATH . $style . DIRECTORY_SEPARATOR . $file;
        }
        if (!preg_match('@\\.[a-z]+$@', $file)) {
            $file .= RC_Config::get('system.tpl_fix');
        }
        if (is_file($file)) {
            return $file;
        } else {
            if (RC_Config::get('system.debug')) {
                rc_die("Template does not exist.:{$file}");
            } else {
                return null;
            }
        }
    }
    public final function display($tpl_file = null, $cache_id = null, $show = true, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (RC_Config::get('system.tpl_usedfront') && !RC_File::is_absolute_path($tpl_file)) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        return parent::display($tpl_file, $cache_id, $show, $options);
    }
    public final function fetch($tpl_file = null, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (RC_Config::get('system.tpl_usedfront') && !RC_File::is_absolute_path($tpl_file)) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        return parent::fetch($tpl_file, $cache_id, $options);
    }
    public final function is_cached($tpl_file, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (RC_Config::get('system.tpl_usedfront')) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        $is_cached = parent::is_cached($tpl_file, $cache_id, $options);
        $purge = royalcms('request')->query('purge', 0);
        $purge = intval($purge);
        if ($is_cached && $purge === 1) {
            parent::clear_cache($tpl_file, $cache_id, $options);
            return false;
        }
        return $is_cached;
    }
    protected function message($msg = '', $url = null, $time = 2, $tpl = null)
    {
        $revise_url = $url ? "window.location.href='" . $url . "'" : "window.history.back(-1);";
        $front_tpl = SITE_THEME_PATH . RC_Config::get('system.tpl_style') . DIRECTORY_SEPARATOR . RC_Config::get('system.tpl_message');
        if ($tpl) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            $tpl = SITE_THEME_PATH . RC_Config::get('system.tpl_style') . DIRECTORY_SEPARATOR . $tpl;
            return $this->display($tpl);
        } elseif (file_exists($front_tpl)) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            return $this->display($front_tpl);
        } else {
            return parent::message($msg, $url, $time, $tpl);
        }
    }
    public function assign_title($title = '')
    {
        $title_suffix = RC_Hook::apply_filters('page_title_suffix', ' - Powered by ECJia');
        $this->assign('page_title', $title . $title_suffix);
    }
    protected function load_hooks()
    {
        RC_Hook::add_action('front_enqueue_scripts', array($this, 'front_enqueue_scripts'), 1);
        RC_Hook::add_action('front_print_styles', array($this, 'front_print_head_styles'), 8);
        RC_Hook::add_action('front_print_scripts', array($this, 'front_print_head_scripts'), 9);
        RC_Hook::add_action('front_print_footer_scripts', array($this, 'print_front_footer_scripts'), 20);
    }
    protected function load_default_script_style()
    {
    }
    public function front_enqueue_scripts()
    {
    }
    public final function print_front_footer_scripts()
    {
        $this->front_print_late_styles();
        $this->front_print_footer_scripts();
    }
    public function front_print_head_styles()
    {
        ecjia_loader::print_head_styles();
    }
    public function front_print_head_scripts()
    {
        ecjia_loader::print_head_scripts();
    }
    public function front_print_footer_scripts()
    {
        ecjia_loader::print_footer_scripts();
    }
    public function front_print_late_styles()
    {
        ecjia_loader::print_late_styles();
    }
}
}

namespace Ecjia\System\BaseController {
use ecjia;
use Ecjia\System\Frameworks\Contracts\EcjiaTemplateFileLoader;
use ecjia_app;
use Ecjia_ThemeManager;
use ecjia_view;
use InvalidArgumentException;
use RC_File;
use RC_Hook;
use RC_Session;
use RC_Theme;
use RC_Uri;
use Smarty;
abstract class SmartyController extends EcjiaController implements EcjiaTemplateFileLoader
{
    public function __construct()
    {
        parent::__construct();
        if (config('system.debug')) {
            error_reporting(E_ALL);
        } else {
            error_reporting(E_ALL ^ (E_NOTICE | E_WARNING));
        }
        RC_Hook::do_action('ecjia_smarty_finish_launching');
    }
    protected function session_start()
    {
        RC_Hook::add_filter('royalcms_session_name', function ($sessin_name) {
            return config('session.session_name');
        });
        RC_Hook::add_filter('royalcms_session_id', function ($sessin_id) {
            return RC_Hook::apply_filters('ecjia_front_session_id', $sessin_id);
        });
        RC_Session::start();
    }
    public function create_view()
    {
        $view = new ecjia_view($this);
        $view->setTemplateDir(SITE_THEME_PATH . RC_Theme::get_template() . DIRECTORY_SEPARATOR);
        $view->addPluginsDir(SITE_THEME_PATH . RC_Theme::get_template() . DIRECTORY_SEPARATOR . 'smarty' . DIRECTORY_SEPARATOR);
        $view->setCompileDir(TEMPLATE_COMPILE_PATH . 'front' . DIRECTORY_SEPARATOR);
        if (config('system.debug')) {
            $view->caching = Smarty::CACHING_OFF;
            $view->cache_lifetime = 0;
            $view->debugging = true;
            $view->force_compile = true;
        } else {
            $view->caching = Smarty::CACHING_LIFETIME_CURRENT;
            $view->cache_lifetime = ecjia::config('cache_time');
            $view->debugging = false;
            $view->force_compile = false;
        }
        $view->assign('ecjia_charset', RC_CHARSET);
        $view->assign('theme_url', RC_Theme::get_template_directory_uri() . '/');
        $view->assign('system_static_url', RC_Uri::system_static_url() . '/');
        try {
            $css_path = Ecjia_ThemeManager::driver(Ecjia_ThemeManager::getTemplateName())->loadSpecifyStyle(Ecjia_ThemeManager::getStyleName())->getStyle();
            $view->assign('theme_css_path', $css_path);
        } catch (InvalidArgumentException $e) {
        }
        return $view;
    }
    public function get_template_dir()
    {
        $style = RC_Theme::get_template();
        $dir = SITE_THEME_PATH . $style . DIRECTORY_SEPARATOR;
        return $dir;
    }
    public function get_template_file($file)
    {
        $style = RC_Theme::get_template();
        if (is_null($file)) {
            $file = SITE_THEME_PATH . $style . DIRECTORY_SEPARATOR . ROUTE_M . DIRECTORY_SEPARATOR . ROUTE_C . '_' . ROUTE_A;
        } elseif (!RC_File::is_absolute_path($file)) {
            $file = SITE_THEME_PATH . $style . DIRECTORY_SEPARATOR . $file;
        }
        if (!preg_match('@\\.[a-z]+$@', $file)) {
            $file .= config('system.tpl_fix');
        }
        if (is_file($file)) {
            return $file;
        }
        if (config('system.debug')) {
            rc_die("Template does not exist.:{$file}");
        }
        return str_replace($this->get_template_dir(), '', $file);
    }
    public function display($tpl_file = null, $cache_id = null, $show = true, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (config('system.tpl_usedfront') && !RC_File::is_absolute_path($tpl_file)) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        return parent::display($tpl_file, $cache_id, $show, $options);
    }
    public function fetch($tpl_file = null, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (config('system.tpl_usedfront') && !RC_File::is_absolute_path($tpl_file)) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        return parent::fetch($tpl_file, $cache_id, $options);
    }
    public final function is_cached($tpl_file, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (config('system.tpl_usedfront') && !RC_File::is_absolute_path($tpl_file)) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        $is_cached = parent::is_cached($tpl_file, $cache_id, $options);
        $purge = royalcms('request')->query('purge', 0);
        $purge = intval($purge);
        if ($is_cached && $purge === 1) {
            $this->clear_cache($tpl_file, $cache_id, $options);
            return false;
        }
        return $is_cached;
    }
    public function clear_cache($tpl_file, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
            if (config('system.tpl_usedfront')) {
                $tpl_file = ecjia_app::get_app_template($tpl_file, ROUTE_M, false);
            }
        }
        return parent::clear_cache($tpl_file, $cache_id, $options);
    }
    public function assign_title($title = '')
    {
        $title_suffix = RC_Hook::apply_filters('page_title_suffix', ' - Powered by ECJia');
        if (empty($title)) {
            $this->assign('page_title', ecjia::config('shop_title') . $title_suffix);
        } else {
            $this->assign('page_title', $title . '-' . ecjia::config('shop_title') . $title_suffix);
        }
    }
}
}

namespace Ecjia\System\BaseController {
use admin_menu;
use admin_nav_here;
use ecjia;
use Ecjia\System\Frameworks\Contracts\EcjiaTemplateFileLoader;
use ecjia_admin_log;
use ecjia_admin_menu;
use ecjia_app;
use ecjia_config;
use ecjia_editor;
use ecjia_notification;
use ecjia_screen;
use ecjia_view;
use RC_Config;
use RC_Cookie;
use RC_ENV;
use RC_File;
use RC_Hook;
use RC_Ip;
use RC_Loader;
use RC_Plugin;
use RC_Script;
use RC_Session;
use RC_Style;
use RC_Time;
use RC_Uri;
use Smarty;
abstract class EcjiaAdminController extends EcjiaController implements EcjiaTemplateFileLoader
{
    public function __construct()
    {
        define('IN_ADMIN', true);
        parent::__construct();
        self::$controller = static::$controller;
        self::$view_object = static::$view_object;
        if (defined('DEBUG_MODE') == false) {
            define('DEBUG_MODE', 2);
        }
        RC_Loader::load_sys_func('global');
        RC_Loader::load_sys_func('general_template');
        clearstatcache();
        if (empty(ecjia_screen::$current_screen)) {
            ecjia_screen::set_current_screen();
        }
        RC_Hook::add_action('admin_print_main_header', array(ecjia_screen::$current_screen, 'render_screen_meta'));
        $this->public_route = RC_Hook::apply_filters('admin_access_public_route', config('system::public_route'));
        if (!$this->_check_login()) {
            RC_Session::destroy();
            if (is_pjax()) {
                ecjia_screen::$current_screen->add_nav_here(new admin_nav_here(__('')));
                $response = $this->showmessage(__(',!'), ecjia::MSGTYPE_HTML | ecjia::MSGSTAT_ERROR, array('links' => array(array('text' => __(''), 'href' => RC_Uri::url('@privilege/login')))));
                royalcms('response')->send();
                exit;
            } elseif (is_ajax()) {
                $this->showmessage(__(',!'), ecjia::MSGTYPE_JSON | ecjia::MSGSTAT_ERROR);
                royalcms('response')->send();
                exit;
            } else {
                RC_Cookie::set('admin_login_referer', RC_Uri::current_url());
                $this->redirectWithExited(RC_Uri::url('@privilege/login'));
            }
        }
        if (RC_Config::get('system.debug')) {
            error_reporting(E_ALL);
        } else {
            error_reporting(E_ALL ^ (E_NOTICE | E_WARNING));
        }
        $this->load_default_script_style();
        $this->assign('ecjia_admin_cptitle', RC_Hook::apply_filters('ecjia_admin_cptitle', __('ECJIA ')));
        $this->assign('ecjia_admin_cpname', RC_Hook::apply_filters('ecjia_admin_cpname', 'ECJia Admin <span class="sml_t">' . VERSION . '</span>'));
        $this->assign('admin_message_is_show', RC_Hook::apply_filters('ecjia_admin_message_show', true));
        $this->assign('ecjia_config', ecjia::config());
        if (RC_Config::get('system.gzip') && RC_ENV::gzip_enabled()) {
            ob_start('ob_gzhandler');
        } else {
            ob_start();
        }
        RC_Hook::add_action('admin_enqueue_scripts', function () {
            $this->csrf_token_meta();
        });
        RC_Hook::do_action('ecjia_admin_finish_launching');
    }
    protected function registerServiceProvider()
    {
        royalcms()->register('Royalcms\\Component\\Purifier\\PurifierServiceProvider');
        royalcms()->register('Ecjia\\System\\Providers\\EcjiaAdminServiceProvider');
    }
    protected function session_start()
    {
        RC_Hook::add_filter('royalcms_session_name', function ($sessin_name) {
            return RC_Config::get('session.session_admin_name');
        });
        RC_Hook::add_filter('royalcms_session_id', function ($sessin_id) {
            return RC_Hook::apply_filters('ecjia_admin_session_id', $sessin_id);
        });
        RC_Session::start();
    }
    public function create_view()
    {
        $view = new ecjia_view($this);
        $view->setTemplateDir(SITE_SYSTEM_PATH . 'templates' . DIRECTORY_SEPARATOR);
        if (!in_array($this->get_template_dir(), $view->getTemplateDir())) {
            $view->addTemplateDir($this->get_template_dir());
        }
        $view->setCompileDir(TEMPLATE_COMPILE_PATH . 'admin' . DIRECTORY_SEPARATOR);
        if (RC_Config::get('system.debug')) {
            $view->caching = Smarty::CACHING_OFF;
            $view->debugging = true;
            $view->force_compile = true;
        } else {
            $view->caching = Smarty::CACHING_OFF;
            $view->debugging = false;
            $view->force_compile = false;
        }
        return $view;
    }
    protected function authSession()
    {
        if (session('session_user_id') && session('session_user_type') == 'admin') {
            return true;
        } else {
            return false;
        }
    }
    protected function csrf_token_meta()
    {
        echo '<meta name="csrf-token" content="' . csrf_token() . '">';
    }
    private function _check_login()
    {
        if ($this->isVerificationPublicRoute()) {
            return true;
        }
        if ($this->authSession()) {
            return true;
        }
        return (new \Ecjia\System\Admins\RememberPassword\RememberPassword())->verification(function ($model) {
            $this->admin_session($model['user_id'], $model['user_name'], $model['action_list'], $model['last_time']);
            $model->last_login = RC_Time::gmtime();
            $model->last_ip = RC_Ip::client_ip();
            $model->save();
        });
    }
    public function get_template_dir()
    {
        if (ROUTE_M != RC_Config::get('system.admin_entrance') && ROUTE_M != 'system') {
            if (RC_Loader::exists_site_app(ROUTE_M)) {
                $dir = SITE_APP_PATH . ROUTE_M . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . 'admin' . DIRECTORY_SEPARATOR;
            } else {
                $dir = RC_APP_PATH . ROUTE_M . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . 'admin' . DIRECTORY_SEPARATOR;
            }
        } else {
            $dir = SITE_SYSTEM_PATH . 'templates' . DIRECTORY_SEPARATOR;
        }
        return $dir;
    }
    public function get_template_file($file)
    {
        if (strpos($file, '/') !== 0 && strpos($file, ":\\") !== 1) {
            $file = $this->get_template_dir() . $file;
        }
        if (!preg_match('@\\.[a-z]+$@', $file)) {
            $file .= RC_Config::get('system.tpl_fix');
        }
        if (is_file($file)) {
            return $file;
        } else {
            return str_replace($this->get_template_dir(), '', $file);
        }
    }
    public final function display($tpl_file = null, $cache_id = null, $show = true, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
        }
        return parent::display($tpl_file, $cache_id, $show, $options);
    }
    public final function fetch($tpl_file = null, $cache_id = null, $options = array())
    {
        if (strpos($tpl_file, 'string:') !== 0) {
            if (RC_File::file_suffix($tpl_file) !== 'php') {
                $tpl_file = $tpl_file . '.php';
            }
        }
        return parent::fetch($tpl_file, $cache_id, $options);
    }
    protected function message($msg = '', $url = null, $time = 2, $tpl = null)
    {
        $revise_url = $url ? "window.location.href='" . $url . "'" : "window.history.back(-1);";
        $system_tpl = SITE_SYSTEM_PATH . 'templates' . DIRECTORY_SEPARATOR . RC_Config::get('system.tpl_message');
        if ($tpl) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            $tpl = SITE_SYSTEM_PATH . 'templates' . DIRECTORY_SEPARATOR . $tpl;
            return $this->display($tpl);
        } elseif (file_exists($system_tpl)) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            return $this->display($system_tpl);
        } else {
            return parent::message($msg, $url, $time, $tpl);
        }
    }
    public function admin_session($user_id, $username, $action_list, $last_time, $email = '')
    {
        RC_Session::set('admin_id', $user_id);
        RC_Session::set('admin_name', $username);
        RC_Session::set('action_list', $action_list);
        RC_Session::set('last_check_order', $last_time);
        RC_Session::set('session_user_id', $user_id);
        RC_Session::set('session_user_type', 'admin');
        RC_Session::set('email', $email);
        RC_Session::set('ip', RC_Ip::client_ip());
    }
    public static function make_admin_menu($action, $name, $link, $sort = 99, $target = '_self')
    {
        return new admin_menu($action, $name, $link, $sort, $target);
    }
    public final function admin_priv($priv_str, $msg_type = ecjia::MSGTYPE_HTML, $msg_output = true)
    {
        if (ecjia_admin_menu::singleton()->admin_priv($priv_str)) {
            return true;
        } else {
            if ($msg_output) {
                if ($msg_type == ecjia::MSGTYPE_JSON && is_ajax() && !is_pjax()) {
                    $this->showmessage(__(''), ecjia::MSGTYPE_JSON | ecjia::MSGSTAT_ERROR);
                    royalcms('response')->send();
                    die;
                } else {
                    ecjia_screen::$current_screen->add_nav_here(new admin_nav_here(__('')));
                    $this->showmessage(__(''), ecjia::MSGTYPE_HTML | ecjia::MSGSTAT_ERROR);
                    royalcms('response')->send();
                    die;
                }
            } else {
                return false;
            }
        }
    }
    public final function load_default_script_style()
    {
        RC_Style::enqueue_style('bootstrap');
        RC_Style::enqueue_style('bootstrap-responsive');
        RC_Style::enqueue_style('jquery-jBreadCrumb');
        RC_Style::enqueue_style('flags');
        RC_Style::enqueue_style('fontello');
        RC_Style::enqueue_style('ecjia');
        RC_Style::enqueue_style('ecjia-ui');
        RC_Style::enqueue_style('ecjia-function');
        RC_Style::enqueue_style('ecjia-skin-blue');
        RC_Style::enqueue_style('jquery-sticky');
        RC_Script::enqueue_script('ecjia');
        RC_Script::enqueue_script('jquery-migrate');
        RC_Script::enqueue_script('jquery-ui-touchpunch');
        RC_Script::enqueue_script('jquery-pjax');
        RC_Script::enqueue_script('jquery-cookie');
        RC_Script::enqueue_script('js-json');
        RC_Script::enqueue_script('jquery-actual');
        RC_Script::enqueue_script('jquery-sticky');
        RC_Script::enqueue_script('bootstrap');
        RC_Script::enqueue_script('jquery-ui-totop');
        RC_Script::enqueue_script('ecjia-admin');
        RC_Script::enqueue_script('ecjia-ui');
        RC_Script::enqueue_script('jquery-quicksearch');
        RC_Script::localize_script('ecjia-admin', 'admin_lang', config('system::jslang.admin_default_page'));
    }
    protected function load_hooks()
    {
        RC_Hook::add_action('admin_head', array(__CLASS__, '_ie_support_header'));
        RC_Hook::add_action('admin_head', array('ecjia_loader', 'admin_enqueue_scripts'), 1);
        RC_Hook::add_action('admin_print_scripts', array('ecjia_loader', 'print_head_scripts'), 20);
        RC_Hook::add_action('admin_print_footer_scripts', array('ecjia_loader', 'print_admin_footer_scripts'));
        RC_Hook::add_action('admin_print_styles', array('ecjia_loader', 'print_head_styles'), 20);
        RC_Hook::add_action('admin_print_main_bottom', array(__CLASS__, 'display_admin_copyright'));
        RC_Hook::add_action('admin_print_header_nav', array(__CLASS__, 'display_admin_header_nav'));
        RC_Hook::add_action('admin_sidebar_collapse_search', array(__CLASS__, 'display_admin_sidebar_nav_search'), 9);
        RC_Hook::add_action('admin_sidebar_collapse', array(__CLASS__, 'display_admin_sidebar_nav'), 9);
        RC_Hook::add_action('admin_dashboard_top', array(__CLASS__, 'display_admin_welcome'), 9);
        RC_Hook::add_filter('upload_default_random_filename', array('ecjia_utility', 'random_filename'));
        RC_Hook::add_action('admin_print_footer_scripts', array(ecjia_notification::make(), 'printScript'));
        RC_Hook::add_action('editor_setting_first_init', function () {
            if (is_pjax()) {
                RC_Hook::add_action('admin_pjax_footer', array(ecjia_editor::editor_instance(), 'editor_js'), 50);
                RC_Hook::add_action('admin_pjax_footer', array(ecjia_editor::editor_instance(), 'enqueue_scripts'), 1);
            } else {
                RC_Hook::add_action('admin_footer', array(ecjia_editor::editor_instance(), 'editor_js'), 50);
                RC_Hook::add_action('admin_footer', array(ecjia_editor::editor_instance(), 'enqueue_scripts'), 1);
            }
        });
        RC_Loader::load_sys_class('hooks.admin_system', false);
        $system_plugins = ecjia_config::instance()->get_addon_config('system_plugins', true);
        if (is_array($system_plugins)) {
            foreach ($system_plugins as $plugin_file) {
                RC_Plugin::load_files($plugin_file);
            }
        }
        $apps = ecjia_app::installed_app_floders();
        if (is_array($apps)) {
            foreach ($apps as $app) {
                RC_Loader::load_app_class('hooks.admin_' . $app, $app, false);
            }
        }
    }
    public static final function admin_log($sn, $action, $content)
    {
        $log_info = ecjia_admin_log::instance()->get_message($sn, $action, $content);
        $db = RC_Loader::load_model('admin_log_model');
        $data = array('log_time' => RC_Time::gmtime(), 'user_id' => $_SESSION['admin_id'], 'log_info' => stripslashes($log_info), 'ip_address' => RC_Ip::client_ip());
        $db->insert($data);
    }
    public static final function admin_info()
    {
        $db = RC_Loader::load_model('admin_user_model');
        $admin_info = $db->find(array('user_id' => intval($_SESSION['admin_id'])));
        if (!empty($admin_info)) {
            return $admin_info;
        }
        return false;
    }
    public static function _ie_support_header()
    {
        if (is_ie()) {
            echo "\n";
            echo '<!--[if lte IE 8]>' . "\n";
            echo '<link rel="stylesheet" href="' . RC_Uri::admin_url() . '/statics/lib/ie/ie.css" />' . "\n";
            echo '<![endif]-->' . "\n";
            echo "\n";
            echo '<!--[if lt IE 9]>' . "\n";
            echo '<script src="' . RC_Uri::admin_url() . '/statics/lib/ie/html5.js"></script>' . "\n";
            echo '<script src="' . RC_Uri::admin_url() . '/statics/lib/ie/respond.min.js"></script>' . "\n";
            echo '<script src="' . RC_Uri::admin_url() . '/statics/lib/flot/excanvas.min.js"></script>' . "\n";
            echo '<![endif]-->' . "\n";
        }
    }
    public static function display_admin_header_nav()
    {
        $menus = ecjia_admin_menu::singleton()->admin_menu();
        $menus_label = ecjia_admin_menu::singleton()->get_menu_label();
        echo '<ul class="nav" id="mobile-nav">' . PHP_EOL;
        foreach ($menus as $key => $group) {
            if ($group) {
                echo '<li class="dropdown">' . PHP_EOL;
                echo '<a class="dropdown-toggle" data-toggle="dropdown" href="#"><i class="icon-list-alt icon-white"></i> ' . $menus_label[$key] . ' <b class="caret"></b></a>' . PHP_EOL;
                echo '<ul class="dropdown-menu">' . PHP_EOL;
                foreach ($group as $k => $menu) {
                    if ($menu->has_submenus) {
                        echo '<li class="dropdown">' . PHP_EOL;
                        if ($menu->link) {
                            echo '<a href="' . $menu->link . '" target="' . $menu->target . '">' . $menu->name . ' <b class="caret-right"></b></a>' . PHP_EOL;
                        } else {
                            echo '<a href="javascript:;" target="' . $menu->target . '">' . $menu->name . ' <b class="caret-right"></b></a>' . PHP_EOL;
                        }
                        echo '<ul class="dropdown-menu">' . PHP_EOL;
                        if ($menu->submenus) {
                            foreach ($menu->submenus as $child) {
                                if ($child->action == 'divider') {
                                    echo '<li class="divider"></li>' . PHP_EOL;
                                } elseif ($child->action == 'nav-header') {
                                    echo '<li class="nav-header">' . $child->name . '</li>' . PHP_EOL;
                                } else {
                                    echo '<li><a href="' . $child->link . '" target="' . $menu->target . '">' . $child->name . '</a></li>' . PHP_EOL;
                                }
                            }
                        }
                        echo '</ul>' . PHP_EOL;
                        echo '</li>' . PHP_EOL;
                    } else {
                        if ($menu->action == 'divider') {
                            echo '<li class="divider"></li>' . PHP_EOL;
                        } elseif ($menu->action == 'nav-header') {
                            echo '<li class="nav-header">' . $menu->name . '</li>' . PHP_EOL;
                        } else {
                            echo '<li><a href="' . $menu->link . '" target="' . $menu->target . '">' . $menu->name . '</a></li>' . PHP_EOL;
                        }
                    }
                }
            }
            echo '</ul>' . PHP_EOL;
            echo '</li>' . PHP_EOL;
        }
        echo '</ul>' . PHP_EOL;
    }
    public static function display_admin_sidebar_nav_search()
    {
        $menus = ecjia_admin_menu::singleton()->admin_menu();
        if (!empty($menus['apps'])) {
            foreach ($menus['apps'] as $k => $menu) {
                if ($menu->has_submenus) {
                    if ($menu->submenus) {
                        foreach ($menu->submenus as $child) {
                            if ($child->action == 'divider') {
                                echo '<li class="divider"></li>';
                            } elseif ($child->action == 'nav-header') {
                                echo '<li class="nav-header">' . $child->name . '</li>';
                            } else {
                                echo '<li><a href="' . $child->link . '">' . $child->name . '</a></li>';
                            }
                        }
                    }
                }
            }
        }
    }
    public static function display_admin_sidebar_nav()
    {
        $menus = ecjia_admin_menu::singleton()->admin_menu();
        if (!empty($menus['apps'])) {
            foreach ($menus['apps'] as $k => $menu) {
                echo '<div class="accordion-group">';
                echo '<div class="accordion-heading">';
                echo '<a class="accordion-toggle" href="#collapse' . $k . '" data-parent="#side_accordion" data-toggle="collapse">';
                echo '<i class="icon-folder-close"></i> ' . $menu->name;
                echo '</a>';
                echo '</div>';
                if ($menu->has_submenus) {
                    echo '<div class="accordion-body collapse" id="collapse' . $k . '">';
                    echo '<div class="accordion-inner">';
                    echo '<ul class="nav nav-list">';
                    if ($menu->submenus) {
                        foreach ($menu->submenus as $child) {
                            if ($child->action == 'divider') {
                                echo '<li class="divider"></li>';
                            } elseif ($child->action == 'nav-header') {
                                echo '<li class="nav-header">' . $child->name . '</li>';
                            } else {
                                if (RC_Uri::current_url() === $child->link) {
                                    echo '<li class="active"><a href="' . $child->link . '">' . $child->name . '</a></li>';
                                } else {
                                    echo '<li><a href="' . $child->link . '">' . $child->name . '</a></li>';
                                }
                            }
                        }
                    }
                    echo '</ul>';
                    echo '</div>';
                    echo '</div>';
                }
                echo '</div>';
            }
        }
    }
    public static function display_admin_copyright()
    {
        $ecjia_version = ecjia::version();
        $company_msg = '  2013-2019 ';
        $ecjia_icon = RC_Uri::admin_url('statics/images/ecjia_icon.png');
        echo "<div class='row-fluid footer'>\n        \t\t<div class='span12'>\n        \t\t\t<span class='f_l w35'>\n        \t\t\t\t<img src='{$ecjia_icon}' />\n        \t\t\t</span>\n        \t\t\t{$company_msg}\t\n        \t\t\t<span class='f_r muted'>\n        \t\t\t\t<i>v{$ecjia_version}</i>\n        \t\t\t</span>\n        \t\t</div>\n        \t</div>";
    }
    public static function display_admin_welcome()
    {
        $ecjia_version = VERSION;
        $ecjia_welcome_logo = RC_Uri::admin_url('statics/images/ecjiawelcom.png');
        $ecjia_about_url = RC_Uri::url('@about/about_us');
        $welcome_ecjia = __('ECJia');
        $description = __('ECJiaPHP+MYSQL+UIECJia');
        $more = __(' ');
        $welcome = <<<WELCOME
      <div>
        <a class="close m_r10" data-dismiss="alert"></a>
        <div class="hero-unit">
            <div class="row-fluid">
                <div class="span3">
                    <img src="{$ecjia_welcome_logo}" />
                </div>
                <div class="span9">
                    <h1>{$welcome_ecjia} {$ecjia_version}</h1>
                    <p>{$description}</p>
                    <a class="btn btn-info" href="{$ecjia_about_url}" target="_self">{$more}</a>
                </div>
            </div>
        </div>
    </div>
WELCOME;
        echo $welcome;
    }
    public static function display_admin_about_welcome()
    {
        $ecjia_version = VERSION;
        $ecjia_welcome_logo = RC_Uri::admin_url('statics/images/ecjiawelcom.png');
        $welcome_ecjia = __('ECJia');
        $description = __('ECJiaPHP+MYSQL+UIECJia');
        $more = __(' ');
        $ecjia_url = 'https://ecjia.com';
        $welcome = <<<WELCOME
        <div class="hero-unit">
\t\t\t<div class="row-fluid">
\t\t\t\t<div class="span9">
\t\t\t\t\t<h1>{$welcome_ecjia} {$ecjia_version}</h1>
\t\t\t\t\t<p>{$description}</p>
\t\t\t\t\t<p><a class="btn btn-info" href="{$ecjia_url}" target="_bank">{$more}</a></p>
\t\t\t\t</div>
\t\t\t\t<div class="span3">
\t\t\t\t\t<div><img src="{$ecjia_welcome_logo}" /></div>
\t\t\t\t</div>
\t\t\t</div>
\t\t</div>
WELCOME;
        echo $welcome;
    }
    public static function is_super_admin()
    {
    }
    public static function is_sidebar_hidden()
    {
        $sidebar_display = ecjia_screen::get_current_screen()->get_sidebar_display();
        $ecjia_sidebar = royalcms('request')->cookie('ecjia_sidebar');
        if ($sidebar_display === false || $ecjia_sidebar == 'hidden') {
            return true;
        } else {
            return false;
        }
    }
}
}

namespace Ecjia\System\BaseController {
use ecjia;
use ecjia_app;
use ecjia_editor;
use ecjia_loader;
use RC_Config;
use RC_ENV;
use RC_Hook;
use RC_Ip;
use RC_Loader;
use RC_Response;
use RC_Session;
abstract class EcjiaFrontController extends SmartyController
{
    public function __construct()
    {
        parent::__construct();
        self::$controller = static::$controller;
        self::$view_object = static::$view_object;
        if (defined('DEBUG_MODE') == false) {
            define('DEBUG_MODE', 0);
        }
        if (ecjia::config('shop_closed') == 1) {
            RC_Hook::do_action('ecjia_shop_closed');
        }
        defined('SESS_ID') or define('SESS_ID', RC_Session::session_id());
        RC_Hook::do_action('ecjia_front_access_session');
        if (isset($_SERVER['PHP_SELF'])) {
            $_SERVER['PHP_SELF'] = htmlspecialchars($_SERVER['PHP_SELF']);
        }
        RC_Response::header('Cache-control', 'private');
        $this->assign_title();
        RC_Hook::do_action('ecjia_compatible_process');
        $this->load_default_script_style();
        if (RC_Config::get('system.gzip') && RC_ENV::gzip_enabled()) {
            ob_start('ob_gzhandler');
        } else {
            ob_start();
        }
        RC_Hook::do_action('ecjia_front_finish_launching');
    }
    protected function registerServiceProvider()
    {
        royalcms()->forgeRegister('Royalcms\\Component\\Purifier\\PurifierServiceProvider');
    }
    protected function session_start()
    {
        parent::session_start();
        $this->default_session();
    }
    protected function default_session()
    {
        if (!RC_Session::has('user_rank')) {
            RC_Session::set('user_rank', 0);
        }
        if (!RC_Session::has('discount')) {
            RC_Session::set('discount', 1.0);
        }
        if (!RC_Session::has('ip')) {
            RC_Session::set('ip', RC_Ip::client_ip());
        }
    }
    protected function message($msg = '', $url = null, $time = 2, $tpl = null)
    {
        $revise_url = $url ? "window.location.href='" . $url . "'" : "window.history.back(-1);";
        $front_tpl = SITE_THEME_PATH . RC_Config::get('system.tpl_style') . DIRECTORY_SEPARATOR . RC_Config::get('system.tpl_message');
        if ($tpl) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            $tpl = SITE_THEME_PATH . RC_Config::get('system.tpl_style') . DIRECTORY_SEPARATOR . $tpl;
            return $this->display($tpl);
        } elseif (file_exists($front_tpl)) {
            $this->assign(array('msg' => $msg, 'url' => $revise_url, 'time' => $time));
            return $this->display($front_tpl);
        } else {
            return parent::message($msg, $url, $time, $tpl);
        }
    }
    public function assign_title($title = '')
    {
        $title_suffix = RC_Hook::apply_filters('page_title_suffix', ' - Powered by ECJia');
        if (empty($title)) {
            $this->assign('page_title', ecjia::config('shop_title') . $title_suffix);
        } else {
            $this->assign('page_title', $title . '-' . ecjia::config('shop_title') . $title_suffix);
        }
    }
    public function assign_template($ctype = '', $catlist = array())
    {
        $this->assign('image_width', ecjia::config('image_width'));
        $this->assign('image_height', ecjia::config('image_height'));
        $this->assign('points_name', ecjia::config('integral_name'));
        $this->assign('qq', explode(',', ecjia::config('qq')));
        $this->assign('ww', explode(',', ecjia::config('ww')));
        $this->assign('ym', explode(',', ecjia::config('ym')));
        $this->assign('msn', explode(',', ecjia::config('msn')));
        $this->assign('skype', explode(',', ecjia::config('skype')));
        $this->assign('stats_code', ecjia::config('stats_code'));
        $this->assign('copyright', '  2013-2019 ');
        $this->assign('shop_name', ecjia::config('shop_name'));
        $this->assign('service_email', ecjia::config('service_email'));
        $this->assign('service_phone', ecjia::config('service_phone'));
        $this->assign('shop_address', ecjia::config('shop_address'));
        $this->assign('ecs_version', VERSION);
        $this->assign('icp_number', ecjia::config('icp_number'));
        $this->assign('username', !empty($_SESSION['user_name']) ? $_SESSION['user_name'] : '');
        if (ecjia::config('search_keywords', ecjia::CONFIG_CHECK)) {
            $searchkeywords = explode(',', trim(ecjia::config('search_keywords')));
            $this->assign('searchkeywords', $searchkeywords);
        }
    }
    protected function load_hooks()
    {
        RC_Hook::add_action('front_enqueue_scripts', array($this, 'front_enqueue_scripts'), 1);
        RC_Hook::add_action('front_print_styles', array($this, 'front_print_head_styles'), 8);
        RC_Hook::add_action('front_print_scripts', array($this, 'front_print_head_scripts'), 9);
        RC_Hook::add_action('front_print_footer_scripts', array($this, 'print_front_footer_scripts'), 20);
        RC_Hook::add_action('editor_setting_first_init', function () {
            RC_Hook::add_action('front_print_footer_scripts', array(ecjia_editor::editor_instance(), 'editor_js'), 50);
            RC_Hook::add_action('front_print_footer_scripts', array(ecjia_editor::editor_instance(), 'enqueue_scripts'), 1);
        });
        $apps = ecjia_app::installed_app_floders();
        if (is_array($apps)) {
            foreach ($apps as $app) {
                RC_Loader::load_app_class('hooks.front_' . $app, $app, false);
            }
        }
    }
    protected function load_default_script_style()
    {
    }
    public function front_enqueue_scripts()
    {
    }
    public final function print_front_footer_scripts()
    {
        $this->front_print_late_styles();
        $this->front_print_footer_scripts();
    }
    public function front_print_head_styles()
    {
        ecjia_loader::print_head_styles();
    }
    public function front_print_head_scripts()
    {
        ecjia_loader::print_head_scripts();
    }
    protected function front_print_late_styles()
    {
        ecjia_loader::print_late_styles();
    }
    protected function front_print_footer_scripts()
    {
        ecjia_loader::print_footer_scripts();
    }
}
}

namespace {
class ecjia_view
{
    protected $smarty;
    protected $isAdminView = true;
    protected $fileloader;
    public function __construct(\Ecjia\System\Frameworks\Contracts\EcjiaTemplateFileLoader $fileloader)
    {
        $this->fileloader = $fileloader;
        $this->smarty = royalcms('view')->getSmarty();
        $filters = array('ecjia_tag');
        if (ROUTE_M != 'installer') {
            $filters[] = 'library_item';
        }
        $this->smarty->autoload_filters = array('pre' => $filters);
        RC_Loader::load_sys_func('smarty_handler');
        if (function_exists('smarty_plugin_handler')) {
            $this->smarty->registerDefaultPluginHandler('smarty_plugin_handler');
        }
    }
    public function getSmarty()
    {
        return $this->smarty;
    }
    public function getFileloader()
    {
        return $this->fileloader;
    }
    public function display($resource_name, $cache_id = null, $show = true, $options = array())
    {
        RC_Hook::do_action('ecjia_view_display_before');
        if (strpos($resource_name, 'string:') !== 0) {
            $resource_name = $this->fileloader->get_template_file($resource_name);
        }
        $content_type = isset($options['content_type']) ? $options['content_type'] : 'text/html';
        $charset = isset($options['charset']) ? $options['charset'] : '';
        $compile_id = isset($options['compile_id']) ? $options['compile_id'] : null;
        $parent = isset($options['parent']) ? $options['parent'] : null;
        $display = isset($options['display']) ? $options['display'] : false;
        $merge_tpl_vars = isset($options['merge_tpl_vars']) ? $options['merge_tpl_vars'] : true;
        $no_output_filter = isset($options['no_output_filter']) ? $options['no_output_filter'] : false;
        $content = $this->smarty->fetch($resource_name, $cache_id, $compile_id, $parent, $display, $merge_tpl_vars, $no_output_filter);
        if ($show) {
            return $this->displayContent($content, $content_type);
        } else {
            return $content;
        }
    }
    public function displayContent($content, $content_type = 'text/html')
    {
        $response = royalcms('response');
        if ($content_type) {
            $response->header('Content-Type', $content_type);
        }
        $response->setContent($content);
        royalcms()->instance('response', $response);
        return $response;
    }
    public function fetch($tpl_file = null, $cache_id = null, $options = array())
    {
        return $this->display($tpl_file, $cache_id, false, $options);
    }
    public function fetch_string($tpl_string = null, $cache_id = null, $options = array())
    {
        $tpl_file = null;
        if ($tpl_string) {
            $tpl_file = 'string:' . $tpl_string;
        }
        return $this->fetch($tpl_file, $cache_id, $options);
    }
    public function is_cached($resource_name, $cache_id = null, $options = array())
    {
        if (strpos($resource_name, 'string:') !== 0) {
            $resource_name = $this->fileloader->get_template_file($resource_name);
        }
        $compile_id = isset($options['compile_id']) ? $options['compile_id'] : null;
        $parent = isset($options['parent']) ? $options['parent'] : null;
        return $this->smarty->isCached($resource_name, $cache_id, $compile_id, $parent);
    }
    public function clear_cache($resource_name, $cache_id = null, $options = array())
    {
        if (strpos($resource_name, 'string:') !== 0) {
            $resource_name = $this->fileloader->get_template_file($resource_name);
        }
        $cache_time = isset($options['cache_time']) ? $options['cache_time'] : null;
        $compile_id = isset($options['compile_id']) ? $options['compile_id'] : null;
        $type = isset($options['type']) ? $options['type'] : null;
        return $this->smarty->clearCache($resource_name, $cache_id, $compile_id, $cache_time, $type);
    }
    public function clear_all_cache($cache_time = null, $options = array())
    {
        $type = isset($options['type']) ? $options['type'] : null;
        return $this->smarty->clearAllCache($cache_time, $type);
    }
    public function assign($name, $value = null)
    {
        return $this->smarty->assign($name, $value);
    }
    public function assign_lang($lang = array())
    {
        if (!empty($lang)) {
            $this->smarty->assign('lang', $lang);
        } else {
            $this->smarty->assign('lang', RC_Lang::lang());
        }
    }
    public function clear_compiled_files()
    {
        if (royalcms('files')->isDirectory(TEMPLATE_COMPILE_PATH)) {
            $this->smarty->clearCompiledTemplate();
        }
    }
    public function clear_cache_files()
    {
        if (royalcms('files')->isDirectory(TEMPLATE_CACHE_PATH)) {
            $this->smarty->clearAllCache();
        }
    }
    public function __call($method, $parameters)
    {
        return call_user_func_array(array($this->smarty, $method), $parameters);
    }
    public function __set($name, $value)
    {
        return $this->smarty->{$name} = $value;
    }
    public function __get($name)
    {
        return $this->smarty->{$name};
    }
    public function __isset($name)
    {
        return isset($this->smarty->{$name});
    }
    public function __unset($name)
    {
        unset($this->smarty->{$name});
    }
}
}

namespace {
class ecjia_notification
{
    protected static $instance;
    protected $registered;
    public static function make()
    {
        if (static::$instance === null) {
            static::$instance = new static();
        }
        return static::$instance;
    }
    public function query($handle)
    {
        if (!isset($this->registered[$handle])) {
            return false;
        }
        return $this->registered[$handle];
    }
    public function register($handle, admin_notification $notification)
    {
        if (isset($this->registered[$handle])) {
            return false;
        }
        $this->registered[$handle] = $notification;
    }
    public function remove($handles)
    {
        foreach ((array) $handles as $handle) {
            unset($this->registered[$handle]);
        }
    }
    public function allNotification()
    {
        return $this->registered;
    }
    public function printScript()
    {
        if (!empty($this->registered)) {
            $script = '<script type="text/javascript">' . PHP_EOL;
            foreach ($this->registered as $notification) {
                $options = array();
                $notification->getAutoclose() and $options['autoclose'] = $notification->getAutoclose();
                $notification->getPosition() and $options['position'] = $notification->getPosition();
                $notification->getType() and $options['type'] = $notification->getType();
                $notification->getSpeed() and $options['speed'] = $notification->getSpeed();
                $notification->getDuplicates() and $options['duplicates'] = $notification->getDuplicates();
                !empty($options) and $options_json = json_encode($options);
                $script .= '$.sticky("' . rc_addslashes($notification->getContent()) . '", ' . $options_json . ');' . PHP_EOL;
            }
            $script .= '</script>' . PHP_EOL;
            echo $script;
        }
    }
}
}

namespace {
defined('IN_ECJIA') or exit('No permission resources.');
class ecjia_loader
{
    protected static $script_loader;
    protected static $style_loader;
    public static function default_scripts(&$scripts)
    {
        if (is_null(self::$script_loader)) {
            self::$script_loader = new \Ecjia\System\Frameworks\ScriptLoader\ScriptLoader($scripts);
        }
    }
    public static function default_styles(&$styles)
    {
        if (is_null(self::$style_loader)) {
            self::$style_loader = new \Ecjia\System\Frameworks\ScriptLoader\StyleLoader($styles);
        }
    }
    public static function admin_print_footer_scripts()
    {
        RC_Hook::do_action('admin_print_footer_scripts');
    }
    public static function admin_enqueue_scripts()
    {
        RC_Hook::do_action('admin_enqueue_scripts');
    }
    public static function print_head_scripts()
    {
        return self::$script_loader->print_head_scripts();
    }
    public static function print_footer_scripts()
    {
        return self::$script_loader->print_footer_scripts();
    }
    public static function print_admin_footer_scripts()
    {
        self::print_late_styles();
        self::print_footer_scripts();
    }
    public static function print_head_styles()
    {
        return self::$style_loader->print_head_styles();
    }
    public static function print_late_styles()
    {
        return self::$style_loader->print_late_styles();
    }
}
}

namespace {
defined('IN_ECJIA') or exit('No permission resources.');
class ecjia_screen
{
    public $action;
    public $base;
    private $columns = 0;
    public $id;
    protected $in_admin;
    public $parent_base;
    public $parent_file;
    private $_help_tabs = array();
    private $_help_sidebar = '';
    private $_options = array();
    protected $_nav_here = array();
    protected $_admin_notice = array();
    private static $_registry = array();
    private $_show_screen_options;
    private $_screen_settings;
    public static $hook_suffix;
    private $_sidebar_display = true;
    protected $subject;
    public static function get($hook_name = '')
    {
        if (is_a($hook_name, __CLASS__)) {
            return $hook_name;
        }
        $post_type = $taxonomy = null;
        $in_admin = false;
        $action = '';
        if ($hook_name) {
            $id = $hook_name;
        } else {
            $id = self::$hook_suffix;
        }
        if ('index' == $id) {
            $id = 'dashboard';
        } elseif ('front' == $id) {
            $in_admin = false;
        }
        $base = $id;
        if (isset(self::$_registry[$id])) {
            $screen = self::$_registry[$id];
            if ($screen === self::get_current_screen()) {
                return $screen;
            }
        } else {
            $screen = new static();
            $screen->id = $id;
        }
        $screen->base = $base;
        $screen->action = $action;
        self::$_registry[$id] = $screen;
        return $screen;
    }
    function make_current_screen()
    {
        self::$current_screen = $this;
        RC_Hook::do_action('current_screen', self::$current_screen);
    }
    private function __construct()
    {
    }
    public function in_admin($admin = null)
    {
        if (empty($admin)) {
            return (bool) $this->in_admin;
        }
        return $admin == $this->in_admin;
    }
    function set_parentage($parent_base, $parent_file)
    {
        $this->parent_file = $parent_file;
        $this->parent_base = $parent_base;
    }
    public function add_nav_here(admin_nav_here $nav_here)
    {
        if ($nav_here instanceof admin_nav_here) {
            $this->_nav_here[] = $nav_here;
        }
    }
    public function remove_nav_here()
    {
        $this->_nav_here = array();
    }
    public function remove_last_nav_here()
    {
        array_pop($this->_nav_here);
    }
    public function add_admin_notice(admin_notice $admin_notice)
    {
        if ($admin_notice instanceof admin_notice) {
            $this->_admin_notice[] = $admin_notice;
        }
    }
    public function set_sidebar_display($bool)
    {
        $this->_sidebar_display = $bool;
        if ($bool) {
            setcookie('ecjia_sidebar', '');
        } else {
            setcookie('ecjia_sidebar', 'hidden');
        }
    }
    public function get_sidebar_display()
    {
        return $this->_sidebar_display;
    }
    public function add_option($option, $args = array())
    {
        $this->_options[$option] = $args;
    }
    public function remove_option($option)
    {
        unset($this->_options[$option]);
    }
    public function remove_options()
    {
        $this->_options = array();
    }
    public function get_options()
    {
        return $this->_options;
    }
    public function get_option($option, $key = false)
    {
        if (!isset($this->_options[$option])) {
            return null;
        }
        if ($key) {
            if (isset($this->_options[$option][$key])) {
                return $this->_options[$option][$key];
            }
            return null;
        }
        return $this->_options[$option];
    }
    public function set_subject($subject)
    {
        $this->subject = $subject;
    }
    public function get_subject()
    {
        return $this->subject;
    }
    public function get_help_tabs()
    {
        return $this->_help_tabs;
    }
    public function get_help_tab($id)
    {
        if (!isset($this->_help_tabs[$id])) {
            return null;
        }
        return $this->_help_tabs[$id];
    }
    public function add_help_tab($args)
    {
        $defaults = array('title' => false, 'id' => false, 'content' => '', 'callback' => false);
        $args = rc_parse_args($args, $defaults);
        $args['id'] = RC_Format::sanitize_html_class($args['id']);
        if (!$args['id'] || !$args['title']) {
            return;
        }
        $this->_help_tabs[$args['id']] = $args;
    }
    public function remove_help_tab($id)
    {
        unset($this->_help_tabs[$id]);
    }
    public function remove_help_tabs()
    {
        $this->_help_tabs = array();
    }
    public function get_help_sidebar()
    {
        return $this->_help_sidebar;
    }
    public function set_help_sidebar($content)
    {
        $this->_help_sidebar = $content;
    }
    public function get_columns()
    {
        return $this->columns;
    }
    public function get_admin_notice()
    {
        return $this->_admin_notice;
    }
    public function render_screen_meta()
    {
        $help_sidebar = $this->get_help_sidebar();
        $help_class = 'hidden';
        if (!$help_sidebar) {
            $help_class .= ' no-sidebar';
        }
        if (!empty($this->_nav_here)) {
            ?>
		<div id="jCrumbs" class="breadCrumb module breadCrumbECJ">
			<div class="breadCrumbWrap">
				<ul>
					<li><a href="<?php 
            echo RC_Uri::url('@index/init');
            ?>
"><i class="icon-home"></i></a></li>
					<?php 
            foreach ($this->_nav_here as $nav_here) {
                if (end($this->_nav_here) === $nav_here) {
                    $last_css = ' class="last"';
                }
                if ($nav_here->get_link()) {
                    ?>
							<li<?php 
                    echo $last_css;
                    ?>
><a href="<?php 
                    echo $nav_here->get_link();
                    ?>
"><?php 
                    echo $nav_here->get_label();
                    ?>
</a></li>
					       <?php 
                } else {
                    ?>
					       <li<?php 
                    echo $last_css;
                    ?>
><?php 
                    echo $nav_here->get_label();
                    ?>
</li>
					       <?php 
                }
            }
            ?>
				</ul>
			</div>
			<div id="screen-meta" class="metabox-prefs">
				<div class="contextual-help-wrap" class="<?php 
            echo RC_Format::esc_attr($help_class);
            ?>
" aria-label="<?php 
            esc_attr_e('Contextual Help Tab');
            ?>
"><!-- tabindex="-1"  -->
					<div id="contextual-help-columns tab-content row-fluid">
							<div class="contextual-help-tabs">
								<ul class="">
									<?php 
            $class = ' class="active"';
            foreach ($this->get_help_tabs() as $tab) {
                $link_id = "tab-link-{$tab['id']}";
                $panel_id = "tab-panel-{$tab['id']}";
                ?>
									<li id="<?php 
                echo RC_Format::esc_attr($link_id);
                ?>
"<?php 
                echo $class;
                ?>
>
										<a href="#<?php 
                echo RC_Format::esc_attr("#{$panel_id}");
                ?>
" aria-controls="<?php 
                echo RC_Format::esc_attr($panel_id);
                ?>
" data-toggle="tab">
											<?php 
                echo RC_Format::esc_html($tab['title']);
                ?>
										</a>
									</li>
									<?php 
                $class = '';
            }
            ?>
								</ul>
							</div>
							<div class="contextual-help-tabs-wrap">
								<div class="tab-content">
									<?php 
            $classes = 'help-tab-content active';
            foreach ($this->get_help_tabs() as $tab) {
                $panel_id = "tab-panel-{$tab['id']}";
                ?>
									<div id="<?php 
                echo RC_Format::esc_attr($panel_id);
                ?>
" class="<?php 
                echo $classes;
                ?>
 tab-pane">
										<?php 
                echo $tab['content'];
                if (!empty($tab['callback'])) {
                    call_user_func_array($tab['callback'], array($this, $tab));
                }
                ?>
									</div>
									<?php 
                $classes = 'help-tab-content';
            }
            ?>
								</div>
							</div>
						<?php 
            if ($help_sidebar) {
                ?>
							<div class="contextual-help-sidebar tab-pane active">
								<?php 
                echo $help_sidebar;
                ?>
							</div>
						<?php 
            }
            ?>
					</div>
				</div>
    		<?php 
            $columns = RC_Hook::apply_filters('screen_layout_columns', array(), $this->id, $this);
            if (!empty($columns) && isset($columns[$this->id])) {
                $this->add_option('layout_columns', array('max' => $columns[$this->id]));
            }
            if ($this->get_option('layout_columns')) {
                $this->columns = (int) get_user_option("screen_layout_{$this->id}");
                if (!$this->columns && $this->get_option('layout_columns', 'default')) {
                    $this->columns = $this->get_option('layout_columns', 'default');
                }
            }
            $GLOBALS['screen_layout_columns'] = $this->columns;
            if ($this->show_screen_options()) {
                $this->render_screen_options();
            }
            ?>
    		</div>
    		<?php 
            if (!$this->get_help_tabs() && !$this->show_screen_options() && !$this->get_admin_notice()) {
                echo "</div>";
                return;
            }
            ?>
            <div class="screen-meta-links" id="screen-meta-links">
                <?php 
            if ($this->get_help_tabs()) {
                ?>
                <a class="btn btn-mini contextual-help-link" href="javascript:;" id="contextual-help-link" aria-controls="contextual-help-wrap" aria-expanded="false"><?php 
                _e('');
                ?>
<i class="fontello-icon-angle-down"></i></a>
                <?php 
            }
            if ($this->show_screen_options()) {
                ?>
                <a class="btn btn-mini show-settings-link" href="javascript:;" id="show-settings-link" aria-controls="screen-options-wrap" aria-expanded="false"><?php 
                _e('');
                ?>
<i class="fontello-icon-angle-down"></i></a>
                <?php 
            }
            ?>
            </div>
			<script type="text/javascript">
				$('.contextual-help-link').on('click', function(){
					var
						$this = $(this),
						$screenmeta = $this.parents('.breadCrumb').find('.contextual-help-wrap'),
						$i = $this.find('i');
					if(!$screenmeta.is(":animated") && $this.css('opacity') != 0){
						if($i.attr('class', $i.hasClass('fontello-icon-angle-down') ? 'fontello-icon-angle-up' : 'fontello-icon-angle-down').hasClass('fontello-icon-angle-up')){
							$screenmeta.slideDown('slow', 'easeOutQuint');
							$('.show-settings-link').css({'opacity':0,'cursor':'default'});
						}else{
							$screenmeta.slideUp('slow', 'easeInQuart');
							$('.show-settings-link').css({'opacity':1,'cursor':'pointer'});
						}
					}
				})
				$('.show-settings-link').on('click', function(){
					var
						$this = $(this),
						$screenmeta = $this.parents('.breadCrumb').find('.screen-options-wrap'),
						$i = $this.find('i');
					if(!$screenmeta.is(":animated") && $this.css('opacity') != 0){
						if($i.attr('class', $i.hasClass('fontello-icon-angle-down') ? 'fontello-icon-angle-up' : 'fontello-icon-angle-down').hasClass('fontello-icon-angle-up')){
							$screenmeta.slideDown('slow', 'easeOutBack');
							$('.contextual-help-link').css({'opacity':0,'cursor':'default'});
						}else{
							$screenmeta.slideUp('slow', 'easeInBack');
							$('.contextual-help-link').css({'opacity':1,'cursor':'pointer'});
						}
					}
				})
			</script>
		</div>
		<?php 
        }
        $this->render_screen_admin_notice();
    }
    public function render_screen_admin_notice()
    {
        if (!empty($this->_admin_notice)) {
            foreach ($this->_admin_notice as $admin_notice) {
                ?>
                <div class="alert<?php 
                if ($admin_notice->get_type()) {
                    echo ' ' . $admin_notice->get_type();
                }
                ?>
">
                    <?php 
                if ($admin_notice->get_allow_close()) {
                    ?>
                	<a data-dismiss="alert" class="close"></a>
                	<?php 
                }
                ?>
                	<?php 
                echo $admin_notice->get_content();
                ?>
                </div>
		       <?php 
            }
        }
    }
    public function show_screen_options()
    {
        global $wp_meta_boxes;
        if (is_bool($this->_show_screen_options)) {
            return $this->_show_screen_options;
        }
        $columns = self::get_column_headers($this);
        $show_screen = !empty($wp_meta_boxes[$this->id]) || $columns || $this->get_option('per_page');
        switch ($this->id) {
            case 'widgets':
                $this->_screen_settings = '<p><a id="access-on" href="widgets.php?widgets-access=on">' . __('Enable accessibility mode') . '</a><a id="access-off" href="widgets.php?widgets-access=off">' . __('Disable accessibility mode') . "</a></p>\n";
                break;
            default:
                $this->_screen_settings = '';
                break;
        }
        $this->_screen_settings = RC_Hook::apply_filters('screen_settings', $this->_screen_settings, $this);
        if ($this->_screen_settings || $this->_options) {
            $show_screen = true;
        }
        $this->_show_screen_options = RC_Hook::apply_filters('screen_options_show_screen', $show_screen, $this);
        return $this->_show_screen_options;
    }
    public function render_screen_options()
    {
        global $wp_meta_boxes, $wp_list_table;
        $columns = self::get_column_headers($this);
        $hidden = self::get_hidden_columns($this);
        ?>
		<div class="screen-options-wrap" class="hidden" aria-label="<?php 
        esc_attr_e('Screen Options Tab');
        ?>
"><!-- tabindex="-1" -->
		<form id="adv-settings" action="" method="post">
		<?php 
        if (isset($wp_meta_boxes[$this->id]) || $this->get_option('per_page') || $columns && empty($columns['_title'])) {
            ?>
			<h5><?php 
            _e('');
            ?>
</h5>
		<?php 
        }
        if (isset($wp_meta_boxes[$this->id])) {
            ?>
			<div class="metabox-prefs">
				<?php 
            self::meta_box_prefs($this);
            if ('dashboard' === $this->id && RC_Hook::has_action('welcome_panel') && current_user_can('edit_theme_options')) {
                if (isset($_GET['welcome'])) {
                    $welcome_checked = empty($_GET['welcome']) ? 0 : 1;
                    update_user_meta(get_current_user_id(), 'show_welcome_panel', $welcome_checked);
                } else {
                    $welcome_checked = get_user_meta(get_current_user_id(), 'show_welcome_panel', true);
                    if (2 == $welcome_checked && wp_get_current_user()->user_email != get_option('admin_email')) {
                        $welcome_checked = false;
                    }
                }
                echo '<label for="wp_welcome_panel-hide">';
                echo '<input type="checkbox" id="wp_welcome_panel-hide"' . checked((bool) $welcome_checked, true, false) . ' />';
                echo _x('Welcome', 'Welcome panel') . "</label>\n";
            }
            ?>
				<br class="clear" />
			</div>
			<?php 
        }
        if ($columns) {
            if (!empty($columns['_title'])) {
                ?>
			<h5><?php 
                echo $columns['_title'];
                ?>
</h5>
			<?php 
            }
            ?>
			<div class="metabox-prefs">
				<?php 
            $special = array('_title', 'cb', 'comment', 'media', 'name', 'title', 'username', 'blogname');
            foreach ($columns as $column => $title) {
                if (in_array($column, $special)) {
                    continue;
                }
                if (empty($title)) {
                    continue;
                }
                if ('comments' == $column) {
                    $title = __('Comments');
                }
                $id = "{$column}-hide";
                echo '<label for="' . $id . '">';
                echo '<input class="hide-column-tog" name="' . $id . '" type="checkbox" id="' . $id . '" value="' . $column . '"' . checked(!in_array($column, $hidden), true, false) . ' />';
                echo "{$title}</label>\n";
            }
            ?>
				<br class="clear" />
			</div>
		<?php 
        }
        $this->render_screen_layout();
        $this->render_per_page_options();
        echo $this->_screen_settings;
        ?>
		<div><?php 
        ?>
</div>
		</form>
		</div>
		<?php 
    }
    function render_screen_layout()
    {
        if (!$this->get_option('layout_columns')) {
            return;
        }
        $screen_layout_columns = $this->get_columns();
        $num = $this->get_option('layout_columns', 'max');
        ?>
		<h5 class="screen-layout"><?php 
        _e('Screen Layout');
        ?>
</h5>
		<div class='columns-prefs'><?php 
        _e('Number of Columns:');
        for ($i = 1; $i <= $num; ++$i) {
            ?>
				<label class="columns-prefs-<?php 
            echo $i;
            ?>
">
					<input type='radio' name='screen_columns' value='<?php 
            echo RC_Format::esc_attr($i);
            ?>
'
						<?php 
            checked($screen_layout_columns, $i);
            ?>
 />
					<?php 
            echo RC_Format::esc_html($i);
            ?>
				</label>
				<?php 
        }
        ?>
		</div>
		<?php 
    }
    function render_per_page_options()
    {
        if (!$this->get_option('per_page')) {
            return;
        }
        $per_page_label = $this->get_option('per_page', 'label');
        $option = $this->get_option('per_page', 'option');
        if (!$option) {
            $option = str_replace('-', '_', "{$this->id}_per_page");
        }
        $per_page = RC_Hook::apply_filters($option, $per_page);
        ?>
		<div class="screen-options">
			<?php 
        if ($per_page_label) {
            ?>
				<input type="number" step="1" min="1" max="999" class="screen-per-page" name="wp_screen_options[value]"
					id="<?php 
            echo RC_Format::esc_attr($option);
            ?>
" maxlength="3"
					value="<?php 
            echo RC_Format::esc_attr($per_page);
            ?>
" />
				<label for="<?php 
            echo RC_Format::esc_attr($option);
            ?>
">
					<?php 
            echo RC_Format::esc_html($per_page_label);
            ?>
				</label>
			<?php 
        }
        echo ecjia_form::get_submit_button(__(''), 'btn', 'screen-options-apply', false);
        ?>
			<input type='hidden' name='wp_screen_options[option]' value='<?php 
        echo RC_Format::esc_attr($option);
        ?>
' />
		</div>
		<?php 
    }
    public static $current_screen;
    public static function get_current_screen()
    {
        if (!isset(self::$current_screen)) {
            return null;
        }
        return self::$current_screen;
    }
    public static function set_current_screen($hook_name = '')
    {
        self::get($hook_name)->make_current_screen();
    }
    public static function add_screen_option($option, $args = array())
    {
        $current_screen = self::get_current_screen();
        if (!$current_screen) {
            return;
        }
        $current_screen->add_option($option, $args);
    }
    public static function get_hidden_meta_boxes($screen)
    {
        if (is_string($screen)) {
            $screen = self::convert_to_screen($screen);
        }
        $hidden = get_user_option("metaboxhidden_{$screen->id}");
        $use_defaults = !is_array($hidden);
        if ($use_defaults) {
            $hidden = array();
            if ('post' == $screen->base) {
                if ('post' == $screen->post_type || 'page' == $screen->post_type || 'attachment' == $screen->post_type) {
                    $hidden = array('slugdiv', 'trackbacksdiv', 'postcustom', 'postexcerpt', 'commentstatusdiv', 'commentsdiv', 'authordiv', 'revisionsdiv');
                } else {
                    $hidden = array('slugdiv');
                }
            }
            $hidden = RC_Hook::apply_filters('default_hidden_meta_boxes', $hidden, $screen);
        }
        return RC_Hook::apply_filters('hidden_meta_boxes', $hidden, $screen, $use_defaults);
    }
    public static function meta_box_prefs($screen)
    {
        global $wp_meta_boxes;
        if (is_string($screen)) {
            $screen = self::convert_to_screen($screen);
        }
        if (empty($wp_meta_boxes[$screen->id])) {
            return;
        }
        $hidden = self::get_hidden_meta_boxes($screen);
        foreach (array_keys($wp_meta_boxes[$screen->id]) as $context) {
            foreach (array_keys($wp_meta_boxes[$screen->id][$context]) as $priority) {
                foreach ($wp_meta_boxes[$screen->id][$context][$priority] as $box) {
                    if (false == $box || !$box['title']) {
                        continue;
                    }
                    if ('submitdiv' == $box['id'] || 'linksubmitdiv' == $box['id']) {
                        continue;
                    }
                    $box_id = $box['id'];
                    echo '<label for="' . $box_id . '-hide">';
                    echo '<input class="hide-postbox-tog" name="' . $box_id . '-hide" type="checkbox" id="' . $box_id . '-hide" value="' . $box_id . '"' . (!in_array($box_id, $hidden) ? ' checked="checked"' : '') . ' />';
                    echo "{$box['title']}</label>\n";
                }
            }
        }
    }
    public static function convert_to_screen($hook_name)
    {
        if (!class_exists(__CLASS__)) {
            _doing_it_wrong('convert_to_screen(), add_meta_box()', __("Likely direct inclusion of wp-admin/includes/template.php in order to use add_meta_box(). This is very wrong. Hook the add_meta_box() call into the add_meta_boxes action instead."), '3.3');
            return (object) array('id' => '_invalid', 'base' => '_are_belong_to_us');
        }
        return self::get($hook_name);
    }
    public static function get_hidden_columns($screen)
    {
        if (is_string($screen)) {
            $screen = self::convert_to_screen($screen);
        }
    }
    public static function get_column_headers($screen)
    {
        if (is_string($screen)) {
            $screen = self::convert_to_screen($screen);
        }
        static $column_headers = array();
        if (!isset($column_headers[$screen->id])) {
            $column_headers[$screen->id] = RC_Hook::apply_filters('manage_' . $screen->id . '_columns', array());
        }
        return $column_headers[$screen->id];
    }
}
}

namespace Ecjia\App\Theme\ThemeOption\Models {
use Ecjia\System\Frameworks\Model\Model;
class TemplateOptionsModel extends Model
{
    protected $table = 'template_options';
    protected $primaryKey = 'option_id';
    protected $fillable = ['option_name', 'option_value', 'site', 'template'];
    public $timestamps = false;
}
}

namespace Ecjia\App\Theme\ThemeOption\Repositories {
use Royalcms\Component\Repository\Repositories\AbstractRepository;
class TemplateOptionsRepository extends AbstractRepository
{
    protected $model = 'Ecjia\\App\\Theme\\ThemeOption\\Models\\TemplateOptionsModel';
    protected $site = null;
    protected $template = null;
    protected $orderBy = ['option_id' => 'asc'];
    public function __construct()
    {
        parent::__construct();
        if (defined('RC_SITE') && constant('RC_SITE')) {
            $this->site = RC_SITE;
        } else {
            $this->site = '';
        }
        $this->template = \RC_Theme::get_template();
    }
    public function getOption($name)
    {
        $where = ['site' => $this->site, 'template' => $this->template, 'option_name' => $this->template];
        $option = $this->findWhereByFirst($where, ['option_name', 'option_value']);
        return $option;
    }
    public function updateOption($name, $value)
    {
        $result = $this->getModel()->where('site', $this->site)->where('template', $this->template)->where('option_name', $name)->update(['option_value' => $value]);
        return $result;
    }
    public function addOption($name, $value)
    {
        $result = $this->getModel()->insertOnDuplicateKey(['site' => $this->site, 'template' => $this->template, 'option_name' => $name, 'option_value' => $value], ['option_name' => $name, 'option_value' => $value]);
        return $result;
    }
    public function deleteOption($name)
    {
        $result = $this->getModel()->where('site', $this->site)->where('template', $this->template)->where('option_name', $name)->delete();
        return $result;
    }
    public function getAllOptions()
    {
        $options = $this->getModel()->where('site', $this->site)->where('template', $this->template)->select('option_name', 'option_value')->orderBy('option_id', 'asc')->get();
        return $options;
    }
    public function findWhereByFirst(array $where, $columns = ['*'])
    {
        $this->newQuery();
        foreach ($where as $field => $value) {
            if (is_array($value)) {
                list($field, $condition, $val) = $value;
                $this->query->where($field, $condition, $val);
            } else {
                $this->query->where($field, '=', $value);
            }
        }
        return $this->query->first($columns);
    }
    public function wherePaginate(array $where, $limit = null, $columns = ['*'])
    {
        $this->newQuery();
        foreach ($where as $field => $value) {
            if (is_array($value)) {
                list($field, $condition, $val) = $value;
                $this->query->where($field, $condition, $val);
            } else {
                $this->query->where($field, '=', $value);
            }
        }
        return $this->query->paginate($limit, $columns);
    }
}
}

namespace Ecjia\App\Theme\ThemeOption {
use Ecjia\App\Theme\ThemeOption\Repositories\TemplateOptionsRepository;
use RC_Hook;
use RC_Format;
class ThemeOption
{
    protected $repository;
    const APPCACHE_KEY = 'theme-option';
    public function __construct($repository = null)
    {
        if (is_null($repository)) {
            $this->repository = new TemplateOptionsRepository();
        } else {
            $this->repository = $repository;
        }
    }
    public function load_alloptions()
    {
        $alloptions = ecjia_cache(self::APPCACHE_KEY)->get('alloptions');
        if (!$alloptions) {
            $alloptions_db = $this->repository->getAllOptions();
            $alloptions = array();
            foreach ($alloptions_db as $o) {
                $alloptions[$o->option_name] = $o->option_value;
            }
            $alloptions = RC_Hook::apply_filters('ecjia_theme_pre_cache_alloptions', $alloptions);
            ecjia_cache(self::APPCACHE_KEY)->add('alloptions', $alloptions);
        }
        return RC_Hook::apply_filters('ecjia_theme_alloptions', $alloptions);
    }
    public function sanitize_option($option, $value)
    {
        $original_value = $value;
        return RC_Hook::apply_filters("ecjia_theme_sanitize_option_{$option}", $value, $option, $original_value);
    }
    public function get_option($option, $default = false)
    {
        $option = trim($option);
        if (empty($option)) {
            return false;
        }
        $pre = RC_Hook::apply_filters("ecjia_theme_pre_option_{$option}", false, $option, $default);
        if (false !== $pre) {
            return $pre;
        }
        $passed_default = func_num_args() > 1;
        $notoptions = ecjia_cache(self::APPCACHE_KEY)->get('notoptions');
        if (isset($notoptions[$option])) {
            return RC_Hook::apply_filters("ecjia_theme_default_option_{$option}", $default, $option, $passed_default);
        }
        $alloptions = $this->load_alloptions();
        if (isset($alloptions[$option])) {
            $value = $alloptions[$option];
        } else {
            $value = ecjia_cache(self::APPCACHE_KEY)->get($option);
            if (is_null($value)) {
                $row = $this->repository->getOption($option);
                if (is_object($row)) {
                    $value = $row->option_value;
                    ecjia_cache(self::APPCACHE_KEY)->add($option, $value, 'options');
                } else {
                    if (!is_array($notoptions)) {
                        $notoptions = array();
                    }
                    $notoptions[$option] = true;
                    ecjia_cache(self::APPCACHE_KEY)->set('notoptions', $notoptions);
                    return RC_Hook::apply_filters("ecjia_theme_default_option_{$option}", $default, $option, $passed_default);
                }
            }
        }
        return RC_Hook::apply_filters("ecjia_theme_option_{$option}", RC_Format::maybe_unserialize($value), $option);
    }
    public function protect_special_option($option)
    {
        if ('alloptions' === $option || 'notoptions' === $option) {
            rc_die(sprintf(__('%s is a protected ECJia Theme option and may not be modified'), RC_Format::esc_html($option)));
        }
    }
    public function form_option($option)
    {
        echo RC_Format::esc_attr($this->get_option($option));
    }
    public function update_option($option, $value, $autoload = null)
    {
        $option = trim($option);
        if (empty($option)) {
            return false;
        }
        $this->protect_special_option($option);
        if (is_object($value)) {
            $value = clone $value;
        }
        $value = $this->sanitize_option($option, $value);
        $old_value = $this->get_option($option);
        $value = RC_Hook::apply_filters("ecjia_theme_pre_update_option_{$option}", $value, $old_value, $option);
        $value = RC_Hook::apply_filters('ecjia_theme_pre_update_option', $value, $option, $old_value);
        if ($value === $old_value || RC_Format::maybe_serialize($value) === RC_Format::maybe_serialize($old_value)) {
            return false;
        }
        if (RC_Hook::apply_filters("ecjia_theme_default_option_{$option}", false, $option, false) === $old_value) {
            return $this->add_option($option, $value);
        }
        $serialized_value = RC_Format::maybe_serialize($value);
        RC_Hook::do_action('ecjia_theme_update_option', $option, $old_value, $value);
        $result = $this->repository->updateOption($option, $serialized_value);
        if (!$result) {
            return false;
        }
        $notoptions = ecjia_cache(self::APPCACHE_KEY)->get('notoptions');
        if (is_array($notoptions) && isset($notoptions[$option])) {
            unset($notoptions[$option]);
            ecjia_cache(self::APPCACHE_KEY)->set('notoptions', $notoptions);
        }
        $alloptions = $this->load_alloptions();
        if (isset($alloptions[$option])) {
            $alloptions[$option] = $serialized_value;
            ecjia_cache(self::APPCACHE_KEY)->set('alloptions', $alloptions);
        } else {
            ecjia_cache(self::APPCACHE_KEY)->set($option, $serialized_value);
        }
        RC_Hook::do_action("ecjia_theme_update_option_{$option}", $old_value, $value, $option);
        RC_Hook::do_action('ecjia_theme_updated_option', $option, $old_value, $value);
        return true;
    }
    public function add_option($option, $value = '', $deprecated = '', $autoload = 'yes')
    {
        if (!empty($deprecated)) {
            _deprecated_argument(__FUNCTION__, '2.3.0');
        }
        $option = trim($option);
        if (empty($option)) {
            return false;
        }
        $this->protect_special_option($option);
        if (is_object($value)) {
            $value = clone $value;
        }
        $value = $this->sanitize_option($option, $value);
        $notoptions = ecjia_cache(self::APPCACHE_KEY)->get('notoptions');
        if (!is_array($notoptions) || !isset($notoptions[$option])) {
            if (RC_Hook::apply_filters("ecjia_theme_default_option_{$option}", false, $option, false) !== $this->get_option($option)) {
                return false;
            }
        }
        $serialized_value = RC_Format::maybe_serialize($value);
        RC_Hook::do_action('ecjia_theme_add_option', $option, $value);
        $result = $this->repository->addOption($option, $serialized_value);
        if (!$result) {
            return false;
        }
        $alloptions = $this->load_alloptions();
        $alloptions[$option] = $serialized_value;
        ecjia_cache(self::APPCACHE_KEY)->set('alloptions', $alloptions);
        $notoptions = ecjia_cache(self::APPCACHE_KEY)->get('notoptions');
        if (is_array($notoptions) && isset($notoptions[$option])) {
            unset($notoptions[$option]);
            ecjia_cache(self::APPCACHE_KEY)->set('notoptions', $notoptions);
        }
        RC_Hook::do_action("ecjia_theme_add_option_{$option}", $option, $value);
        RC_Hook::do_action('ecjia_theme_added_option', $option, $value);
        return true;
    }
    public function delete_option($option)
    {
        $option = trim($option);
        if (empty($option)) {
            return false;
        }
        $this->protect_special_option($option);
        $row = $this->repository->getOption($option);
        if (is_null($row)) {
            return false;
        }
        RC_Hook::do_action('ecjia_theme_delete_option', $option);
        $result = $this->repository->deleteOption($option);
        $alloptions = $this->load_alloptions();
        if (is_array($alloptions) && isset($alloptions[$option])) {
            unset($alloptions[$option]);
            ecjia_cache(self::APPCACHE_KEY)->set('alloptions', $alloptions);
        }
        if ($result) {
            RC_Hook::do_action("ecjia_theme_delete_option_{$option}", $option);
            RC_Hook::do_action('ecjia_theme_deleted_option', $option);
            return true;
        }
        return false;
    }
}
}

namespace Ecjia\App\Theme\ThemeFramework {
use RC_Hook;
abstract class ThemeFrameworkAbstract
{
    protected $framework;
    public function __construct()
    {
        $this->framework = new ThemeFramework();
    }
    public function setFramework($framework)
    {
        $this->framework = $framework;
        return $this;
    }
    public function getFramework()
    {
        return $this->framework;
    }
    public function addAction($hook, $function_to_add, $priority = 30, $accepted_args = 1)
    {
        RC_Hook::add_action($hook, array(&$this, $function_to_add), $priority, $accepted_args);
    }
    public function addFilter($tag, $function_to_add, $priority = 30, $accepted_args = 1)
    {
        RC_Hook::add_action($tag, array(&$this, $function_to_add), $priority, $accepted_args);
    }
}
}

namespace Ecjia\App\Theme\ThemeFramework\Foundation {
use Ecjia\App\Theme\ThemeFramework\Support\Helpers;
use Ecjia\App\Theme\ThemeFramework\ThemeConstant;
use Ecjia\App\Theme\ThemeFramework\ThemeFrameworkAbstract;
use RC_Hook;
use RC_Uri;
use RC_Style;
use RC_Script;
use ecjia_theme_option;
use ecjia_theme_setting;
use ecjia_theme_transient;
class AdminPanel extends ThemeFrameworkAbstract
{
    public $unique = ThemeConstant::CS_OPTION;
    public $settings = array();
    public $options = array();
    public $sections = array();
    public $theme_options = array();
    private static $instance = null;
    public static function instance($settings = array(), $options = array())
    {
        if (is_null(self::$instance)) {
            self::$instance = new self($settings, $options);
        }
        return self::$instance;
    }
    public function __construct($settings, $options)
    {
        parent::__construct();
        $this->settings = RC_Hook::apply_filters('cs_framework_settings', $settings);
        $this->options = RC_Hook::apply_filters('cs_framework_options', $options);
        if (!empty($this->options)) {
            $this->sections = $this->getSections();
            $this->theme_options = ecjia_theme_option::load_alloptions();
            $this->addAction('admin_theme_option_nav', 'display_setting_menus');
            $this->addAction('admin_theme_option_page', 'display_theme_option_page');
            $this->addAction('admin_enqueue_scripts', 'admin_enqueue_scripts');
            $this->addFilter('template_option_default_section', 'template_option_default_section');
        }
        $this->admin_enqueue_scripts();
    }
    public function template_option_default_section()
    {
        return collect($this->sections)->keys()->first();
    }
    public function getSections()
    {
        $sections = array();
        foreach ($this->options as $key => $value) {
            if (isset($value['sections'])) {
                foreach ($value['sections'] as $section) {
                    if (isset($section['fields'])) {
                        $sections[$section['name']] = $section;
                    }
                }
            } else {
                if (isset($value['fields'])) {
                    $sections[$value['name']] = $value;
                }
            }
        }
        return $sections;
    }
    public function getSection($name)
    {
        return array_get($this->sections, $name, []);
    }
    public function display_setting_menus($name)
    {
        echo '<div class="setting-group">' . PHP_EOL;
        echo '<span class="setting-group-title"><i class="fontello-icon-cog"></i>' . $this->settings['menu_title'] . '</span>' . PHP_EOL;
        echo '<ul class="nav nav-list m_t10">' . PHP_EOL;
        foreach ($this->sections as $section) {
            echo '<li><a class="data-pjax setting-group-item';
            if ($name == $section['name']) {
                echo ' llv-active';
            }
            $url = RC_Uri::url('theme/admin_option/init', ['section' => $section['name']]);
            echo '" href="' . $url . '">' . $section['title'] . '</a></li>' . PHP_EOL;
        }
        echo '</ul>' . PHP_EOL;
        echo '</div>' . PHP_EOL;
    }
    public function display_theme_option_page($name)
    {
        $section = $this->getSection($name);
        $this->setSettingsFields($section);
        $form_action = RC_Uri::url('theme/admin_option/update', ['section' => $name]);
        echo '<form method="post" class="form-horizontal" action="' . $form_action . '" name="theForm" >' . PHP_EOL;
        echo '<fieldset>' . PHP_EOL;
        echo '<div>' . PHP_EOL;
        echo '<h3 class="heading">';
        echo $section['title'];
        echo '</h3>' . PHP_EOL;
        echo '</div>' . PHP_EOL;
        $this->displaySettingsPageSection($section);
        echo '<div class="control-group">' . PHP_EOL;
        echo '<div class="controls">' . PHP_EOL;
        echo '<input type="submit" value="" class="btn btn-gebo" />' . PHP_EOL;
        echo '</div>' . PHP_EOL;
        echo '</div>' . PHP_EOL;
        echo '</fieldset>' . PHP_EOL;
        echo '</form>' . PHP_EOL;
    }
    protected function staticsPath($path)
    {
        return $this->getFramework()->getStaticsUrl() . $path;
    }
    public function admin_enqueue_scripts()
    {
        $route = royalcms('default-router');
        if (!$route->justCurrentRoute('theme/admin_option/init')) {
            return;
        }
        RC_Style::enqueue_style('cs-framework', $this->staticsPath('/theme-framework/css/cs-framework.css'), array(), '1.0.0', 'all');
        RC_Style::enqueue_style('font-awesome', $this->staticsPath('/theme-framework/css/font-awesome.css'), array(), '4.2.0', 'all');
        if (is_rtl()) {
            RC_Style::enqueue_style('cs-framework-rtl', $this->staticsPath('/theme-framework/css/cs-framework-rtl.css'), array(), '1.0.0', 'all');
        }
        RC_Script::enqueue_script('cs-plugins', $this->staticsPath('/theme-framework/js/cs-plugins.js'), array(), '1.0.0', true);
        RC_Script::enqueue_script('cs-framework', $this->staticsPath('/theme-framework/js/cs-framework.js'), array('cs-plugins'), '1.0.0', true);
        RC_Script::enqueue_script('bootstrap-colorpicker');
        RC_Script::enqueue_script('jquery-ui-dialog');
        RC_Script::enqueue_script('jquery-ui-sortable');
        RC_Script::enqueue_script('jquery-ui-accordion');
    }
    protected function displaySettingsPageSection(array $section)
    {
        $page = $section['name'] . '_section_group';
        echo '<div class="cs-content">';
        echo '<div class="cs-sections">';
        if (isset($section['fields'])) {
            echo '<div id="cs-tab-' . $section['name'] . '" class="cs-section">';
            echo isset($section['title']) && empty($has_nav) ? '<div class="cs-section-title"><h3>' . $section['title'] . '</h3></div>' : '';
            $this->do_settings_section($page, $section);
            echo '</div>';
        }
        echo '</div>';
        echo '<div class="clear"></div>';
        echo '</div>';
    }
    protected function setSettingsFields(array $section)
    {
        $defaults = array();
        ecjia_theme_setting::register_setting($this->unique . '_group', $this->unique, array(&$this, 'validate_save'));
        if (isset($section['fields'])) {
            ecjia_theme_setting::add_settings_section($section['name'] . '_section', $section['title'], '', $section['name'] . '_section_group');
            foreach ($section['fields'] as $field_key => $field) {
                ecjia_theme_setting::add_settings_field($field_key . '_field', '', array(&$this, 'fieldCallback'), $section['name'] . '_section_group', $section['name'] . '_section', $field);
                if (isset($field['default'])) {
                    $defaults[$field['id']] = $field['default'];
                    if (!empty($this->theme_options) && !isset($this->theme_options[$field['id']])) {
                        $this->theme_options[$field['id']] = $field['default'];
                    }
                }
            }
        }
        if (empty($this->theme_options) && !empty($defaults)) {
            $this->theme_options = $defaults;
        }
    }
    public function validate_save($request)
    {
        $add_errors = array();
        $section_id = Helpers::cs_get_var('cs_section_id');
        if (isset($request['_nonce'])) {
            unset($request['_nonce']);
        }
        if (isset($request['import']) && !empty($request['import'])) {
            $decode_string = Helpers::cs_decode_string($request['import']);
            if (is_array($decode_string)) {
                return $decode_string;
            }
            $add_errors[] = $this->add_settings_error(__('Success. Imported backup options.', 'cs-framework'), 'updated');
        }
        if (isset($request['resetall'])) {
            $add_errors[] = $this->add_settings_error(__('Default options restored.', 'cs-framework'), 'updated');
            return null;
        }
        if (isset($request['reset']) && !empty($section_id)) {
            foreach ($this->sections as $value) {
                if ($value['name'] == $section_id) {
                    foreach ($value['fields'] as $field) {
                        if (isset($field['id'])) {
                            if (isset($field['default'])) {
                                $request[$field['id']] = $field['default'];
                            } else {
                                unset($request[$field['id']]);
                            }
                        }
                    }
                }
            }
            $add_errors[] = $this->add_settings_error(__('Default options restored for only this section.', 'cs-framework'), 'updated');
        }
        foreach ($this->sections as $section) {
            if (isset($section['fields'])) {
                foreach ($section['fields'] as $field) {
                    if (isset($field['type']) && !isset($field['multilang']) && isset($field['id'])) {
                        $request_value = isset($request[$field['id']]) ? $request[$field['id']] : '';
                        $sanitize_type = $field['type'];
                        if (isset($field['sanitize'])) {
                            $sanitize_type = $field['sanitize'] !== false ? $field['sanitize'] : false;
                        }
                        if ($sanitize_type !== false && RC_Hook::has_filter('cs_sanitize_' . $sanitize_type)) {
                            $request[$field['id']] = RC_Hook::apply_filters('cs_sanitize_' . $sanitize_type, $request_value, $field, $section['fields']);
                        }
                        if (isset($field['validate']) && RC_Hook::has_filter('cs_validate_' . $field['validate'])) {
                            $validate = RC_Hook::apply_filters('cs_validate_' . $field['validate'], $request_value, $field, $section['fields']);
                            if (!empty($validate)) {
                                $add_errors[] = $this->add_settings_error($validate, 'error', $field['id']);
                                $request[$field['id']] = isset($this->theme_options[$field['id']]) ? $this->theme_options[$field['id']] : '';
                            }
                        }
                    }
                    if (!isset($field['id']) || empty($request[$field['id']])) {
                        continue;
                    }
                }
            }
        }
        $request = RC_Hook::apply_filters('cs_validate_save', $request);
        RC_Hook::do_action('cs_validate_save', $request);
        ecjia_theme_transient::set_transient('cs-framework-transient', array('errors' => $add_errors, 'section_id' => $section_id), 30);
        return $request;
    }
    public function do_settings_sections($page)
    {
        $theme_settings_sections = ecjia_theme_setting::get_settings_sections($page);
        if (empty($theme_settings_sections)) {
            return;
        }
        foreach ($theme_settings_sections as $section) {
            $this->do_settings_section($page, $section);
        }
    }
    public function do_settings_section($page, $section)
    {
        if ($section['callback']) {
            call_user_func($section['callback'], $section);
        }
        $this->do_settings_fields($page, $section);
    }
    public function do_settings_fields($page, $section)
    {
        $section_id = $section['name'] . '_section';
        $theme_settings_fields = ecjia_theme_setting::get_settings_fields($page, $section_id);
        if (empty($theme_settings_fields)) {
            return;
        }
        foreach ($theme_settings_fields as $field) {
            call_user_func($field['callback'], $field['args']);
        }
    }
    public function fieldCallback($field)
    {
        $value = isset($field['id']) && isset($this->theme_options[$field['id']]) ? $this->theme_options[$field['id']] : '';
        echo $this->getFramework()->getOptionField()->addElement($field, $value, $this->unique);
    }
    public function add_settings_error($message, $type = 'error', $id = 'global')
    {
        return array('setting' => 'cs-errors', 'code' => $id, 'message' => $message, 'type' => $type);
    }
}
}

namespace Ecjia\App\Theme\ThemeFramework {
class OptionField
{
    protected $framework;
    protected $fields = [];
    protected $current;
    public function __construct($framework)
    {
        $this->framework = $framework;
        $this->fields = config('app-theme::fields');
    }
    public function getFeildClass($type)
    {
        return array_get($this->fields, $type);
    }
    public function addElement($field = array(), $value = '', $unique = '')
    {
        $output = '';
        $depend = '';
        $sub = isset($field['sub']) ? 'sub-' : '';
        $unique = isset($unique) ? $unique : '';
        $languages = $this->framework->language_defaults();
        $class = $this->getFeildClass($field['type']);
        $wrap_class = isset($field['wrap_class']) ? ' ' . $field['wrap_class'] : '';
        $hidden = isset($field['show_only_language']) && $field['show_only_language'] != $languages['current'] ? ' hidden' : '';
        $is_pseudo = isset($field['pseudo']) ? ' cs-pseudo-field' : '';
        if (isset($field['dependency'])) {
            $hidden = ' hidden';
            $depend .= ' data-' . $sub . 'controller="' . $field['dependency'][0] . '"';
            $depend .= ' data-' . $sub . 'condition="' . $field['dependency'][1] . '"';
            $depend .= ' data-' . $sub . 'value="' . $field['dependency'][2] . '"';
        }
        $output .= '<div class="cs-element cs-field-' . $field['type'] . $is_pseudo . $wrap_class . $hidden . '"' . $depend . '>';
        if (isset($field['title'])) {
            $field_desc = isset($field['desc']) ? '<p class="cs-text-desc">' . $field['desc'] . '</p>' : '';
            $output .= '<div class="cs-title"><h4>' . $field['title'] . '</h4>' . $field_desc . '</div>';
        }
        $output .= isset($field['title']) ? '<div class="cs-fieldset">' : '';
        $value = !isset($value) && isset($field['default']) ? $field['default'] : $value;
        $value = isset($field['value']) ? $field['value'] : $value;
        if (class_exists($class)) {
            ob_start();
            $element = new $class($field, $value, $unique);
            $element->output();
            $output .= ob_get_clean();
        } else {
            $output .= '<p>' . __('This field class is not available!', 'theme-framework') . '</p>';
        }
        $output .= isset($field['title']) ? '</div>' : '';
        $output .= '<div class="clear"></div>';
        $output .= '</div>';
        return $output;
    }
}
}

namespace Ecjia\App\Theme\ThemeFramework {
class ThemeConstant
{
    const CS_VERSION = '1.0.1';
    const CS_OPTION = '_cs_options';
    const CS_CUSTOMIZE = '_cs_customize_options';
}
}

namespace Ecjia\App\Theme\Facades {
use Royalcms\Component\Support\Facades\Facade;
class EcjiaThemeOption extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.theme.option';
    }
}
}

namespace Ecjia\App\Theme\Facades {
use Royalcms\Component\Support\Facades\Facade;
class EcjiaThemeFramework extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'ecjia.theme.framework';
    }
}
}

